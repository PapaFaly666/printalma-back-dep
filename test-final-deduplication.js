const { PrismaClient } = require('@prisma/client');
const crypto = require('crypto');

const prisma = new PrismaClient();

async function testFinalDeduplication() {
  console.log('üß™ Test final de d√©duplication globale des designs avec brouillons...\n');

  try {
    // 1. Cr√©er deux vendeurs de test
    const vendor1 = await prisma.user.create({
      data: {
        firstName: 'Vendeur',
        lastName: 'Un',
        email: 'test-vendor1-final@example.com',
        password: 'hashedpassword',
        role: 'VENDEUR'
      }
    });

    const vendor2 = await prisma.user.create({
      data: {
        firstName: 'Vendeur',
        lastName: 'Deux',
        email: 'test-vendor2-final@example.com',
        password: 'hashedpassword',
        role: 'VENDEUR'
      }
    });

    console.log(`‚úÖ Vendeur 1 cr√©√©: ${vendor1.id}`);
    console.log(`‚úÖ Vendeur 2 cr√©√©: ${vendor2.id}`);

    // 2. Cr√©er un admin
    const admin = await prisma.user.create({
      data: {
        firstName: 'Admin',
        lastName: 'Test',
        email: 'test-admin-final@example.com',
        password: 'hashedpassword',
        role: 'ADMIN'
      }
    });

    console.log(`‚úÖ Admin cr√©√©: ${admin.id}`);

    // 3. Cr√©er un produit de base
    const baseProduct = await prisma.product.upsert({
      where: { id: 999 },
      update: {},
      create: {
        id: 999,
        name: 'T-shirt Test Final',
        description: 'Produit de base pour test',
        price: 15000,
        stock: 100,
        status: 'PUBLISHED'
      }
    });

    console.log(`‚úÖ Produit de base cr√©√©: ${baseProduct.id}`);

    // 4. Design de test (m√™me contenu pour les deux vendeurs)
    const testDesignBase64 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==';
    const designContent = testDesignBase64.replace(/^data:image\/[a-z]+;base64,/, '');
    const designHash = crypto.createHash('sha256').update(designContent).digest('hex');

    console.log(`üé® Hash du design: ${designHash.substring(0, 12)}...`);

    // 5. Test de d√©duplication globale
    console.log('\nüì¶ Test 1: D√©duplication globale entre vendeurs...');
    
    // Vendeur 1 cr√©e un produit avec AUTO_PUBLISH
    const design1 = await createOrFindDesign(designHash, vendor1.id);
    const product1 = await createProductWithDesign(design1.id, vendor1.id, baseProduct.id, 'AUTO_PUBLISH');
    console.log(`‚úÖ Vendeur 1 - Design: ${design1.id} (nouveau: ${design1.isNew}), Produit: ${product1.id}`);

    // Vendeur 2 cr√©e un produit avec TO_DRAFT (m√™me design)
    const design2 = await createOrFindDesign(designHash, vendor2.id);
    const product2 = await createProductWithDesign(design2.id, vendor2.id, baseProduct.id, 'TO_DRAFT');
    console.log(`‚úÖ Vendeur 2 - Design: ${design2.id} (nouveau: ${design2.isNew}), Produit: ${product2.id}`);

    // V√©rifier la d√©duplication globale
    if (design1.id === design2.id) {
      console.log(`‚úÖ SUCC√àS: Design r√©utilis√© globalement (ID: ${design1.id})`);
    } else {
      console.log(`‚ùå √âCHEC: Designs diff√©rents (${design1.id} vs ${design2.id})`);
      return;
    }

    // 6. Test de cascade validation avec brouillons
    console.log('\nüîÑ Test 2: Cascade validation avec gestion des brouillons...');
    
    // Valider le design
    await prisma.design.update({
      where: { id: design1.id },
      data: {
        isValidated: true,
        validatedAt: new Date(),
        validatedBy: admin.id,
        isPending: false
      }
    });

    console.log(`‚úÖ Design ${design1.id} valid√© par admin ${admin.id}`);

    // Simuler la cascade validation
    const cascadeResult = await simulateCascadeValidation(design1.id);
    console.log(`üìä Cascade: ${cascadeResult.publishedProducts} publi√©s, ${cascadeResult.draftProducts} en brouillon`);

    // 7. V√©rifier les r√©sultats
    const updatedProduct1 = await prisma.vendorProduct.findUnique({
      where: { id: product1.id }
    });

    const updatedProduct2 = await prisma.vendorProduct.findUnique({
      where: { id: product2.id }
    });

    console.log(`Produit 1 (AUTO_PUBLISH) - isValidated: ${updatedProduct1.isValidated}, status: ${updatedProduct1.status}`);
    console.log(`Produit 2 (TO_DRAFT) - isValidated: ${updatedProduct2.isValidated}, status: ${updatedProduct2.status}`);

    // V√©rifier les r√©sultats
    let success = true;

    if (updatedProduct1.isValidated && updatedProduct1.status === 'PUBLISHED') {
      console.log('‚úÖ Produit 1: Valid√© et publi√© automatiquement (AUTO_PUBLISH)');
    } else {
      console.log('‚ùå Produit 1: Probl√®me cascade validation');
      success = false;
    }

    if (updatedProduct2.isValidated && updatedProduct2.status === 'DRAFT') {
      console.log('‚úÖ Produit 2: Valid√© et en brouillon (TO_DRAFT)');
    } else {
      console.log('‚ùå Produit 2: Probl√®me cascade validation');
      success = false;
    }

    // 8. Test de publication manuelle d'un brouillon
    console.log('\nüì§ Test 3: Publication manuelle d\'un produit en brouillon...');
    
    const publishResult = await publishDraftProduct(product2.id, vendor2.id);
    console.log(`‚úÖ Publication brouillon: ${publishResult.message}`);

    // V√©rifier que le produit est maintenant publi√©
    const finalProduct2 = await prisma.vendorProduct.findUnique({
      where: { id: product2.id }
    });

    if (finalProduct2.status === 'PUBLISHED') {
      console.log('‚úÖ Produit 2: Publi√© manuellement avec succ√®s');
    } else {
      console.log('‚ùå Produit 2: √âchec publication manuelle');
      success = false;
    }

    // 9. Statistiques finales
    console.log('\nüìä Statistiques finales...');
    
    const totalDesigns = await prisma.design.count({
      where: { 
        OR: [
          { vendorId: vendor1.id },
          { vendorId: vendor2.id }
        ]
      }
    });
    
    const totalProducts = await prisma.vendorProduct.count({
      where: { 
        vendorId: { in: [vendor1.id, vendor2.id] }
      }
    });
    
    const totalLinks = await prisma.designProductLink.count({
      where: {
        vendorProduct: {
          vendorId: { in: [vendor1.id, vendor2.id] }
        }
      }
    });

    console.log(`Designs cr√©√©s: ${totalDesigns}`);
    console.log(`Produits cr√©√©s: ${totalProducts}`);
    console.log(`Liens cr√©√©s: ${totalLinks}`);

    if (success) {
      console.log('\nüéâ Test termin√© avec succ√®s !');
      console.log('‚úÖ D√©duplication globale fonctionne correctement');
      console.log('‚úÖ Cascade validation avec brouillons fonctionne');
      console.log('‚úÖ Publication manuelle des brouillons fonctionne');
    } else {
      console.log('\n‚ùå Test √©chou√© - Voir les erreurs ci-dessus');
    }

  } catch (error) {
    console.error('‚ùå Erreur durant le test:', error);
  } finally {
    await cleanup();
    await prisma.$disconnect();
  }
}

async function createOrFindDesign(contentHash, vendorId) {
  // Chercher un design existant avec ce hash (global)
  let design = await prisma.design.findFirst({
    where: {
      contentHash: contentHash
    }
  });

  if (design) {
    return { ...design, isNew: false };
  }

  // Cr√©er un nouveau design
  design = await prisma.design.create({
    data: {
      vendorId: vendorId, // Premier vendeur √† utiliser ce design
      name: `Design ${contentHash.substring(0, 8)}`,
      description: `Design partag√© - Hash: ${contentHash.substring(0, 12)}`,
      price: 0,
      category: 'ILLUSTRATION',
      imageUrl: `https://example.com/global_design_${contentHash.substring(0, 12)}.jpg`,
      thumbnailUrl: `https://example.com/global_design_${contentHash.substring(0, 12)}_thumb.jpg`,
      cloudinaryPublicId: `global_design_${contentHash.substring(0, 12)}`,
      fileSize: 1000,
      originalFileName: `global_design_${contentHash.substring(0, 12)}`,
      contentHash: contentHash,
      dimensions: { width: 500, height: 500 },
      format: 'jpg',
      tags: ['vendor-created', 'global-design'],
      isDraft: false,
      isPublished: false,
      isPending: true,
      isValidated: false
    }
  });

  return { ...design, isNew: true };
}

async function createProductWithDesign(designId, vendorId, baseProductId, postValidationAction) {
  const vendorProduct = await prisma.vendorProduct.create({
    data: {
      baseProductId: baseProductId,
      vendorId: vendorId,
      name: `Produit Test ${postValidationAction}`,
      description: `Produit avec action ${postValidationAction}`,
      price: 25000,
      stock: 100,
      designId: designId,
      designCloudinaryUrl: `https://example.com/design_${designId}.jpg`,
      designCloudinaryPublicId: `design_${designId}`,
      sizes: JSON.stringify([{ id: 1, name: 'M' }]),
      colors: JSON.stringify([{ id: 1, name: 'Rouge', code: '#ff0000' }]),
      status: postValidationAction === 'TO_DRAFT' ? 'DRAFT' : 'PENDING',
      isValidated: false,
      postValidationAction: postValidationAction,
      adminProductName: 'T-shirt Test Final',
      adminProductDescription: 'Produit de base pour test',
      adminProductPrice: 15000,
      vendorName: `Produit Test ${postValidationAction}`,
      vendorDescription: `Produit avec action ${postValidationAction}`,
      vendorStock: 100,
      basePriceAdmin: 15000
    }
  });

  // Cr√©er le lien design-produit
  await prisma.designProductLink.create({
    data: {
      designId: designId,
      vendorProductId: vendorProduct.id
    }
  });

  return vendorProduct;
}

async function simulateCascadeValidation(designId) {
  console.log(`üîÑ Simulation cascade validation pour design ${designId}...`);

  // R√©cup√©rer tous les produits li√©s √† ce design
  const linkedProducts = await prisma.vendorProduct.findMany({
    where: { designId: designId }
  });

  console.log(`üì¶ ${linkedProducts.length} produits li√©s trouv√©s`);

  let publishedCount = 0;
  let draftCount = 0;

  // Mettre √† jour chaque produit selon son action post-validation
  for (const product of linkedProducts) {
    let newStatus;
    
    if (product.postValidationAction === 'TO_DRAFT') {
      newStatus = 'DRAFT';
      draftCount++;
    } else {
      newStatus = 'PUBLISHED';
      publishedCount++;
    }
    
    await prisma.vendorProduct.update({
      where: { id: product.id },
      data: {
        isValidated: true,
        validatedAt: new Date(),
        status: newStatus,
        rejectionReason: null
      }
    });

    console.log(`‚úÖ Produit ${product.id}: ${product.postValidationAction} ‚Üí ${newStatus}`);
  }

  return { publishedCount, draftCount };
}

async function publishDraftProduct(productId, vendorId) {
  console.log(`üì§ Publication produit brouillon ${productId} par vendeur ${vendorId}`);

  // V√©rifier que le produit appartient au vendeur et est en brouillon valid√©
  const product = await prisma.vendorProduct.findFirst({
    where: {
      id: productId,
      vendorId: vendorId,
      status: 'DRAFT',
      isValidated: true
    }
  });

  if (!product) {
    throw new Error('Produit non trouv√© ou non √©ligible √† la publication');
  }

  // Publier le produit
  await prisma.vendorProduct.update({
    where: { id: productId },
    data: {
      status: 'PUBLISHED',
      updatedAt: new Date()
    }
  });

  return {
    success: true,
    message: 'Produit publi√© avec succ√®s',
    newStatus: 'PUBLISHED'
  };
}

async function cleanup() {
  console.log('üßπ Nettoyage des donn√©es de test...');

  try {
    // Supprimer dans l'ordre pour √©viter les contraintes
    await prisma.designProductLink.deleteMany({
      where: {
        vendorProduct: {
          vendor: {
            email: {
              in: [
                'test-vendor1-final@example.com',
                'test-vendor2-final@example.com'
              ]
            }
          }
        }
      }
    });

    await prisma.vendorProduct.deleteMany({
      where: {
        vendor: {
          email: {
            in: [
              'test-vendor1-final@example.com',
              'test-vendor2-final@example.com'
            ]
          }
        }
      }
    });

    await prisma.design.deleteMany({
      where: {
        vendor: {
          email: {
            in: [
              'test-vendor1-final@example.com',
              'test-vendor2-final@example.com'
            ]
          }
        }
      }
    });

    await prisma.product.deleteMany({
      where: {
        OR: [
          { name: 'T-shirt Test Final' },
          { id: 999 }
        ]
      }
    });

    await prisma.user.deleteMany({
      where: {
        email: {
          in: [
            'test-vendor1-final@example.com',
            'test-vendor2-final@example.com',
            'test-admin-final@example.com'
          ]
        }
      }
    });

    console.log('‚úÖ Nettoyage termin√©');

  } catch (error) {
    console.error('‚ùå Erreur lors du nettoyage:', error);
  }
}

// Ex√©cuter le test
if (require.main === module) {
  testFinalDeduplication()
    .then(() => {
      console.log('\nüéâ Tous les tests termin√©s !');
      process.exit(0);
    })
    .catch((error) => {
      console.error('üí• Erreur fatale:', error);
      process.exit(1);
    });
}

module.exports = { testFinalDeduplication }; 