const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient();

async function migrateToMockupsByColor() {
  console.log('üîÑ === MIGRATION VERS ARCHITECTURE MOCKUPS PAR COULEUR ===\n');

  try {
    // 1. Statistiques initiales
    console.log('üìä === STATISTIQUES INITIALES ===');
    
    const [totalProducts, productsWithDesign, existingMockups, legacyImages] = await Promise.all([
      prisma.vendorProduct.count(),
      prisma.vendorProduct.count({ where: { designId: { not: null } } }),
      prisma.vendorProductMockup.count(),
      prisma.vendorProductImage.count()
    ]);

    console.log(`üì¶ Total produits vendeur: ${totalProducts}`);
    console.log(`üé® Produits avec design r√©f√©renc√©: ${productsWithDesign}`);
    console.log(`üñºÔ∏è Mockups nouvelle architecture: ${existingMockups}`);
    console.log(`üì∑ Images ancienne architecture: ${legacyImages}\n`);

    // 2. Migration des produits sans designId
    console.log('üîß === MIGRATION PRODUITS SANS DESIGN ID ===');
    
    const productsWithoutDesign = await prisma.vendorProduct.findMany({
      where: { designId: null },
      include: {
        vendor: {
          select: { id: true, firstName: true, lastName: true }
        }
      }
    });

    console.log(`üîç ${productsWithoutDesign.length} produits sans designId trouv√©s`);

    let designsCreated = 0;
    let designLinkingErrors = 0;

    for (const product of productsWithoutDesign) {
      try {
        // Cr√©er un design automatique pour ce produit
        const autoDesign = await prisma.design.create({
          data: {
            vendorId: product.vendorId,
            name: `Design auto - ${product.vendorName || 'Produit'} #${product.id}`,
            description: `Design g√©n√©r√© automatiquement lors de la migration vers l'architecture mockups par couleur`,
            price: Math.max(product.price * 0.7, 5000), // 70% du prix produit ou minimum 5000
            category: 'ABSTRACT',
            imageUrl: product.designUrl || product.originalDesignUrl || 'https://via.placeholder.com/500x500?text=Design+Auto',
            thumbnailUrl: product.designUrl || product.originalDesignUrl || 'https://via.placeholder.com/250x250?text=Thumb',
            cloudinaryPublicId: `auto_design_migration_${product.id}_${Date.now()}`,
            fileSize: 100000,
            originalFileName: `migration_design_${product.id}.jpg`,
            dimensions: { width: 500, height: 500 },
            format: 'jpg',
            tags: ['auto-generated', 'migration', 'v2-architecture'],
            
            // Copier les statuts du produit
            isDraft: product.status === 'DRAFT',
            isPublished: product.status === 'PUBLISHED',
            isPending: product.status === 'PENDING',
            isValidated: product.isValidated,
            validatedAt: product.validatedAt,
            validatedBy: product.validatedBy,
            
            // Statistiques initiales
            views: 0,
            likes: 0,
            earnings: 0,
            usageCount: 1
          }
        });

        // Lier le design au produit
        await prisma.vendorProduct.update({
          where: { id: product.id },
          data: { designId: autoDesign.id }
        });

        designsCreated++;
        console.log(`‚úÖ Design auto cr√©√© pour produit ${product.id}: Design ID ${autoDesign.id}`);

      } catch (error) {
        designLinkingErrors++;
        console.error(`‚ùå Erreur cr√©ation design pour produit ${product.id}:`, error.message);
      }
    }

    console.log(`üìä Designs cr√©√©s: ${designsCreated}, Erreurs: ${designLinkingErrors}\n`);

    // 3. Migration des images vers mockups par couleur
    console.log('üñºÔ∏è === MIGRATION IMAGES VERS MOCKUPS PAR COULEUR ===');
    
    const productsWithImages = await prisma.vendorProduct.findMany({
      where: {
        AND: [
          { designId: { not: null } },
          { images: { some: {} } }
        ]
      },
      include: {
        images: {
          where: { imageType: 'color' },
          orderBy: { createdAt: 'asc' }
        },
        design: {
          select: { id: true, name: true }
        }
      }
    });

    console.log(`üîç ${productsWithImages.length} produits avec images √† migrer`);

    let mockupsCreated = 0;
    let mockupErrors = 0;

    for (const product of productsWithImages) {
      try {
        // D√©coder les couleurs s√©lectionn√©es
        let selectedColors = [];
        try {
          selectedColors = JSON.parse(product.colors);
        } catch (error) {
          console.warn(`‚ö†Ô∏è Couleurs invalides pour produit ${product.id}, ignor√©`);
          continue;
        }

        // Cr√©er des mockups pour chaque couleur ayant une image
        for (const color of selectedColors) {
          // Trouver l'image correspondante
          const correspondingImage = product.images.find(img => 
            img.colorId === color.id
          );

          if (correspondingImage) {
            try {
              // Cr√©er le mockup dans la nouvelle table
              await prisma.vendorProductMockup.upsert({
                where: {
                  unique_product_color: {
                    vendorProductId: product.id,
                    colorId: color.id
                  }
                },
                update: {
                  mockupUrl: correspondingImage.cloudinaryUrl,
                  mockupPublicId: correspondingImage.cloudinaryPublicId,
                  width: correspondingImage.width,
                  height: correspondingImage.height,
                  format: correspondingImage.format,
                  fileSize: correspondingImage.fileSize,
                  generationStatus: 'COMPLETED',
                  generatedAt: correspondingImage.uploadedAt
                },
                create: {
                  vendorProductId: product.id,
                  colorId: color.id,
                  colorName: color.name,
                  colorCode: color.colorCode,
                  mockupUrl: correspondingImage.cloudinaryUrl,
                  mockupPublicId: correspondingImage.cloudinaryPublicId,
                  width: correspondingImage.width,
                  height: correspondingImage.height,
                  format: correspondingImage.format,
                  fileSize: correspondingImage.fileSize,
                  generationStatus: 'COMPLETED',
                  generatedAt: correspondingImage.uploadedAt
                }
              });

              mockupsCreated++;
              console.log(`‚úÖ Mockup migr√©: Produit ${product.id} - Couleur ${color.name}`);

            } catch (error) {
              mockupErrors++;
              console.error(`‚ùå Erreur cr√©ation mockup ${product.id}-${color.id}:`, error.message);
            }
          }
        }

      } catch (error) {
        console.error(`‚ùå Erreur migration produit ${product.id}:`, error.message);
      }
    }

    console.log(`üìä Mockups cr√©√©s: ${mockupsCreated}, Erreurs: ${mockupErrors}\n`);

    // 4. G√©n√©rer les mockups manquants
    console.log('üé® === G√âN√âRATION MOCKUPS MANQUANTS ===');
    
    const productsNeedingMockups = await prisma.vendorProduct.findMany({
      where: {
        AND: [
          { designId: { not: null } },
          { 
            OR: [
              { mockups: { none: {} } },
              { 
                mockups: {
                  some: { generationStatus: 'FAILED' }
                }
              }
            ]
          }
        ]
      },
      include: {
        design: {
          select: { id: true, imageUrl: true, isValidated: true }
        }
      }
    });

    console.log(`üîç ${productsNeedingMockups.length} produits n√©cessitent la g√©n√©ration de mockups`);

    let mockupsGenerated = 0;
    let generationErrors = 0;

    for (const product of productsNeedingMockups) {
      try {
        if (!product.design?.isValidated) {
          console.log(`‚è≠Ô∏è Produit ${product.id} ignor√©: design non valid√©`);
          continue;
        }

        // D√©coder les couleurs
        let selectedColors = [];
        try {
          selectedColors = JSON.parse(product.colors);
        } catch (error) {
          console.warn(`‚ö†Ô∏è Couleurs invalides pour produit ${product.id}, ignor√©`);
          continue;
        }

        // Cr√©er des mockups placeholder pour chaque couleur
        for (const color of selectedColors) {
          try {
            await prisma.vendorProductMockup.upsert({
              where: {
                unique_product_color: {
                  vendorProductId: product.id,
                  colorId: color.id
                }
              },
              update: {
                generationStatus: 'COMPLETED',
                generatedAt: new Date()
              },
              create: {
                vendorProductId: product.id,
                colorId: color.id,
                colorName: color.name,
                colorCode: color.colorCode,
                // Utiliser le design original comme fallback
                mockupUrl: product.design.imageUrl,
                mockupPublicId: `fallback_${product.id}_${color.id}`,
                generationStatus: 'COMPLETED',
                generatedAt: new Date()
              }
            });

            mockupsGenerated++;
            console.log(`‚úÖ Mockup fallback cr√©√©: Produit ${product.id} - Couleur ${color.name}`);

          } catch (error) {
            generationErrors++;
            console.error(`‚ùå Erreur g√©n√©ration fallback ${product.id}-${color.id}:`, error.message);
          }
        }

      } catch (error) {
        console.error(`‚ùå Erreur g√©n√©ration produit ${product.id}:`, error.message);
      }
    }

    console.log(`üìä Mockups g√©n√©r√©s: ${mockupsGenerated}, Erreurs: ${generationErrors}\n`);

    // 5. Statistiques finales
    console.log('üìä === STATISTIQUES FINALES ===');
    
    const [
      finalTotalProducts,
      finalProductsWithDesign,
      finalMockups,
      completedMockups,
      failedMockups
    ] = await Promise.all([
      prisma.vendorProduct.count(),
      prisma.vendorProduct.count({ where: { designId: { not: null } } }),
      prisma.vendorProductMockup.count(),
      prisma.vendorProductMockup.count({ where: { generationStatus: 'COMPLETED' } }),
      prisma.vendorProductMockup.count({ where: { generationStatus: 'FAILED' } })
    ]);

    console.log(`üì¶ Total produits vendeur: ${finalTotalProducts}`);
    console.log(`üé® Produits avec design: ${finalProductsWithDesign} (${Math.round((finalProductsWithDesign/finalTotalProducts)*100)}%)`);
    console.log(`üñºÔ∏è Total mockups: ${finalMockups}`);
    console.log(`‚úÖ Mockups compl√©t√©s: ${completedMockups}`);
    console.log(`‚ùå Mockups √©chou√©s: ${failedMockups}`);

    const migrationSuccess = finalProductsWithDesign === finalTotalProducts && completedMockups > 0;

    console.log('\nüéâ === R√âSUM√â MIGRATION ===');
    console.log(`Migration r√©ussie: ${migrationSuccess ? '‚úÖ OUI' : '‚ùå NON'}`);
    console.log(`Designs cr√©√©s automatiquement: ${designsCreated}`);
    console.log(`Mockups migr√©s depuis images: ${mockupsCreated}`);
    console.log(`Mockups fallback g√©n√©r√©s: ${mockupsGenerated}`);
    console.log(`Erreurs totales: ${designLinkingErrors + mockupErrors + generationErrors}`);

    if (migrationSuccess) {
      console.log('\n‚úÖ MIGRATION TERMIN√âE AVEC SUCC√àS !');
      console.log('üé® Architecture v2_mockups_by_color op√©rationnelle');
      console.log('üîß Vous pouvez maintenant utiliser les nouveaux endpoints');
      console.log('üì± Le frontend peut utiliser la nouvelle structure de donn√©es');
    } else {
      console.log('\n‚ö†Ô∏è MIGRATION PARTIELLEMENT R√âUSSIE');
      console.log('üõ†Ô∏è V√©rifiez les erreurs ci-dessus et relancez si n√©cessaire');
      console.log('üìù Certains produits peuvent n√©cessiter une intervention manuelle');
    }

  } catch (error) {
    console.error('‚ùå Erreur lors de la migration:', error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

// Ex√©cution
if (require.main === module) {
  migrateToMockupsByColor()
    .then(() => {
      console.log('\nüöÄ Migration termin√©e');
      process.exit(0);
    })
    .catch((error) => {
      console.error('\nüí• Migration √©chou√©e:', error);
      process.exit(1);
    });
}

module.exports = { migrateToMockupsByColor }; 

const prisma = new PrismaClient();

async function migrateToMockupsByColor() {
  console.log('üîÑ === MIGRATION VERS ARCHITECTURE MOCKUPS PAR COULEUR ===\n');

  try {
    // 1. Statistiques initiales
    console.log('üìä === STATISTIQUES INITIALES ===');
    
    const [totalProducts, productsWithDesign, existingMockups, legacyImages] = await Promise.all([
      prisma.vendorProduct.count(),
      prisma.vendorProduct.count({ where: { designId: { not: null } } }),
      prisma.vendorProductMockup.count(),
      prisma.vendorProductImage.count()
    ]);

    console.log(`üì¶ Total produits vendeur: ${totalProducts}`);
    console.log(`üé® Produits avec design r√©f√©renc√©: ${productsWithDesign}`);
    console.log(`üñºÔ∏è Mockups nouvelle architecture: ${existingMockups}`);
    console.log(`üì∑ Images ancienne architecture: ${legacyImages}\n`);

    // 2. Migration des produits sans designId
    console.log('üîß === MIGRATION PRODUITS SANS DESIGN ID ===');
    
    const productsWithoutDesign = await prisma.vendorProduct.findMany({
      where: { designId: null },
      include: {
        vendor: {
          select: { id: true, firstName: true, lastName: true }
        }
      }
    });

    console.log(`üîç ${productsWithoutDesign.length} produits sans designId trouv√©s`);

    let designsCreated = 0;
    let designLinkingErrors = 0;

    for (const product of productsWithoutDesign) {
      try {
        // Cr√©er un design automatique pour ce produit
        const autoDesign = await prisma.design.create({
          data: {
            vendorId: product.vendorId,
            name: `Design auto - ${product.vendorName || 'Produit'} #${product.id}`,
            description: `Design g√©n√©r√© automatiquement lors de la migration vers l'architecture mockups par couleur`,
            price: Math.max(product.price * 0.7, 5000), // 70% du prix produit ou minimum 5000
            category: 'ABSTRACT',
            imageUrl: product.designUrl || product.originalDesignUrl || 'https://via.placeholder.com/500x500?text=Design+Auto',
            thumbnailUrl: product.designUrl || product.originalDesignUrl || 'https://via.placeholder.com/250x250?text=Thumb',
            cloudinaryPublicId: `auto_design_migration_${product.id}_${Date.now()}`,
            fileSize: 100000,
            originalFileName: `migration_design_${product.id}.jpg`,
            dimensions: { width: 500, height: 500 },
            format: 'jpg',
            tags: ['auto-generated', 'migration', 'v2-architecture'],
            
            // Copier les statuts du produit
            isDraft: product.status === 'DRAFT',
            isPublished: product.status === 'PUBLISHED',
            isPending: product.status === 'PENDING',
            isValidated: product.isValidated,
            validatedAt: product.validatedAt,
            validatedBy: product.validatedBy,
            
            // Statistiques initiales
            views: 0,
            likes: 0,
            earnings: 0,
            usageCount: 1
          }
        });

        // Lier le design au produit
        await prisma.vendorProduct.update({
          where: { id: product.id },
          data: { designId: autoDesign.id }
        });

        designsCreated++;
        console.log(`‚úÖ Design auto cr√©√© pour produit ${product.id}: Design ID ${autoDesign.id}`);

      } catch (error) {
        designLinkingErrors++;
        console.error(`‚ùå Erreur cr√©ation design pour produit ${product.id}:`, error.message);
      }
    }

    console.log(`üìä Designs cr√©√©s: ${designsCreated}, Erreurs: ${designLinkingErrors}\n`);

    // 3. Migration des images vers mockups par couleur
    console.log('üñºÔ∏è === MIGRATION IMAGES VERS MOCKUPS PAR COULEUR ===');
    
    const productsWithImages = await prisma.vendorProduct.findMany({
      where: {
        AND: [
          { designId: { not: null } },
          { images: { some: {} } }
        ]
      },
      include: {
        images: {
          where: { imageType: 'color' },
          orderBy: { createdAt: 'asc' }
        },
        design: {
          select: { id: true, name: true }
        }
      }
    });

    console.log(`üîç ${productsWithImages.length} produits avec images √† migrer`);

    let mockupsCreated = 0;
    let mockupErrors = 0;

    for (const product of productsWithImages) {
      try {
        // D√©coder les couleurs s√©lectionn√©es
        let selectedColors = [];
        try {
          selectedColors = JSON.parse(product.colors);
        } catch (error) {
          console.warn(`‚ö†Ô∏è Couleurs invalides pour produit ${product.id}, ignor√©`);
          continue;
        }

        // Cr√©er des mockups pour chaque couleur ayant une image
        for (const color of selectedColors) {
          // Trouver l'image correspondante
          const correspondingImage = product.images.find(img => 
            img.colorId === color.id
          );

          if (correspondingImage) {
            try {
              // Cr√©er le mockup dans la nouvelle table
              await prisma.vendorProductMockup.upsert({
                where: {
                  unique_product_color: {
                    vendorProductId: product.id,
                    colorId: color.id
                  }
                },
                update: {
                  mockupUrl: correspondingImage.cloudinaryUrl,
                  mockupPublicId: correspondingImage.cloudinaryPublicId,
                  width: correspondingImage.width,
                  height: correspondingImage.height,
                  format: correspondingImage.format,
                  fileSize: correspondingImage.fileSize,
                  generationStatus: 'COMPLETED',
                  generatedAt: correspondingImage.uploadedAt
                },
                create: {
                  vendorProductId: product.id,
                  colorId: color.id,
                  colorName: color.name,
                  colorCode: color.colorCode,
                  mockupUrl: correspondingImage.cloudinaryUrl,
                  mockupPublicId: correspondingImage.cloudinaryPublicId,
                  width: correspondingImage.width,
                  height: correspondingImage.height,
                  format: correspondingImage.format,
                  fileSize: correspondingImage.fileSize,
                  generationStatus: 'COMPLETED',
                  generatedAt: correspondingImage.uploadedAt
                }
              });

              mockupsCreated++;
              console.log(`‚úÖ Mockup migr√©: Produit ${product.id} - Couleur ${color.name}`);

            } catch (error) {
              mockupErrors++;
              console.error(`‚ùå Erreur cr√©ation mockup ${product.id}-${color.id}:`, error.message);
            }
          }
        }

      } catch (error) {
        console.error(`‚ùå Erreur migration produit ${product.id}:`, error.message);
      }
    }

    console.log(`üìä Mockups cr√©√©s: ${mockupsCreated}, Erreurs: ${mockupErrors}\n`);

    // 4. G√©n√©rer les mockups manquants
    console.log('üé® === G√âN√âRATION MOCKUPS MANQUANTS ===');
    
    const productsNeedingMockups = await prisma.vendorProduct.findMany({
      where: {
        AND: [
          { designId: { not: null } },
          { 
            OR: [
              { mockups: { none: {} } },
              { 
                mockups: {
                  some: { generationStatus: 'FAILED' }
                }
              }
            ]
          }
        ]
      },
      include: {
        design: {
          select: { id: true, imageUrl: true, isValidated: true }
        }
      }
    });

    console.log(`üîç ${productsNeedingMockups.length} produits n√©cessitent la g√©n√©ration de mockups`);

    let mockupsGenerated = 0;
    let generationErrors = 0;

    for (const product of productsNeedingMockups) {
      try {
        if (!product.design?.isValidated) {
          console.log(`‚è≠Ô∏è Produit ${product.id} ignor√©: design non valid√©`);
          continue;
        }

        // D√©coder les couleurs
        let selectedColors = [];
        try {
          selectedColors = JSON.parse(product.colors);
        } catch (error) {
          console.warn(`‚ö†Ô∏è Couleurs invalides pour produit ${product.id}, ignor√©`);
          continue;
        }

        // Cr√©er des mockups placeholder pour chaque couleur
        for (const color of selectedColors) {
          try {
            await prisma.vendorProductMockup.upsert({
              where: {
                unique_product_color: {
                  vendorProductId: product.id,
                  colorId: color.id
                }
              },
              update: {
                generationStatus: 'COMPLETED',
                generatedAt: new Date()
              },
              create: {
                vendorProductId: product.id,
                colorId: color.id,
                colorName: color.name,
                colorCode: color.colorCode,
                // Utiliser le design original comme fallback
                mockupUrl: product.design.imageUrl,
                mockupPublicId: `fallback_${product.id}_${color.id}`,
                generationStatus: 'COMPLETED',
                generatedAt: new Date()
              }
            });

            mockupsGenerated++;
            console.log(`‚úÖ Mockup fallback cr√©√©: Produit ${product.id} - Couleur ${color.name}`);

          } catch (error) {
            generationErrors++;
            console.error(`‚ùå Erreur g√©n√©ration fallback ${product.id}-${color.id}:`, error.message);
          }
        }

      } catch (error) {
        console.error(`‚ùå Erreur g√©n√©ration produit ${product.id}:`, error.message);
      }
    }

    console.log(`üìä Mockups g√©n√©r√©s: ${mockupsGenerated}, Erreurs: ${generationErrors}\n`);

    // 5. Statistiques finales
    console.log('üìä === STATISTIQUES FINALES ===');
    
    const [
      finalTotalProducts,
      finalProductsWithDesign,
      finalMockups,
      completedMockups,
      failedMockups
    ] = await Promise.all([
      prisma.vendorProduct.count(),
      prisma.vendorProduct.count({ where: { designId: { not: null } } }),
      prisma.vendorProductMockup.count(),
      prisma.vendorProductMockup.count({ where: { generationStatus: 'COMPLETED' } }),
      prisma.vendorProductMockup.count({ where: { generationStatus: 'FAILED' } })
    ]);

    console.log(`üì¶ Total produits vendeur: ${finalTotalProducts}`);
    console.log(`üé® Produits avec design: ${finalProductsWithDesign} (${Math.round((finalProductsWithDesign/finalTotalProducts)*100)}%)`);
    console.log(`üñºÔ∏è Total mockups: ${finalMockups}`);
    console.log(`‚úÖ Mockups compl√©t√©s: ${completedMockups}`);
    console.log(`‚ùå Mockups √©chou√©s: ${failedMockups}`);

    const migrationSuccess = finalProductsWithDesign === finalTotalProducts && completedMockups > 0;

    console.log('\nüéâ === R√âSUM√â MIGRATION ===');
    console.log(`Migration r√©ussie: ${migrationSuccess ? '‚úÖ OUI' : '‚ùå NON'}`);
    console.log(`Designs cr√©√©s automatiquement: ${designsCreated}`);
    console.log(`Mockups migr√©s depuis images: ${mockupsCreated}`);
    console.log(`Mockups fallback g√©n√©r√©s: ${mockupsGenerated}`);
    console.log(`Erreurs totales: ${designLinkingErrors + mockupErrors + generationErrors}`);

    if (migrationSuccess) {
      console.log('\n‚úÖ MIGRATION TERMIN√âE AVEC SUCC√àS !');
      console.log('üé® Architecture v2_mockups_by_color op√©rationnelle');
      console.log('üîß Vous pouvez maintenant utiliser les nouveaux endpoints');
      console.log('üì± Le frontend peut utiliser la nouvelle structure de donn√©es');
    } else {
      console.log('\n‚ö†Ô∏è MIGRATION PARTIELLEMENT R√âUSSIE');
      console.log('üõ†Ô∏è V√©rifiez les erreurs ci-dessus et relancez si n√©cessaire');
      console.log('üìù Certains produits peuvent n√©cessiter une intervention manuelle');
    }

  } catch (error) {
    console.error('‚ùå Erreur lors de la migration:', error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

// Ex√©cution
if (require.main === module) {
  migrateToMockupsByColor()
    .then(() => {
      console.log('\nüöÄ Migration termin√©e');
      process.exit(0);
    })
    .catch((error) => {
      console.error('\nüí• Migration √©chou√©e:', error);
      process.exit(1);
    });
}

module.exports = { migrateToMockupsByColor }; 
 
 
 
 
 
 
 
 
 
 