const fs = require('fs');
const FormData = require('form-data');

// Configuration
const BASE_URL = 'http://localhost:3004';
const PRODUCT_ID = 4;

// Simulation du service de gestion des couleurs
class ColorManagementService {
  constructor() {
    this.cache = new Map();
    this.timestampMapping = new Map();
  }

  async getProductWithCache(productId) {
    if (this.cache.has(productId)) {
      console.log('üìã Produit r√©cup√©r√© depuis le cache');
      return this.cache.get(productId);
    }

    console.log('üìã R√©cup√©ration du produit depuis l\'API...');
    const response = await fetch(`${BASE_URL}/products/${productId}`);
    if (!response.ok) {
      throw new Error(`Produit ${productId} non trouv√©`);
    }

    const product = await response.json();
    this.cache.set(productId, product);
    console.log('‚úÖ Produit mis en cache');
    return product;
  }

  detectColorId(colorVariation, product) {
    console.log('üîç D√©tection couleur pour:', colorVariation);

    // 1. Si c'est un objet avec un ID valide
    if (typeof colorVariation === 'object' && colorVariation.id) {
      const existingColor = product.colorVariations.find(cv => cv.id === colorVariation.id);
      if (existingColor) {
        console.log('‚úÖ ID direct trouv√©:', existingColor.id);
        return existingColor.id;
      }
    }

    // 2. Si c'est un objet avec nom/code couleur
    if (typeof colorVariation === 'object' && colorVariation.name) {
      const existingColor = product.colorVariations.find(cv => 
        cv.name.toLowerCase() === colorVariation.name.toLowerCase() ||
        cv.colorCode === colorVariation.colorCode
      );
      if (existingColor) {
        console.log('‚úÖ Couleur trouv√©e par nom/code:', existingColor.id);
        return existingColor.id;
      }
    }

    // 3. Si c'est un timestamp, utiliser le mapping intelligent
    if (typeof colorVariation === 'number' && colorVariation > 1000000000000) {
      return this.mapTimestampToColorId(colorVariation, product.colorVariations);
    }

    // 4. Si c'est un ID num√©rique direct
    if (typeof colorVariation === 'number' && colorVariation < 1000000) {
      const existingColor = product.colorVariations.find(cv => cv.id === colorVariation);
      if (existingColor) {
        console.log('‚úÖ ID num√©rique trouv√©:', existingColor.id);
        return existingColor.id;
      }
    }

    // 5. Fallback : premi√®re couleur disponible
    const fallbackColor = product.colorVariations[0];
    if (fallbackColor) {
      console.log('‚ö†Ô∏è Utilisation couleur par d√©faut:', fallbackColor.id);
      return fallbackColor.id;
    }

    throw new Error('Aucune couleur disponible pour ce produit');
  }

  mapTimestampToColorId(timestamp, colorVariations) {
    if (!colorVariations || colorVariations.length === 0) {
      throw new Error('Aucune couleur disponible');
    }

    // V√©rifier si on a d√©j√† mapp√© ce timestamp
    if (this.timestampMapping.has(timestamp)) {
      const mappedId = this.timestampMapping.get(timestamp);
      console.log('üîÑ Timestamp d√©j√† mapp√©:', timestamp, '‚Üí', mappedId);
      return mappedId;
    }

    // Cr√©er un mapping d√©terministe bas√© sur le timestamp
    const index = Math.abs(timestamp % colorVariations.length);
    const selectedColor = colorVariations[index];
    
    // Sauvegarder le mapping
    this.timestampMapping.set(timestamp, selectedColor.id);
    
    console.log(`üîÑ Nouveau mapping: timestamp ${timestamp} ‚Üí index ${index} ‚Üí couleur ${selectedColor.name} (ID: ${selectedColor.id})`);
    
    return selectedColor.id;
  }

  async uploadColorImage(productId, colorVariation, imageFile) {
    console.log('üöÄ Upload intelligent pour:', colorVariation);

    try {
      // 1. R√©cup√©rer les donn√©es du produit
      const product = await this.getProductWithCache(productId);
      
      // 2. D√©tecter l'ID de couleur
      const colorId = this.detectColorId(colorVariation, product);
      
      console.log('üéØ ID de couleur d√©tect√©:', colorId);
      
      // 3. Upload avec l'ID correct
      const formData = new FormData();
      formData.append('image', imageFile);
      
      const response = await fetch(`${BASE_URL}/products/upload-color-image/${productId}/${colorId}`, {
        method: 'POST',
        body: formData
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message);
      }
      
      const result = await response.json();
      console.log('‚úÖ Upload r√©ussi:', result);
      
      return result;
    } catch (error) {
      console.error('‚ùå Erreur upload intelligent:', error);
      throw error;
    }
  }

  clearCache(productId = null) {
    if (productId) {
      this.cache.delete(productId);
      console.log('üóëÔ∏è Cache nettoy√© pour le produit:', productId);
    } else {
      this.cache.clear();
      console.log('üóëÔ∏è Cache compl√®tement nettoy√©');
    }
    this.timestampMapping.clear();
  }
}

// Instance du service
const colorManagementService = new ColorManagementService();

// Test 1 : Test de d√©tection d'ID
async function testColorDetection() {
  console.log('\nüß™ Test 1: D√©tection d\'ID de couleur...');
  
  try {
    const product = await colorManagementService.getProductWithCache(PRODUCT_ID);
    
    const testCases = [
      { name: 'ID direct', input: { id: 16 }, expected: 16 },
      { name: 'Nom de couleur', input: { name: 'Blanc' }, expected: 16 },
      { name: 'Code couleur', input: { colorCode: '#244a89' }, expected: 17 },
      { name: 'ID num√©rique', input: 23, expected: 23 },
      { name: 'Timestamp', input: Date.now(), expected: 'any' },
      { name: 'Objet inconnu', input: { name: 'CouleurInconnue' }, expected: 'fallback' }
    ];

    for (const testCase of testCases) {
      console.log(`\nüìù Test: ${testCase.name}`);
      console.log('Input:', testCase.input);
      
      try {
        const result = colorManagementService.detectColorId(testCase.input, product);
        console.log('‚úÖ R√©sultat:', result);
        
        if (testCase.expected === 'any') {
          console.log('‚úÖ Timestamp mapp√© vers une couleur valide');
        } else if (testCase.expected === 'fallback') {
          console.log('‚úÖ Fallback utilis√©');
        } else if (result === testCase.expected) {
          console.log('‚úÖ Test r√©ussi');
        } else {
          console.log('‚ùå Test √©chou√© - attendu:', testCase.expected, 're√ßu:', result);
        }
      } catch (error) {
        console.log('‚ùå Erreur:', error.message);
      }
    }
    
  } catch (error) {
    console.error('‚ùå Erreur test d√©tection:', error.message);
  }
}

// Test 2 : Test d'upload avec diff√©rents types
async function testUploadWithDifferentTypes() {
  console.log('\nüß™ Test 2: Upload avec diff√©rents types de couleur...');
  
  try {
    const testCases = [
      { name: 'Objet avec ID', input: { id: 16 } },
      { name: 'Objet avec nom', input: { name: 'Blue' } },
      { name: 'Timestamp', input: Date.now() },
      { name: 'ID num√©rique', input: 23 }
    ];

    for (const testCase of testCases) {
      console.log(`\nüìù Test upload: ${testCase.name}`);
      console.log('Input:', testCase.input);
      
      // Cr√©er un fichier de test
      const testImagePath = `./test-${Date.now()}.jpg`;
      fs.writeFileSync(testImagePath, `fake image data for ${testCase.name}`);
      
      try {
        const result = await colorManagementService.uploadColorImage(
          PRODUCT_ID, 
          testCase.input, 
          fs.createReadStream(testImagePath)
        );
        console.log('‚úÖ Upload r√©ussi:', result);
      } catch (error) {
        console.log('‚ùå Erreur upload:', error.message);
      }
      
      // Nettoyer
      if (fs.existsSync(testImagePath)) {
        fs.unlinkSync(testImagePath);
      }
    }
    
  } catch (error) {
    console.error('‚ùå Erreur test upload:', error.message);
  }
}

// Test 3 : Test de cache
async function testCache() {
  console.log('\nüß™ Test 3: Test du cache...');
  
  try {
    console.log('üìã Premi√®re r√©cup√©ration (depuis API)...');
    const product1 = await colorManagementService.getProductWithCache(PRODUCT_ID);
    
    console.log('üìã Deuxi√®me r√©cup√©ration (depuis cache)...');
    const product2 = await colorManagementService.getProductWithCache(PRODUCT_ID);
    
    if (product1.id === product2.id) {
      console.log('‚úÖ Cache fonctionne correctement');
    } else {
      console.log('‚ùå Probl√®me avec le cache');
    }
    
    console.log('üóëÔ∏è Nettoyage du cache...');
    colorManagementService.clearCache(PRODUCT_ID);
    
    console.log('üìã Troisi√®me r√©cup√©ration (depuis API apr√®s nettoyage)...');
    const product3 = await colorManagementService.getProductWithCache(PRODUCT_ID);
    
    console.log('‚úÖ Cache nettoy√© et recharg√©');
    
  } catch (error) {
    console.error('‚ùå Erreur test cache:', error.message);
  }
}

// Test 4 : Test de mapping de timestamps
async function testTimestampMapping() {
  console.log('\nüß™ Test 4: Test de mapping de timestamps...');
  
  try {
    const product = await colorManagementService.getProductWithCache(PRODUCT_ID);
    const colorVariations = product.colorVariations;
    
    const timestamps = [
      Date.now(),
      Date.now() + 1000,
      Date.now() + 2000,
      Date.now() + 3000,
      Date.now() + 4000
    ];
    
    console.log('üé® Couleurs disponibles:', colorVariations.map(cv => `${cv.name} (ID: ${cv.id})`));
    
    for (const timestamp of timestamps) {
      console.log(`\nüìù Test timestamp: ${timestamp}`);
      
      const colorId = colorManagementService.mapTimestampToColorId(timestamp, colorVariations);
      const selectedColor = colorVariations.find(cv => cv.id === colorId);
      
      console.log(`üéØ Mapping: ${timestamp} ‚Üí ${selectedColor.name} (ID: ${colorId})`);
    }
    
    // Test de coh√©rence du mapping
    console.log('\nüîÑ Test de coh√©rence du mapping...');
    const sameTimestamp = Date.now();
    const result1 = colorManagementService.mapTimestampToColorId(sameTimestamp, colorVariations);
    const result2 = colorManagementService.mapTimestampToColorId(sameTimestamp, colorVariations);
    
    if (result1 === result2) {
      console.log('‚úÖ Mapping coh√©rent pour le m√™me timestamp');
    } else {
      console.log('‚ùå Mapping incoh√©rent');
    }
    
  } catch (error) {
    console.error('‚ùå Erreur test mapping:', error.message);
  }
}

// Test 5 : Test de performance
async function testPerformance() {
  console.log('\nüß™ Test 5: Test de performance...');
  
  try {
    const startTime = Date.now();
    
    // R√©cup√©rer le produit plusieurs fois
    for (let i = 0; i < 5; i++) {
      await colorManagementService.getProductWithCache(PRODUCT_ID);
    }
    
    const endTime = Date.now();
    const duration = endTime - startTime;
    
    console.log(`‚è±Ô∏è Temps total: ${duration}ms`);
    console.log(`üìä Temps moyen par requ√™te: ${duration / 5}ms`);
    
    // Nettoyer le cache pour un test √©quitable
    colorManagementService.clearCache();
    
    const startTimeNoCache = Date.now();
    
    // R√©cup√©rer sans cache
    for (let i = 0; i < 5; i++) {
      const response = await fetch(`${BASE_URL}/products/${PRODUCT_ID}`);
      await response.json();
    }
    
    const endTimeNoCache = Date.now();
    const durationNoCache = endTimeNoCache - startTimeNoCache;
    
    console.log(`‚è±Ô∏è Temps sans cache: ${durationNoCache}ms`);
    console.log(`üìä Am√©lioration: ${Math.round((durationNoCache - duration) / durationNoCache * 100)}%`);
    
  } catch (error) {
    console.error('‚ùå Erreur test performance:', error.message);
  }
}

// Fonction principale
async function runAllTests() {
  console.log('üöÄ D√©marrage des tests de gestion intelligente des couleurs...\n');
  
  await testColorDetection();
  await testUploadWithDifferentTypes();
  await testCache();
  await testTimestampMapping();
  await testPerformance();
  
  console.log('\n‚ú® Tous les tests termin√©s!');
  console.log('\nüìã R√©sum√©:');
  console.log('‚úÖ D√©tection automatique d\'ID de couleur');
  console.log('‚úÖ Upload intelligent avec mapping');
  console.log('‚úÖ Cache optimis√©');
  console.log('‚úÖ Mapping coh√©rent des timestamps');
  console.log('‚úÖ Performance am√©lior√©e');
}

// Ex√©cuter les tests si le script est appel√© directement
if (require.main === module) {
  runAllTests().catch(console.error);
}

module.exports = {
  ColorManagementService,
  testColorDetection,
  testUploadWithDifferentTypes,
  testCache,
  testTimestampMapping,
  testPerformance
}; 