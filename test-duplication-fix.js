const axios = require('axios');

const BASE_URL = 'http://localhost:3004';

async function testDuplicationFix() {
  console.log('üîç Test de la correction du probl√®me de duplication...\n');

  try {
    // 1. Tester l'endpoint /vendor/products
    console.log('1Ô∏è‚É£ Test de l\'endpoint /vendor/products...');
    
    const response = await axios.get(`${BASE_URL}/vendor/products`);
    
    if (response.data.success) {
      const products = response.data.data.products;
      console.log(`   Produits retourn√©s: ${products.length}`);
      
      // V√©rifier les doublons
      const productIds = products.map(p => p.id);
      const uniqueIds = [...new Set(productIds)];
      
      if (productIds.length !== uniqueIds.length) {
        console.log(`   ‚ùå DOUBLONS D√âTECT√âS: ${productIds.length - uniqueIds.length} doublons`);
        
        // Identifier les doublons
        const duplicates = productIds.filter((id, index) => productIds.indexOf(id) !== index);
        const uniqueDuplicates = [...new Set(duplicates)];
        
        uniqueDuplicates.forEach(dupId => {
          const dupProducts = products.filter(p => p.id === dupId);
          console.log(`     - ID: ${dupId}, Count: ${dupProducts.length}`);
          dupProducts.forEach((p, index) => {
            console.log(`       * Instance ${index + 1}: ${p.vendorName} (${p.status})`);
          });
        });
      } else {
        console.log(`   ‚úÖ Aucun doublon d√©tect√© dans la r√©ponse`);
      }
      
      // Afficher les premiers produits pour v√©rification
      console.log('\nüìã Premiers produits (max 5):');
      products.slice(0, 5).forEach((product, index) => {
        console.log(`   ${index + 1}. ID: ${product.id}, Nom: ${product.vendorName}, Prix: ${product.price} FCFA`);
      });
      
    } else {
      console.log('   ‚ùå Erreur dans la r√©ponse API');
    }

    // 2. Tester l'endpoint public
    console.log('\n2Ô∏è‚É£ Test de l\'endpoint /public/vendor-products...');
    
    const publicResponse = await axios.get(`${BASE_URL}/public/vendor-products?limit=10`);
    
    if (publicResponse.data.success) {
      const publicProducts = publicResponse.data.data.products;
      console.log(`   Produits publics retourn√©s: ${publicProducts.length}`);
      
      // V√©rifier les doublons
      const publicProductIds = publicProducts.map(p => p.id);
      const uniquePublicIds = [...new Set(publicProductIds)];
      
      if (publicProductIds.length !== uniquePublicIds.length) {
        console.log(`   ‚ùå DOUBLONS D√âTECT√âS: ${publicProductIds.length - uniquePublicIds.length} doublons`);
      } else {
        console.log(`   ‚úÖ Aucun doublon d√©tect√© dans la r√©ponse publique`);
      }
    }

    // 3. Tester avec un vendeur sp√©cifique
    console.log('\n3Ô∏è‚É£ Test avec un vendeur sp√©cifique...');
    
    // Essayer de trouver un vendeur avec des produits
    const vendorsResponse = await axios.get(`${BASE_URL}/vendor/products`);
    
    if (vendorsResponse.data.success && vendorsResponse.data.data.products.length > 0) {
      const firstProduct = vendorsResponse.data.data.products[0];
      const vendorId = firstProduct.vendorId || 1; // Utiliser le premier vendeur trouv√©
      
      console.log(`   Test avec le vendeur ID: ${vendorId}`);
      
      const vendorProductsResponse = await axios.get(`${BASE_URL}/vendor/products?vendorId=${vendorId}`);
      
      if (vendorProductsResponse.data.success) {
        const vendorProducts = vendorProductsResponse.data.data.products;
        console.log(`   Produits du vendeur: ${vendorProducts.length}`);
        
        // V√©rifier les doublons pour ce vendeur
        const vendorProductIds = vendorProducts.map(p => p.id);
        const uniqueVendorIds = [...new Set(vendorProductIds)];
        
        if (vendorProductIds.length !== uniqueVendorIds.length) {
          console.log(`   ‚ùå DOUBLONS pour ce vendeur: ${vendorProductIds.length - uniqueVendorIds.length} doublons`);
        } else {
          console.log(`   ‚úÖ Aucun doublon pour ce vendeur`);
        }
      }
    }

    // 4. V√©rifier la structure des donn√©es
    console.log('\n4Ô∏è‚É£ V√©rification de la structure des donn√©es...');
    
    if (response.data.success && response.data.data.products.length > 0) {
      const sampleProduct = response.data.data.products[0];
      console.log('   Structure d\'un produit:');
      console.log(`     - ID: ${sampleProduct.id}`);
      console.log(`     - Nom: ${sampleProduct.vendorName}`);
      console.log(`     - Prix: ${sampleProduct.price}`);
      console.log(`     - Status: ${sampleProduct.status}`);
      
      // V√©rifier les propri√©t√©s importantes
      const importantProps = ['id', 'vendorName', 'price', 'status', 'designId', 'baseProductId'];
      const missingProps = importantProps.filter(prop => !(prop in sampleProduct));
      
      if (missingProps.length > 0) {
        console.log(`   ‚ö†Ô∏è Propri√©t√©s manquantes: ${missingProps.join(', ')}`);
      } else {
        console.log(`   ‚úÖ Toutes les propri√©t√©s importantes sont pr√©sentes`);
      }
    }

    // 5. Recommandations
    console.log('\n5Ô∏è‚É£ Recommandations:');
    
    if (response.data.success) {
      const products = response.data.data.products;
      const productIds = products.map(p => p.id);
      const uniqueIds = [...new Set(productIds)];
      
      if (productIds.length !== uniqueIds.length) {
        console.log('   üîß Actions n√©cessaires:');
        console.log('   1. Ex√©cuter: node clean-duplicates.js');
        console.log('   2. Appliquer la migration: npx prisma migrate dev --name add-uniqueness-constraints');
        console.log('   3. Red√©marrer le serveur');
        console.log('   4. Tester √† nouveau');
      } else {
        console.log('   ‚úÖ Aucune action n√©cessaire - pas de doublons d√©tect√©s');
      }
    }

  } catch (error) {
    console.error('‚ùå Erreur lors du test:', error.message);
    
    if (error.code === 'ECONNREFUSED') {
      console.log('\nüí° Le serveur n\'est pas d√©marr√©. Pour tester:');
      console.log('   1. D√©marrer le serveur: npm run start:dev');
      console.log('   2. Relancer ce test: node test-duplication-fix.js');
    }
  }
}

async function testSwaggerEndpoint() {
  console.log('\nüîç Test de l\'endpoint Swagger...');
  
  try {
    const swaggerResponse = await axios.get(`${BASE_URL}/api-docs`);
    console.log('‚úÖ Swagger UI accessible');
    console.log(`üìö URL Swagger: ${BASE_URL}/api-docs`);
  } catch (error) {
    console.error('‚ùå Erreur acc√®s Swagger:', error.message);
  }
}

// Ex√©cuter les tests
async function runTests() {
  console.log('üöÄ D√©marrage des tests de correction duplication...\n');
  
  await testSwaggerEndpoint();
  await testDuplicationFix();
  
  console.log('\n‚úÖ Tests termin√©s !');
}

runTests().catch(console.error); 

const BASE_URL = 'http://localhost:3004';

async function testDuplicationFix() {
  console.log('üîç Test de la correction du probl√®me de duplication...\n');

  try {
    // 1. Tester l'endpoint /vendor/products
    console.log('1Ô∏è‚É£ Test de l\'endpoint /vendor/products...');
    
    const response = await axios.get(`${BASE_URL}/vendor/products`);
    
    if (response.data.success) {
      const products = response.data.data.products;
      console.log(`   Produits retourn√©s: ${products.length}`);
      
      // V√©rifier les doublons
      const productIds = products.map(p => p.id);
      const uniqueIds = [...new Set(productIds)];
      
      if (productIds.length !== uniqueIds.length) {
        console.log(`   ‚ùå DOUBLONS D√âTECT√âS: ${productIds.length - uniqueIds.length} doublons`);
        
        // Identifier les doublons
        const duplicates = productIds.filter((id, index) => productIds.indexOf(id) !== index);
        const uniqueDuplicates = [...new Set(duplicates)];
        
        uniqueDuplicates.forEach(dupId => {
          const dupProducts = products.filter(p => p.id === dupId);
          console.log(`     - ID: ${dupId}, Count: ${dupProducts.length}`);
          dupProducts.forEach((p, index) => {
            console.log(`       * Instance ${index + 1}: ${p.vendorName} (${p.status})`);
          });
        });
      } else {
        console.log(`   ‚úÖ Aucun doublon d√©tect√© dans la r√©ponse`);
      }
      
      // Afficher les premiers produits pour v√©rification
      console.log('\nüìã Premiers produits (max 5):');
      products.slice(0, 5).forEach((product, index) => {
        console.log(`   ${index + 1}. ID: ${product.id}, Nom: ${product.vendorName}, Prix: ${product.price} FCFA`);
      });
      
    } else {
      console.log('   ‚ùå Erreur dans la r√©ponse API');
    }

    // 2. Tester l'endpoint public
    console.log('\n2Ô∏è‚É£ Test de l\'endpoint /public/vendor-products...');
    
    const publicResponse = await axios.get(`${BASE_URL}/public/vendor-products?limit=10`);
    
    if (publicResponse.data.success) {
      const publicProducts = publicResponse.data.data.products;
      console.log(`   Produits publics retourn√©s: ${publicProducts.length}`);
      
      // V√©rifier les doublons
      const publicProductIds = publicProducts.map(p => p.id);
      const uniquePublicIds = [...new Set(publicProductIds)];
      
      if (publicProductIds.length !== uniquePublicIds.length) {
        console.log(`   ‚ùå DOUBLONS D√âTECT√âS: ${publicProductIds.length - uniquePublicIds.length} doublons`);
      } else {
        console.log(`   ‚úÖ Aucun doublon d√©tect√© dans la r√©ponse publique`);
      }
    }

    // 3. Tester avec un vendeur sp√©cifique
    console.log('\n3Ô∏è‚É£ Test avec un vendeur sp√©cifique...');
    
    // Essayer de trouver un vendeur avec des produits
    const vendorsResponse = await axios.get(`${BASE_URL}/vendor/products`);
    
    if (vendorsResponse.data.success && vendorsResponse.data.data.products.length > 0) {
      const firstProduct = vendorsResponse.data.data.products[0];
      const vendorId = firstProduct.vendorId || 1; // Utiliser le premier vendeur trouv√©
      
      console.log(`   Test avec le vendeur ID: ${vendorId}`);
      
      const vendorProductsResponse = await axios.get(`${BASE_URL}/vendor/products?vendorId=${vendorId}`);
      
      if (vendorProductsResponse.data.success) {
        const vendorProducts = vendorProductsResponse.data.data.products;
        console.log(`   Produits du vendeur: ${vendorProducts.length}`);
        
        // V√©rifier les doublons pour ce vendeur
        const vendorProductIds = vendorProducts.map(p => p.id);
        const uniqueVendorIds = [...new Set(vendorProductIds)];
        
        if (vendorProductIds.length !== uniqueVendorIds.length) {
          console.log(`   ‚ùå DOUBLONS pour ce vendeur: ${vendorProductIds.length - uniqueVendorIds.length} doublons`);
        } else {
          console.log(`   ‚úÖ Aucun doublon pour ce vendeur`);
        }
      }
    }

    // 4. V√©rifier la structure des donn√©es
    console.log('\n4Ô∏è‚É£ V√©rification de la structure des donn√©es...');
    
    if (response.data.success && response.data.data.products.length > 0) {
      const sampleProduct = response.data.data.products[0];
      console.log('   Structure d\'un produit:');
      console.log(`     - ID: ${sampleProduct.id}`);
      console.log(`     - Nom: ${sampleProduct.vendorName}`);
      console.log(`     - Prix: ${sampleProduct.price}`);
      console.log(`     - Status: ${sampleProduct.status}`);
      
      // V√©rifier les propri√©t√©s importantes
      const importantProps = ['id', 'vendorName', 'price', 'status', 'designId', 'baseProductId'];
      const missingProps = importantProps.filter(prop => !(prop in sampleProduct));
      
      if (missingProps.length > 0) {
        console.log(`   ‚ö†Ô∏è Propri√©t√©s manquantes: ${missingProps.join(', ')}`);
      } else {
        console.log(`   ‚úÖ Toutes les propri√©t√©s importantes sont pr√©sentes`);
      }
    }

    // 5. Recommandations
    console.log('\n5Ô∏è‚É£ Recommandations:');
    
    if (response.data.success) {
      const products = response.data.data.products;
      const productIds = products.map(p => p.id);
      const uniqueIds = [...new Set(productIds)];
      
      if (productIds.length !== uniqueIds.length) {
        console.log('   üîß Actions n√©cessaires:');
        console.log('   1. Ex√©cuter: node clean-duplicates.js');
        console.log('   2. Appliquer la migration: npx prisma migrate dev --name add-uniqueness-constraints');
        console.log('   3. Red√©marrer le serveur');
        console.log('   4. Tester √† nouveau');
      } else {
        console.log('   ‚úÖ Aucune action n√©cessaire - pas de doublons d√©tect√©s');
      }
    }

  } catch (error) {
    console.error('‚ùå Erreur lors du test:', error.message);
    
    if (error.code === 'ECONNREFUSED') {
      console.log('\nüí° Le serveur n\'est pas d√©marr√©. Pour tester:');
      console.log('   1. D√©marrer le serveur: npm run start:dev');
      console.log('   2. Relancer ce test: node test-duplication-fix.js');
    }
  }
}

async function testSwaggerEndpoint() {
  console.log('\nüîç Test de l\'endpoint Swagger...');
  
  try {
    const swaggerResponse = await axios.get(`${BASE_URL}/api-docs`);
    console.log('‚úÖ Swagger UI accessible');
    console.log(`üìö URL Swagger: ${BASE_URL}/api-docs`);
  } catch (error) {
    console.error('‚ùå Erreur acc√®s Swagger:', error.message);
  }
}

// Ex√©cuter les tests
async function runTests() {
  console.log('üöÄ D√©marrage des tests de correction duplication...\n');
  
  await testSwaggerEndpoint();
  await testDuplicationFix();
  
  console.log('\n‚úÖ Tests termin√©s !');
}

runTests().catch(console.error); 