const { PrismaClient } = require('@prisma/client');
const { VendorPublishService } = require('./src/vendor-product/vendor-publish.service');
const { CloudinaryService } = require('./src/core/cloudinary/cloudinary.service');

const prisma = new PrismaClient();

// Mock CloudinaryService
const mockCloudinaryService = {
  uploadBase64: jest.fn().mockResolvedValue({
    secure_url: 'https://res.cloudinary.com/test/image/upload/v1234567890/test-design.jpg',
    public_id: 'test-design',
    bytes: 1000,
    width: 500,
    height: 500,
    format: 'jpg'
  })
};

async function testVendorPublishDeduplication() {
  console.log('üß™ Test de d√©duplication avec VendorPublishService...\n');

  const vendorPublishService = new VendorPublishService(prisma, mockCloudinaryService);

  try {
    // 1. Cr√©er un vendeur de test
    const vendor = await prisma.user.create({
      data: {
        firstName: 'Test',
        lastName: 'Vendor',
        email: 'test-vendor-publish@example.com',
        password: 'hashedpassword',
        role: 'VENDEUR'
      }
    });

    console.log(`‚úÖ Vendeur cr√©√©: ${vendor.id}`);

    // 2. Cr√©er un produit de base
    const baseProduct = await prisma.product.create({
      data: {
        name: 'T-shirt Test',
        description: 'Produit de base pour test',
        price: 15000,
        stock: 100,
        status: 'PUBLISHED'
      }
    });

    console.log(`‚úÖ Produit de base cr√©√©: ${baseProduct.id}`);

    // 3. Cr√©er une variation de couleur
    const colorVariation = await prisma.colorVariation.create({
      data: {
        name: 'Rouge',
        colorCode: '#ff0000',
        productId: baseProduct.id
      }
    });

    // 4. Cr√©er une image pour la variation
    const productImage = await prisma.productImage.create({
      data: {
        view: 'Front',
        url: 'https://example.com/image1.jpg',
        publicId: 'image1',
        colorVariationId: colorVariation.id
      }
    });

    // 5. Cr√©er une d√©limitation
    await prisma.delimitation.create({
      data: {
        x: 10,
        y: 10,
        width: 80,
        height: 80,
        productImageId: productImage.id
      }
    });

    // 6. Design de test (m√™me contenu)
    const testDesignBase64 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==';

    // 7. DTO pour le premier produit
    const publishDto1 = {
      baseProductId: baseProduct.id,
      vendorName: 'T-shirt Design Test 1',
      vendorDescription: 'Premier produit avec design',
      vendorPrice: 25000,
      vendorStock: 100,
      selectedColors: [{ id: colorVariation.id, name: 'Rouge', code: '#ff0000' }],
      selectedSizes: [{ id: 1, name: 'M' }],
      finalImagesBase64: { design: testDesignBase64 },
      productStructure: {
        adminProduct: {
          id: baseProduct.id,
          name: baseProduct.name,
          description: baseProduct.description,
          price: baseProduct.price,
          images: {
            colorVariations: [
              {
                id: colorVariation.id,
                name: 'Rouge',
                colorCode: '#ff0000',
                images: [
                  {
                    id: productImage.id,
                    url: 'https://example.com/image1.jpg',
                    view: 'Front'
                  }
                ]
              }
            ]
          }
        },
        designApplication: { scale: 0.6 }
      },
      postValidationAction: 'AUTO_PUBLISH'
    };

    // 8. Test 1: Cr√©er le premier produit
    console.log('\nüì¶ Test 1: Cr√©ation du premier produit...');
    
    const result1 = await vendorPublishService.publishProduct(publishDto1, vendor.id);
    console.log(`‚úÖ Produit 1 cr√©√©: ${result1.productId} avec design: ${result1.designId}`);

    // 9. Test 2: Cr√©er le deuxi√®me produit avec le M√äME design
    console.log('\nüì¶ Test 2: Cr√©ation du deuxi√®me produit avec le m√™me design...');
    
    const publishDto2 = {
      ...publishDto1,
      vendorName: 'T-shirt Design Test 2',
      vendorDescription: 'Deuxi√®me produit avec M√äME design',
      postValidationAction: 'TO_DRAFT'
    };

    const result2 = await vendorPublishService.publishProduct(publishDto2, vendor.id);
    console.log(`‚úÖ Produit 2 cr√©√©: ${result2.productId} avec design: ${result2.designId}`);

    // 10. V√©rifier que les deux produits utilisent le m√™me design
    console.log('\nüîç V√©rification de la d√©duplication...');
    
    if (result1.designId === result2.designId) {
      console.log(`‚úÖ SUCC√àS: Les deux produits utilisent le m√™me design (ID: ${result1.designId})`);
    } else {
      console.log(`‚ùå √âCHEC: Les produits utilisent des designs diff√©rents (${result1.designId} vs ${result2.designId})`);
    }

    // 11. V√©rifier le nombre d'appels √† Cloudinary
    console.log(`üìä Nombre d'appels √† Cloudinary: ${mockCloudinaryService.uploadBase64.mock.calls.length}`);
    
    if (mockCloudinaryService.uploadBase64.mock.calls.length === 1) {
      console.log('‚úÖ SUCC√àS: Un seul upload vers Cloudinary');
    } else {
      console.log('‚ùå √âCHEC: Plusieurs uploads vers Cloudinary');
    }

    // 12. V√©rifier les designs en base
    const designs = await prisma.design.findMany({
      where: { vendorId: vendor.id }
    });

    console.log(`üìä Nombre de designs en base: ${designs.length}`);
    
    if (designs.length === 1) {
      console.log('‚úÖ SUCC√àS: Un seul design en base');
    } else {
      console.log('‚ùå √âCHEC: Plusieurs designs en base');
    }

    // 13. Test de cascade validation
    console.log('\nüîÑ Test de cascade validation...');
    
    // Valider le design
    const design = designs[0];
    await prisma.design.update({
      where: { id: design.id },
      data: {
        isValidated: true,
        validatedAt: new Date(),
        isPending: false
      }
    });

    // Simuler la cascade
    await simulateCascadeValidation(design.id);

    // 14. V√©rifier les r√©sultats
    const updatedProduct1 = await prisma.vendorProduct.findUnique({
      where: { id: result1.productId }
    });

    const updatedProduct2 = await prisma.vendorProduct.findUnique({
      where: { id: result2.productId }
    });

    console.log(`Produit 1 - isValidated: ${updatedProduct1.isValidated}, status: ${updatedProduct1.status}`);
    console.log(`Produit 2 - isValidated: ${updatedProduct2.isValidated}, status: ${updatedProduct2.status}`);

    if (updatedProduct1.isValidated && updatedProduct1.status === 'PUBLISHED') {
      console.log('‚úÖ Produit 1: Valid√© et publi√© (AUTO_PUBLISH)');
    } else {
      console.log('‚ùå Produit 1: Probl√®me cascade validation');
    }

    if (updatedProduct2.isValidated && updatedProduct2.status === 'DRAFT') {
      console.log('‚úÖ Produit 2: Valid√© et en brouillon (TO_DRAFT)');
    } else {
      console.log('‚ùå Produit 2: Probl√®me cascade validation');
    }

    console.log('\nüéâ Test termin√© avec succ√®s !');

  } catch (error) {
    console.error('‚ùå Erreur durant le test:', error);
  } finally {
    await cleanup();
    await prisma.$disconnect();
  }
}

async function simulateCascadeValidation(designId) {
  console.log(`üîÑ Simulation cascade validation pour design ${designId}...`);

  // R√©cup√©rer tous les produits li√©s √† ce design
  const linkedProducts = await prisma.vendorProduct.findMany({
    where: { designId: designId }
  });

  console.log(`üì¶ ${linkedProducts.length} produits li√©s trouv√©s`);

  // Mettre √† jour chaque produit selon son action post-validation
  for (const product of linkedProducts) {
    const newStatus = product.postValidationAction === 'AUTO_PUBLISH' ? 'PUBLISHED' : 'DRAFT';
    
    await prisma.vendorProduct.update({
      where: { id: product.id },
      data: {
        isValidated: true,
        validatedAt: new Date(),
        status: newStatus
      }
    });

    console.log(`‚úÖ Produit ${product.id}: ${product.postValidationAction} ‚Üí ${newStatus}`);
  }
}

async function cleanup() {
  console.log('üßπ Nettoyage des donn√©es de test...');

  try {
    // Supprimer dans l'ordre pour √©viter les contraintes
    await prisma.designProductLink.deleteMany({
      where: {
        vendorProduct: {
          vendor: {
            email: 'test-vendor-publish@example.com'
          }
        }
      }
    });

    await prisma.vendorProductImage.deleteMany({
      where: {
        vendorProduct: {
          vendor: {
            email: 'test-vendor-publish@example.com'
          }
        }
      }
    });

    await prisma.vendorProduct.deleteMany({
      where: {
        vendor: {
          email: 'test-vendor-publish@example.com'
        }
      }
    });

    await prisma.design.deleteMany({
      where: {
        vendor: {
          email: 'test-vendor-publish@example.com'
        }
      }
    });

    await prisma.delimitation.deleteMany({
      where: {
        productImage: {
          colorVariation: {
            product: {
              name: 'T-shirt Test'
            }
          }
        }
      }
    });

    await prisma.productImage.deleteMany({
      where: {
        colorVariation: {
          product: {
            name: 'T-shirt Test'
          }
        }
      }
    });

    await prisma.colorVariation.deleteMany({
      where: {
        product: {
          name: 'T-shirt Test'
        }
      }
    });

    await prisma.product.deleteMany({
      where: {
        name: 'T-shirt Test'
      }
    });

    await prisma.user.deleteMany({
      where: {
        email: 'test-vendor-publish@example.com'
      }
    });

    console.log('‚úÖ Nettoyage termin√©');

  } catch (error) {
    console.error('‚ùå Erreur lors du nettoyage:', error);
  }
}

// Mock jest si non disponible
if (typeof jest === 'undefined') {
  global.jest = {
    fn: () => ({
      mockResolvedValue: (value) => ({
        mock: { calls: [] },
        ...(() => Promise.resolve(value))
      })
    })
  };
}

// Ex√©cuter le test
if (require.main === module) {
  testVendorPublishDeduplication()
    .then(() => {
      console.log('\nüéâ Tous les tests termin√©s !');
      process.exit(0);
    })
    .catch((error) => {
      console.error('üí• Erreur fatale:', error);
      process.exit(1);
    });
}

module.exports = { testVendorPublishDeduplication }; 