const { PrismaClient } = require('@prisma/client');
const crypto = require('crypto');

const prisma = new PrismaClient();

async function testDesignDeduplication() {
  console.log('üß™ Test complet du syst√®me de d√©duplication des designs...\n');

  try {
    // 1. Cr√©er un vendeur de test
    const vendor = await prisma.user.upsert({
      where: { email: 'test-vendor-dedup@example.com' },
      update: {},
      create: {
        firstName: 'Test',
        lastName: 'Vendor',
        email: 'test-vendor-dedup@example.com',
        password: 'hashedpassword',
        role: 'VENDEUR'
      }
    });

    console.log(`‚úÖ Vendeur cr√©√©/trouv√©: ${vendor.id}`);

    // 2. Cr√©er un admin de test
    const admin = await prisma.user.upsert({
      where: { email: 'test-admin-dedup@example.com' },
      update: {},
      create: {
        firstName: 'Test',
        lastName: 'Admin',
        email: 'test-admin-dedup@example.com',
        password: 'hashedpassword',
        role: 'ADMIN'
      }
    });

    console.log(`‚úÖ Admin cr√©√©/trouv√©: ${admin.id}`);

    // 3. Cr√©er un produit de base s'il n'existe pas
    const baseProduct = await prisma.product.upsert({
      where: { id: 1 },
      update: {},
      create: {
        id: 1,
        name: 'T-shirt Basique Test',
        description: 'Produit de base pour test',
        price: 15000,
        stock: 100,
        status: 'PUBLISHED'
      }
    });

    console.log(`‚úÖ Produit de base cr√©√©/trouv√©: ${baseProduct.id}`);

    // 4. Design de test (m√™me contenu)
    const testDesignBase64 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==';
    const designContent = testDesignBase64.replace(/^data:image\/[a-z]+;base64,/, '');
    const designHash = crypto.createHash('sha256').update(designContent).digest('hex');

    console.log(`üé® Hash du design test: ${designHash.substring(0, 12)}...`);

    // 5. Nettoyer les donn√©es de test pr√©c√©dentes
    await cleanup();

    // 6. Test 1: Cr√©er le premier produit avec ce design
    console.log('\nüì¶ Test 1: Cr√©ation du premier produit...');
    
    const publishDto1 = {
      baseProductId: baseProduct.id,
      vendorName: 'T-shirt Design Test 1',
      vendorDescription: 'Premier produit avec design',
      vendorPrice: 25000,
      vendorStock: 100,
      selectedColors: [{ id: 1, name: 'Rouge', code: '#ff0000' }],
      selectedSizes: [{ id: 1, name: 'M' }],
      finalImagesBase64: { design: testDesignBase64 },
      productStructure: {
        adminProduct: {
          id: baseProduct.id,
          name: baseProduct.name,
          description: baseProduct.description,
          price: baseProduct.price,
          images: {
            colorVariations: [
              {
                id: 1,
                name: 'Rouge',
                colorCode: '#ff0000',
                images: [
                  {
                    id: 1,
                    url: 'https://example.com/image1.jpg',
                    view: 'Front'
                  }
                ]
              }
            ]
          }
        },
        designApplication: { scale: 0.6 }
      },
      postValidationAction: 'AUTO_PUBLISH'
    };

    // Simuler la cr√©ation du produit 1
    const product1 = await createProductWithDesign(publishDto1, vendor.id);
    console.log(`‚úÖ Produit 1 cr√©√©: ${product1.id} avec design: ${product1.designId}`);

    // 7. Test 2: Cr√©er le deuxi√®me produit avec le M√äME design
    console.log('\nüì¶ Test 2: Cr√©ation du deuxi√®me produit avec le m√™me design...');
    
    const publishDto2 = {
      ...publishDto1,
      vendorName: 'T-shirt Design Test 2',
      vendorDescription: 'Deuxi√®me produit avec M√äME design',
      postValidationAction: 'TO_DRAFT'
    };

    const product2 = await createProductWithDesign(publishDto2, vendor.id);
    console.log(`‚úÖ Produit 2 cr√©√©: ${product2.id} avec design: ${product2.designId}`);

    // 8. V√©rifier que les deux produits utilisent le m√™me design
    console.log('\nüîç V√©rification de la d√©duplication...');
    
    if (product1.designId === product2.designId) {
      console.log(`‚úÖ SUCC√àS: Les deux produits utilisent le m√™me design (ID: ${product1.designId})`);
    } else {
      console.log(`‚ùå √âCHEC: Les produits utilisent des designs diff√©rents (${product1.designId} vs ${product2.designId})`);
      return;
    }

    // 9. V√©rifier qu'il n'y a qu'un seul design en base avec ce hash
    const designsWithHash = await prisma.design.findMany({
      where: { contentHash: designHash }
    });

    console.log(`üìä Nombre de designs avec ce hash: ${designsWithHash.length}`);
    
    if (designsWithHash.length === 1) {
      console.log('‚úÖ SUCC√àS: Un seul design en base');
    } else {
      console.log('‚ùå √âCHEC: Plusieurs designs avec le m√™me hash');
      return;
    }

    // 10. Test de la cascade validation
    console.log('\nüîÑ Test de la cascade validation...');
    
    // Valider le design
    const design = designsWithHash[0];
    await prisma.design.update({
      where: { id: design.id },
      data: {
        isValidated: true,
        validatedAt: new Date(),
        validatedBy: admin.id,
        isPending: false
      }
    });

    console.log(`‚úÖ Design ${design.id} valid√© par admin ${admin.id}`);

    // Simuler la cascade validation
    await simulateCascadeValidation(design.id);

    // 11. V√©rifier les r√©sultats de la cascade
    console.log('\nüìä V√©rification des r√©sultats de la cascade...');
    
    const updatedProduct1 = await prisma.vendorProduct.findUnique({
      where: { id: product1.id }
    });

    const updatedProduct2 = await prisma.vendorProduct.findUnique({
      where: { id: product2.id }
    });

    console.log(`Produit 1 - isValidated: ${updatedProduct1.isValidated}, status: ${updatedProduct1.status}`);
    console.log(`Produit 2 - isValidated: ${updatedProduct2.isValidated}, status: ${updatedProduct2.status}`);

    // V√©rifier les actions post-validation
    if (updatedProduct1.isValidated && updatedProduct1.status === 'PUBLISHED') {
      console.log('‚úÖ Produit 1: Valid√© et publi√© automatiquement (AUTO_PUBLISH)');
    } else {
      console.log('‚ùå Produit 1: Probl√®me avec la cascade validation');
    }

    if (updatedProduct2.isValidated && updatedProduct2.status === 'DRAFT') {
      console.log('‚úÖ Produit 2: Valid√© et en brouillon (TO_DRAFT)');
    } else {
      console.log('‚ùå Produit 2: Probl√®me avec la cascade validation');
    }

    // 12. Statistiques finales
    console.log('\nüìä Statistiques finales...');
    
    const totalDesigns = await prisma.design.count();
    const totalProducts = await prisma.vendorProduct.count({
      where: { vendorId: vendor.id }
    });
    const totalLinks = await prisma.designProductLink.count();

    console.log(`Designs total: ${totalDesigns}`);
    console.log(`Produits vendeur: ${totalProducts}`);
    console.log(`Liens design-produit: ${totalLinks}`);

    console.log('\nüéâ Test de d√©duplication termin√© avec succ√®s !');

  } catch (error) {
    console.error('‚ùå Erreur durant le test:', error);
  } finally {
    await cleanup();
    await prisma.$disconnect();
  }
}

async function createProductWithDesign(publishDto, vendorId) {
  // Calculer le hash du design
  const designContent = publishDto.finalImagesBase64.design.replace(/^data:image\/[a-z]+;base64,/, '');
  const designHash = crypto.createHash('sha256').update(designContent).digest('hex');

  // Rechercher un design existant
  let design = await prisma.design.findFirst({
    where: { contentHash: designHash }
  });

  if (!design) {
    // Cr√©er un nouveau design
    design = await prisma.design.create({
      data: {
        vendorId: vendorId,
        name: `Design ${designHash.substring(0, 8)}`,
        description: `Design cr√©√© par vendeur ${vendorId}`,
        price: 0,
        category: 'ILLUSTRATION',
        imageUrl: `https://example.com/design_${designHash.substring(0, 12)}.jpg`,
        thumbnailUrl: `https://example.com/design_${designHash.substring(0, 12)}_thumb.jpg`,
        cloudinaryPublicId: `design_${designHash.substring(0, 12)}`,
        fileSize: 1000,
        originalFileName: `design_${designHash.substring(0, 12)}`,
        contentHash: designHash,
        dimensions: { width: 500, height: 500 },
        format: 'jpg',
        tags: ['test'],
        isDraft: false,
        isPublished: false,
        isPending: true,
        isValidated: false
      }
    });
    console.log(`üé® Nouveau design cr√©√©: ${design.id}`);
  } else {
    console.log(`üîÑ Design existant r√©utilis√©: ${design.id}`);
  }

  // Cr√©er le produit vendeur
  const vendorProduct = await prisma.vendorProduct.create({
    data: {
      baseProductId: publishDto.baseProductId,
      vendorId: vendorId,
      name: publishDto.vendorName,
      description: publishDto.vendorDescription,
      price: publishDto.vendorPrice,
      stock: publishDto.vendorStock,
      designId: design.id,
      designCloudinaryUrl: design.imageUrl,
      designCloudinaryPublicId: design.cloudinaryPublicId,
      sizes: JSON.stringify(publishDto.selectedSizes),
      colors: JSON.stringify(publishDto.selectedColors),
      status: 'PENDING',
      isValidated: false,
      postValidationAction: publishDto.postValidationAction,
      adminProductName: publishDto.productStructure.adminProduct.name,
      adminProductDescription: publishDto.productStructure.adminProduct.description,
      adminProductPrice: publishDto.productStructure.adminProduct.price,
      vendorName: publishDto.vendorName,
      vendorDescription: publishDto.vendorDescription,
      vendorStock: publishDto.vendorStock,
      basePriceAdmin: publishDto.productStructure.adminProduct.price
    }
  });

  // Cr√©er le lien design-produit
  await prisma.designProductLink.create({
    data: {
      designId: design.id,
      vendorProductId: vendorProduct.id
    }
  });

  return { ...vendorProduct, designId: design.id };
}

async function simulateCascadeValidation(designId) {
  console.log(`üîÑ Simulation cascade validation pour design ${designId}...`);

  // R√©cup√©rer tous les produits li√©s √† ce design
  const linkedProducts = await prisma.vendorProduct.findMany({
    where: {
      designId: designId
    }
  });

  console.log(`üì¶ ${linkedProducts.length} produits li√©s trouv√©s`);

  // Mettre √† jour chaque produit selon son action post-validation
  for (const product of linkedProducts) {
    const newStatus = product.postValidationAction === 'AUTO_PUBLISH' ? 'PUBLISHED' : 'DRAFT';
    
    await prisma.vendorProduct.update({
      where: { id: product.id },
      data: {
        isValidated: true,
        validatedAt: new Date(),
        status: newStatus
      }
    });

    console.log(`‚úÖ Produit ${product.id}: ${product.postValidationAction} ‚Üí ${newStatus}`);
  }
}

async function cleanup() {
  console.log('üßπ Nettoyage des donn√©es de test...');

  try {
    // Supprimer les liens
    await prisma.designProductLink.deleteMany({
      where: {
        vendorProduct: {
          vendor: {
            email: 'test-vendor-dedup@example.com'
          }
        }
      }
    });

    // Supprimer les produits de test
    await prisma.vendorProduct.deleteMany({
      where: {
        vendor: {
          email: 'test-vendor-dedup@example.com'
        }
      }
    });

    // Supprimer les designs de test
    await prisma.design.deleteMany({
      where: {
        vendor: {
          email: 'test-vendor-dedup@example.com'
        }
      }
    });

    // Supprimer les utilisateurs de test
    await prisma.user.deleteMany({
      where: {
        email: {
          in: ['test-vendor-dedup@example.com', 'test-admin-dedup@example.com']
        }
      }
    });

    console.log('‚úÖ Nettoyage termin√©');

  } catch (error) {
    console.error('‚ùå Erreur lors du nettoyage:', error);
  }
}

// Ex√©cuter le test
if (require.main === module) {
  testDesignDeduplication()
    .then(() => {
      console.log('\nüéâ Tous les tests termin√©s !');
      process.exit(0);
    })
    .catch((error) => {
      console.error('üí• Erreur fatale:', error);
      process.exit(1);
    });
}

module.exports = { testDesignDeduplication }; 