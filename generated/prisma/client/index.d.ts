
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model PasswordReset
 * 
 */
export type PasswordReset = $Result.DefaultSelection<Prisma.$PasswordResetPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductSize
 * 
 */
export type ProductSize = $Result.DefaultSelection<Prisma.$ProductSizePayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model ColorVariation
 * 
 */
export type ColorVariation = $Result.DefaultSelection<Prisma.$ColorVariationPayload>
/**
 * Model ProductImage
 * 
 */
export type ProductImage = $Result.DefaultSelection<Prisma.$ProductImagePayload>
/**
 * Model Delimitation
 * 
 */
export type Delimitation = $Result.DefaultSelection<Prisma.$DelimitationPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Design
 * 
 */
export type Design = $Result.DefaultSelection<Prisma.$DesignPayload>
/**
 * Model VendorProduct
 * VendorProduct représente un produit mis en vente par un vendeur à partir d'un produit de base (admin).
 * Il stocke les variantes sélectionnées (tailles, couleurs) sous forme de tableau JSON pour simplifier le schéma.
 */
export type VendorProduct = $Result.DefaultSelection<Prisma.$VendorProductPayload>
/**
 * Model VendorProductImage
 * VendorProductImage stocke les images générées pour chaque produit vendeur avec métadonnées Cloudinary
 * ⚠️ DEPRECATED: Cette table sera progressivement remplacée par VendorProductMockup
 */
export type VendorProductImage = $Result.DefaultSelection<Prisma.$VendorProductImagePayload>
/**
 * Model DesignTransformation
 * DesignTransformation stocke les transformations personnalisées du design pour chaque délimitation
 * Permet aux vendeurs de redimensionner et recadrer leurs designs de manière persistante
 */
export type DesignTransformation = $Result.DefaultSelection<Prisma.$DesignTransformationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PublicationStatus: {
  PUBLISHED: 'PUBLISHED',
  DRAFT: 'DRAFT',
  PENDING: 'PENDING'
};

export type PublicationStatus = (typeof PublicationStatus)[keyof typeof PublicationStatus]


export const VendorProductStatus: {
  PUBLISHED: 'PUBLISHED',
  DRAFT: 'DRAFT',
  PENDING: 'PENDING'
};

export type VendorProductStatus = (typeof VendorProductStatus)[keyof typeof VendorProductStatus]


export const ViewType: {
  FRONT: 'FRONT',
  BACK: 'BACK',
  LEFT: 'LEFT',
  RIGHT: 'RIGHT',
  TOP: 'TOP',
  BOTTOM: 'BOTTOM',
  DETAIL: 'DETAIL',
  OTHER: 'OTHER'
};

export type ViewType = (typeof ViewType)[keyof typeof ViewType]


export const Role: {
  SUPERADMIN: 'SUPERADMIN',
  ADMIN: 'ADMIN',
  VENDEUR: 'VENDEUR'
};

export type Role = (typeof Role)[keyof typeof Role]


export const VendeurType: {
  DESIGNER: 'DESIGNER',
  INFLUENCEUR: 'INFLUENCEUR',
  ARTISTE: 'ARTISTE'
};

export type VendeurType = (typeof VendeurType)[keyof typeof VendeurType]


export const SizeType: {
  XS: 'XS',
  S: 'S',
  M: 'M',
  L: 'L',
  XL: 'XL',
  XXL: 'XXL',
  XXXL: 'XXXL'
};

export type SizeType = (typeof SizeType)[keyof typeof SizeType]


export const OrderStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  PROCESSING: 'PROCESSING',
  SHIPPED: 'SHIPPED',
  DELIVERED: 'DELIVERED',
  CANCELLED: 'CANCELLED',
  REJECTED: 'REJECTED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const NotificationType: {
  ORDER_NEW: 'ORDER_NEW',
  ORDER_UPDATED: 'ORDER_UPDATED',
  SYSTEM: 'SYSTEM',
  SUCCESS: 'SUCCESS',
  WARNING: 'WARNING',
  ERROR: 'ERROR'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const CoordinateType: {
  PERCENTAGE: 'PERCENTAGE',
  ABSOLUTE: 'ABSOLUTE'
};

export type CoordinateType = (typeof CoordinateType)[keyof typeof CoordinateType]


export const DesignPositioning: {
  CENTER: 'CENTER',
  TOP: 'TOP',
  BOTTOM: 'BOTTOM'
};

export type DesignPositioning = (typeof DesignPositioning)[keyof typeof DesignPositioning]


export const DesignCategory: {
  LOGO: 'LOGO',
  PATTERN: 'PATTERN',
  ILLUSTRATION: 'ILLUSTRATION',
  TYPOGRAPHY: 'TYPOGRAPHY',
  ABSTRACT: 'ABSTRACT'
};

export type DesignCategory = (typeof DesignCategory)[keyof typeof DesignCategory]

}

export type PublicationStatus = $Enums.PublicationStatus

export const PublicationStatus: typeof $Enums.PublicationStatus

export type VendorProductStatus = $Enums.VendorProductStatus

export const VendorProductStatus: typeof $Enums.VendorProductStatus

export type ViewType = $Enums.ViewType

export const ViewType: typeof $Enums.ViewType

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type VendeurType = $Enums.VendeurType

export const VendeurType: typeof $Enums.VendeurType

export type SizeType = $Enums.SizeType

export const SizeType: typeof $Enums.SizeType

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type CoordinateType = $Enums.CoordinateType

export const CoordinateType: typeof $Enums.CoordinateType

export type DesignPositioning = $Enums.DesignPositioning

export const DesignPositioning: typeof $Enums.DesignPositioning

export type DesignCategory = $Enums.DesignCategory

export const DesignCategory: typeof $Enums.DesignCategory

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordReset`: Exposes CRUD operations for the **PasswordReset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResets
    * const passwordResets = await prisma.passwordReset.findMany()
    * ```
    */
  get passwordReset(): Prisma.PasswordResetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productSize`: Exposes CRUD operations for the **ProductSize** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductSizes
    * const productSizes = await prisma.productSize.findMany()
    * ```
    */
  get productSize(): Prisma.ProductSizeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.colorVariation`: Exposes CRUD operations for the **ColorVariation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ColorVariations
    * const colorVariations = await prisma.colorVariation.findMany()
    * ```
    */
  get colorVariation(): Prisma.ColorVariationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productImage`: Exposes CRUD operations for the **ProductImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductImages
    * const productImages = await prisma.productImage.findMany()
    * ```
    */
  get productImage(): Prisma.ProductImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.delimitation`: Exposes CRUD operations for the **Delimitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Delimitations
    * const delimitations = await prisma.delimitation.findMany()
    * ```
    */
  get delimitation(): Prisma.DelimitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.design`: Exposes CRUD operations for the **Design** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Designs
    * const designs = await prisma.design.findMany()
    * ```
    */
  get design(): Prisma.DesignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorProduct`: Exposes CRUD operations for the **VendorProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorProducts
    * const vendorProducts = await prisma.vendorProduct.findMany()
    * ```
    */
  get vendorProduct(): Prisma.VendorProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorProductImage`: Exposes CRUD operations for the **VendorProductImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorProductImages
    * const vendorProductImages = await prisma.vendorProductImage.findMany()
    * ```
    */
  get vendorProductImage(): Prisma.VendorProductImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.designTransformation`: Exposes CRUD operations for the **DesignTransformation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DesignTransformations
    * const designTransformations = await prisma.designTransformation.findMany()
    * ```
    */
  get designTransformation(): Prisma.DesignTransformationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    PasswordReset: 'PasswordReset',
    Product: 'Product',
    ProductSize: 'ProductSize',
    Category: 'Category',
    ColorVariation: 'ColorVariation',
    ProductImage: 'ProductImage',
    Delimitation: 'Delimitation',
    Order: 'Order',
    OrderItem: 'OrderItem',
    Notification: 'Notification',
    Design: 'Design',
    VendorProduct: 'VendorProduct',
    VendorProductImage: 'VendorProductImage',
    DesignTransformation: 'DesignTransformation'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "passwordReset" | "product" | "productSize" | "category" | "colorVariation" | "productImage" | "delimitation" | "order" | "orderItem" | "notification" | "design" | "vendorProduct" | "vendorProductImage" | "designTransformation"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      PasswordReset: {
        payload: Prisma.$PasswordResetPayload<ExtArgs>
        fields: Prisma.PasswordResetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          findMany: {
            args: Prisma.PasswordResetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          create: {
            args: Prisma.PasswordResetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          createMany: {
            args: Prisma.PasswordResetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          update: {
            args: Prisma.PasswordResetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordReset>
          }
          groupBy: {
            args: Prisma.PasswordResetGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductSize: {
        payload: Prisma.$ProductSizePayload<ExtArgs>
        fields: Prisma.ProductSizeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductSizeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductSizeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          findFirst: {
            args: Prisma.ProductSizeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductSizeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          findMany: {
            args: Prisma.ProductSizeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>[]
          }
          create: {
            args: Prisma.ProductSizeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          createMany: {
            args: Prisma.ProductSizeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductSizeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>[]
          }
          delete: {
            args: Prisma.ProductSizeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          update: {
            args: Prisma.ProductSizeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          deleteMany: {
            args: Prisma.ProductSizeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductSizeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductSizeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>[]
          }
          upsert: {
            args: Prisma.ProductSizeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          aggregate: {
            args: Prisma.ProductSizeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductSize>
          }
          groupBy: {
            args: Prisma.ProductSizeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductSizeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductSizeCountArgs<ExtArgs>
            result: $Utils.Optional<ProductSizeCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      ColorVariation: {
        payload: Prisma.$ColorVariationPayload<ExtArgs>
        fields: Prisma.ColorVariationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ColorVariationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorVariationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ColorVariationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorVariationPayload>
          }
          findFirst: {
            args: Prisma.ColorVariationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorVariationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ColorVariationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorVariationPayload>
          }
          findMany: {
            args: Prisma.ColorVariationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorVariationPayload>[]
          }
          create: {
            args: Prisma.ColorVariationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorVariationPayload>
          }
          createMany: {
            args: Prisma.ColorVariationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ColorVariationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorVariationPayload>[]
          }
          delete: {
            args: Prisma.ColorVariationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorVariationPayload>
          }
          update: {
            args: Prisma.ColorVariationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorVariationPayload>
          }
          deleteMany: {
            args: Prisma.ColorVariationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ColorVariationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ColorVariationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorVariationPayload>[]
          }
          upsert: {
            args: Prisma.ColorVariationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorVariationPayload>
          }
          aggregate: {
            args: Prisma.ColorVariationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateColorVariation>
          }
          groupBy: {
            args: Prisma.ColorVariationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ColorVariationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ColorVariationCountArgs<ExtArgs>
            result: $Utils.Optional<ColorVariationCountAggregateOutputType> | number
          }
        }
      }
      ProductImage: {
        payload: Prisma.$ProductImagePayload<ExtArgs>
        fields: Prisma.ProductImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          findFirst: {
            args: Prisma.ProductImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          findMany: {
            args: Prisma.ProductImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>[]
          }
          create: {
            args: Prisma.ProductImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          createMany: {
            args: Prisma.ProductImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>[]
          }
          delete: {
            args: Prisma.ProductImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          update: {
            args: Prisma.ProductImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          deleteMany: {
            args: Prisma.ProductImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>[]
          }
          upsert: {
            args: Prisma.ProductImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          aggregate: {
            args: Prisma.ProductImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductImage>
          }
          groupBy: {
            args: Prisma.ProductImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductImageCountArgs<ExtArgs>
            result: $Utils.Optional<ProductImageCountAggregateOutputType> | number
          }
        }
      }
      Delimitation: {
        payload: Prisma.$DelimitationPayload<ExtArgs>
        fields: Prisma.DelimitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DelimitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelimitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DelimitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelimitationPayload>
          }
          findFirst: {
            args: Prisma.DelimitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelimitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DelimitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelimitationPayload>
          }
          findMany: {
            args: Prisma.DelimitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelimitationPayload>[]
          }
          create: {
            args: Prisma.DelimitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelimitationPayload>
          }
          createMany: {
            args: Prisma.DelimitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DelimitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelimitationPayload>[]
          }
          delete: {
            args: Prisma.DelimitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelimitationPayload>
          }
          update: {
            args: Prisma.DelimitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelimitationPayload>
          }
          deleteMany: {
            args: Prisma.DelimitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DelimitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DelimitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelimitationPayload>[]
          }
          upsert: {
            args: Prisma.DelimitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelimitationPayload>
          }
          aggregate: {
            args: Prisma.DelimitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDelimitation>
          }
          groupBy: {
            args: Prisma.DelimitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DelimitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DelimitationCountArgs<ExtArgs>
            result: $Utils.Optional<DelimitationCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Design: {
        payload: Prisma.$DesignPayload<ExtArgs>
        fields: Prisma.DesignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DesignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DesignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignPayload>
          }
          findFirst: {
            args: Prisma.DesignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DesignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignPayload>
          }
          findMany: {
            args: Prisma.DesignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignPayload>[]
          }
          create: {
            args: Prisma.DesignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignPayload>
          }
          createMany: {
            args: Prisma.DesignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DesignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignPayload>[]
          }
          delete: {
            args: Prisma.DesignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignPayload>
          }
          update: {
            args: Prisma.DesignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignPayload>
          }
          deleteMany: {
            args: Prisma.DesignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DesignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DesignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignPayload>[]
          }
          upsert: {
            args: Prisma.DesignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignPayload>
          }
          aggregate: {
            args: Prisma.DesignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDesign>
          }
          groupBy: {
            args: Prisma.DesignGroupByArgs<ExtArgs>
            result: $Utils.Optional<DesignGroupByOutputType>[]
          }
          count: {
            args: Prisma.DesignCountArgs<ExtArgs>
            result: $Utils.Optional<DesignCountAggregateOutputType> | number
          }
        }
      }
      VendorProduct: {
        payload: Prisma.$VendorProductPayload<ExtArgs>
        fields: Prisma.VendorProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductPayload>
          }
          findFirst: {
            args: Prisma.VendorProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductPayload>
          }
          findMany: {
            args: Prisma.VendorProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductPayload>[]
          }
          create: {
            args: Prisma.VendorProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductPayload>
          }
          createMany: {
            args: Prisma.VendorProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductPayload>[]
          }
          delete: {
            args: Prisma.VendorProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductPayload>
          }
          update: {
            args: Prisma.VendorProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductPayload>
          }
          deleteMany: {
            args: Prisma.VendorProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductPayload>[]
          }
          upsert: {
            args: Prisma.VendorProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductPayload>
          }
          aggregate: {
            args: Prisma.VendorProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorProduct>
          }
          groupBy: {
            args: Prisma.VendorProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorProductCountArgs<ExtArgs>
            result: $Utils.Optional<VendorProductCountAggregateOutputType> | number
          }
        }
      }
      VendorProductImage: {
        payload: Prisma.$VendorProductImagePayload<ExtArgs>
        fields: Prisma.VendorProductImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorProductImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorProductImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductImagePayload>
          }
          findFirst: {
            args: Prisma.VendorProductImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorProductImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductImagePayload>
          }
          findMany: {
            args: Prisma.VendorProductImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductImagePayload>[]
          }
          create: {
            args: Prisma.VendorProductImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductImagePayload>
          }
          createMany: {
            args: Prisma.VendorProductImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorProductImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductImagePayload>[]
          }
          delete: {
            args: Prisma.VendorProductImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductImagePayload>
          }
          update: {
            args: Prisma.VendorProductImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductImagePayload>
          }
          deleteMany: {
            args: Prisma.VendorProductImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorProductImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorProductImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductImagePayload>[]
          }
          upsert: {
            args: Prisma.VendorProductImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProductImagePayload>
          }
          aggregate: {
            args: Prisma.VendorProductImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorProductImage>
          }
          groupBy: {
            args: Prisma.VendorProductImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorProductImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorProductImageCountArgs<ExtArgs>
            result: $Utils.Optional<VendorProductImageCountAggregateOutputType> | number
          }
        }
      }
      DesignTransformation: {
        payload: Prisma.$DesignTransformationPayload<ExtArgs>
        fields: Prisma.DesignTransformationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DesignTransformationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignTransformationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DesignTransformationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignTransformationPayload>
          }
          findFirst: {
            args: Prisma.DesignTransformationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignTransformationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DesignTransformationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignTransformationPayload>
          }
          findMany: {
            args: Prisma.DesignTransformationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignTransformationPayload>[]
          }
          create: {
            args: Prisma.DesignTransformationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignTransformationPayload>
          }
          createMany: {
            args: Prisma.DesignTransformationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DesignTransformationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignTransformationPayload>[]
          }
          delete: {
            args: Prisma.DesignTransformationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignTransformationPayload>
          }
          update: {
            args: Prisma.DesignTransformationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignTransformationPayload>
          }
          deleteMany: {
            args: Prisma.DesignTransformationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DesignTransformationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DesignTransformationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignTransformationPayload>[]
          }
          upsert: {
            args: Prisma.DesignTransformationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignTransformationPayload>
          }
          aggregate: {
            args: Prisma.DesignTransformationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDesignTransformation>
          }
          groupBy: {
            args: Prisma.DesignTransformationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DesignTransformationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DesignTransformationCountArgs<ExtArgs>
            result: $Utils.Optional<DesignTransformationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    passwordReset?: PasswordResetOmit
    product?: ProductOmit
    productSize?: ProductSizeOmit
    category?: CategoryOmit
    colorVariation?: ColorVariationOmit
    productImage?: ProductImageOmit
    delimitation?: DelimitationOmit
    order?: OrderOmit
    orderItem?: OrderItemOmit
    notification?: NotificationOmit
    design?: DesignOmit
    vendorProduct?: VendorProductOmit
    vendorProductImage?: VendorProductImageOmit
    designTransformation?: DesignTransformationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    passwordResets: number
    orders: number
    validatedOrders: number
    notifications: number
    designs: number
    validatedDesigns: number
    validatedProducts: number
    validatedVendorProducts: number
    vendorProducts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passwordResets?: boolean | UserCountOutputTypeCountPasswordResetsArgs
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    validatedOrders?: boolean | UserCountOutputTypeCountValidatedOrdersArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    designs?: boolean | UserCountOutputTypeCountDesignsArgs
    validatedDesigns?: boolean | UserCountOutputTypeCountValidatedDesignsArgs
    validatedProducts?: boolean | UserCountOutputTypeCountValidatedProductsArgs
    validatedVendorProducts?: boolean | UserCountOutputTypeCountValidatedVendorProductsArgs
    vendorProducts?: boolean | UserCountOutputTypeCountVendorProductsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountValidatedOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDesignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountValidatedDesignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountValidatedProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountValidatedVendorProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorProductWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVendorProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorProductWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    categories: number
    sizes: number
    colorVariations: number
    orderItems: number
    vendorProducts: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | ProductCountOutputTypeCountCategoriesArgs
    sizes?: boolean | ProductCountOutputTypeCountSizesArgs
    colorVariations?: boolean | ProductCountOutputTypeCountColorVariationsArgs
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
    vendorProducts?: boolean | ProductCountOutputTypeCountVendorProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSizesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductSizeWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountColorVariationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ColorVariationWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountVendorProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorProductWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ColorVariationCountOutputType
   */

  export type ColorVariationCountOutputType = {
    images: number
    orderItems: number
    vendorProductImages: number
  }

  export type ColorVariationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | ColorVariationCountOutputTypeCountImagesArgs
    orderItems?: boolean | ColorVariationCountOutputTypeCountOrderItemsArgs
    vendorProductImages?: boolean | ColorVariationCountOutputTypeCountVendorProductImagesArgs
  }

  // Custom InputTypes
  /**
   * ColorVariationCountOutputType without action
   */
  export type ColorVariationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorVariationCountOutputType
     */
    select?: ColorVariationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ColorVariationCountOutputType without action
   */
  export type ColorVariationCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImageWhereInput
  }

  /**
   * ColorVariationCountOutputType without action
   */
  export type ColorVariationCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ColorVariationCountOutputType without action
   */
  export type ColorVariationCountOutputTypeCountVendorProductImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorProductImageWhereInput
  }


  /**
   * Count Type ProductImageCountOutputType
   */

  export type ProductImageCountOutputType = {
    delimitations: number
  }

  export type ProductImageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delimitations?: boolean | ProductImageCountOutputTypeCountDelimitationsArgs
  }

  // Custom InputTypes
  /**
   * ProductImageCountOutputType without action
   */
  export type ProductImageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImageCountOutputType
     */
    select?: ProductImageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductImageCountOutputType without action
   */
  export type ProductImageCountOutputTypeCountDelimitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DelimitationWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    orderItems: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | OrderCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type VendorProductCountOutputType
   */

  export type VendorProductCountOutputType = {
    images: number
    transformations: number
  }

  export type VendorProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | VendorProductCountOutputTypeCountImagesArgs
    transformations?: boolean | VendorProductCountOutputTypeCountTransformationsArgs
  }

  // Custom InputTypes
  /**
   * VendorProductCountOutputType without action
   */
  export type VendorProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProductCountOutputType
     */
    select?: VendorProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendorProductCountOutputType without action
   */
  export type VendorProductCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorProductImageWhereInput
  }

  /**
   * VendorProductCountOutputType without action
   */
  export type VendorProductCountOutputTypeCountTransformationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignTransformationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    login_attempts: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    login_attempts: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    status: boolean | null
    photo_profil: string | null
    login_attempts: number | null
    locked_until: Date | null
    last_login_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    must_change_password: boolean | null
    vendeur_type: $Enums.VendeurType | null
    phone: string | null
    country: string | null
    address: string | null
    shop_name: string | null
    profile_photo_url: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    status: boolean | null
    photo_profil: string | null
    login_attempts: number | null
    locked_until: Date | null
    last_login_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    must_change_password: boolean | null
    vendeur_type: $Enums.VendeurType | null
    phone: string | null
    country: string | null
    address: string | null
    shop_name: string | null
    profile_photo_url: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    password: number
    role: number
    status: number
    photo_profil: number
    login_attempts: number
    locked_until: number
    last_login_at: number
    created_at: number
    updated_at: number
    must_change_password: number
    vendeur_type: number
    phone: number
    country: number
    address: number
    shop_name: number
    profile_photo_url: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    login_attempts?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    login_attempts?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    role?: true
    status?: true
    photo_profil?: true
    login_attempts?: true
    locked_until?: true
    last_login_at?: true
    created_at?: true
    updated_at?: true
    must_change_password?: true
    vendeur_type?: true
    phone?: true
    country?: true
    address?: true
    shop_name?: true
    profile_photo_url?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    role?: true
    status?: true
    photo_profil?: true
    login_attempts?: true
    locked_until?: true
    last_login_at?: true
    created_at?: true
    updated_at?: true
    must_change_password?: true
    vendeur_type?: true
    phone?: true
    country?: true
    address?: true
    shop_name?: true
    profile_photo_url?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    role?: true
    status?: true
    photo_profil?: true
    login_attempts?: true
    locked_until?: true
    last_login_at?: true
    created_at?: true
    updated_at?: true
    must_change_password?: true
    vendeur_type?: true
    phone?: true
    country?: true
    address?: true
    shop_name?: true
    profile_photo_url?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    firstName: string
    lastName: string
    email: string
    password: string
    role: $Enums.Role
    status: boolean
    photo_profil: string | null
    login_attempts: number
    locked_until: Date | null
    last_login_at: Date | null
    created_at: Date
    updated_at: Date
    must_change_password: boolean
    vendeur_type: $Enums.VendeurType | null
    phone: string | null
    country: string | null
    address: string | null
    shop_name: string | null
    profile_photo_url: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    status?: boolean
    photo_profil?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    last_login_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    must_change_password?: boolean
    vendeur_type?: boolean
    phone?: boolean
    country?: boolean
    address?: boolean
    shop_name?: boolean
    profile_photo_url?: boolean
    passwordResets?: boolean | User$passwordResetsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    validatedOrders?: boolean | User$validatedOrdersArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    designs?: boolean | User$designsArgs<ExtArgs>
    validatedDesigns?: boolean | User$validatedDesignsArgs<ExtArgs>
    validatedProducts?: boolean | User$validatedProductsArgs<ExtArgs>
    validatedVendorProducts?: boolean | User$validatedVendorProductsArgs<ExtArgs>
    vendorProducts?: boolean | User$vendorProductsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    status?: boolean
    photo_profil?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    last_login_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    must_change_password?: boolean
    vendeur_type?: boolean
    phone?: boolean
    country?: boolean
    address?: boolean
    shop_name?: boolean
    profile_photo_url?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    status?: boolean
    photo_profil?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    last_login_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    must_change_password?: boolean
    vendeur_type?: boolean
    phone?: boolean
    country?: boolean
    address?: boolean
    shop_name?: boolean
    profile_photo_url?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    status?: boolean
    photo_profil?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    last_login_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    must_change_password?: boolean
    vendeur_type?: boolean
    phone?: boolean
    country?: boolean
    address?: boolean
    shop_name?: boolean
    profile_photo_url?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "email" | "password" | "role" | "status" | "photo_profil" | "login_attempts" | "locked_until" | "last_login_at" | "created_at" | "updated_at" | "must_change_password" | "vendeur_type" | "phone" | "country" | "address" | "shop_name" | "profile_photo_url", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passwordResets?: boolean | User$passwordResetsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    validatedOrders?: boolean | User$validatedOrdersArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    designs?: boolean | User$designsArgs<ExtArgs>
    validatedDesigns?: boolean | User$validatedDesignsArgs<ExtArgs>
    validatedProducts?: boolean | User$validatedProductsArgs<ExtArgs>
    validatedVendorProducts?: boolean | User$validatedVendorProductsArgs<ExtArgs>
    vendorProducts?: boolean | User$vendorProductsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      passwordResets: Prisma.$PasswordResetPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      validatedOrders: Prisma.$OrderPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      designs: Prisma.$DesignPayload<ExtArgs>[]
      validatedDesigns: Prisma.$DesignPayload<ExtArgs>[]
      validatedProducts: Prisma.$ProductPayload<ExtArgs>[]
      validatedVendorProducts: Prisma.$VendorProductPayload<ExtArgs>[]
      vendorProducts: Prisma.$VendorProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      firstName: string
      lastName: string
      email: string
      password: string
      role: $Enums.Role
      status: boolean
      photo_profil: string | null
      login_attempts: number
      locked_until: Date | null
      last_login_at: Date | null
      created_at: Date
      updated_at: Date
      must_change_password: boolean
      vendeur_type: $Enums.VendeurType | null
      phone: string | null
      country: string | null
      address: string | null
      shop_name: string | null
      profile_photo_url: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    passwordResets<T extends User$passwordResetsArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    validatedOrders<T extends User$validatedOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$validatedOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    designs<T extends User$designsArgs<ExtArgs> = {}>(args?: Subset<T, User$designsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    validatedDesigns<T extends User$validatedDesignsArgs<ExtArgs> = {}>(args?: Subset<T, User$validatedDesignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    validatedProducts<T extends User$validatedProductsArgs<ExtArgs> = {}>(args?: Subset<T, User$validatedProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    validatedVendorProducts<T extends User$validatedVendorProductsArgs<ExtArgs> = {}>(args?: Subset<T, User$validatedVendorProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendorProducts<T extends User$vendorProductsArgs<ExtArgs> = {}>(args?: Subset<T, User$vendorProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly status: FieldRef<"User", 'Boolean'>
    readonly photo_profil: FieldRef<"User", 'String'>
    readonly login_attempts: FieldRef<"User", 'Int'>
    readonly locked_until: FieldRef<"User", 'DateTime'>
    readonly last_login_at: FieldRef<"User", 'DateTime'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
    readonly must_change_password: FieldRef<"User", 'Boolean'>
    readonly vendeur_type: FieldRef<"User", 'VendeurType'>
    readonly phone: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly shop_name: FieldRef<"User", 'String'>
    readonly profile_photo_url: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.passwordResets
   */
  export type User$passwordResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    where?: PasswordResetWhereInput
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    cursor?: PasswordResetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.validatedOrders
   */
  export type User$validatedOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.designs
   */
  export type User$designsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Design
     */
    select?: DesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Design
     */
    omit?: DesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignInclude<ExtArgs> | null
    where?: DesignWhereInput
    orderBy?: DesignOrderByWithRelationInput | DesignOrderByWithRelationInput[]
    cursor?: DesignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DesignScalarFieldEnum | DesignScalarFieldEnum[]
  }

  /**
   * User.validatedDesigns
   */
  export type User$validatedDesignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Design
     */
    select?: DesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Design
     */
    omit?: DesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignInclude<ExtArgs> | null
    where?: DesignWhereInput
    orderBy?: DesignOrderByWithRelationInput | DesignOrderByWithRelationInput[]
    cursor?: DesignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DesignScalarFieldEnum | DesignScalarFieldEnum[]
  }

  /**
   * User.validatedProducts
   */
  export type User$validatedProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * User.validatedVendorProducts
   */
  export type User$validatedVendorProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProduct
     */
    select?: VendorProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProduct
     */
    omit?: VendorProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductInclude<ExtArgs> | null
    where?: VendorProductWhereInput
    orderBy?: VendorProductOrderByWithRelationInput | VendorProductOrderByWithRelationInput[]
    cursor?: VendorProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorProductScalarFieldEnum | VendorProductScalarFieldEnum[]
  }

  /**
   * User.vendorProducts
   */
  export type User$vendorProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProduct
     */
    select?: VendorProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProduct
     */
    omit?: VendorProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductInclude<ExtArgs> | null
    where?: VendorProductWhereInput
    orderBy?: VendorProductOrderByWithRelationInput | VendorProductOrderByWithRelationInput[]
    cursor?: VendorProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorProductScalarFieldEnum | VendorProductScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model PasswordReset
   */

  export type AggregatePasswordReset = {
    _count: PasswordResetCountAggregateOutputType | null
    _avg: PasswordResetAvgAggregateOutputType | null
    _sum: PasswordResetSumAggregateOutputType | null
    _min: PasswordResetMinAggregateOutputType | null
    _max: PasswordResetMaxAggregateOutputType | null
  }

  export type PasswordResetAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PasswordResetSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PasswordResetMinAggregateOutputType = {
    id: number | null
    token: string | null
    userId: number | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
    usedAt: Date | null
  }

  export type PasswordResetMaxAggregateOutputType = {
    id: number | null
    token: string | null
    userId: number | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
    usedAt: Date | null
  }

  export type PasswordResetCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    expiresAt: number
    used: number
    createdAt: number
    usedAt: number
    _all: number
  }


  export type PasswordResetAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PasswordResetSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PasswordResetMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    used?: true
    createdAt?: true
    usedAt?: true
  }

  export type PasswordResetMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    used?: true
    createdAt?: true
    usedAt?: true
  }

  export type PasswordResetCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    used?: true
    createdAt?: true
    usedAt?: true
    _all?: true
  }

  export type PasswordResetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordReset to aggregate.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResets
    **/
    _count?: true | PasswordResetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasswordResetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasswordResetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetMaxAggregateInputType
  }

  export type GetPasswordResetAggregateType<T extends PasswordResetAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordReset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordReset[P]>
      : GetScalarType<T[P], AggregatePasswordReset[P]>
  }




  export type PasswordResetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetWhereInput
    orderBy?: PasswordResetOrderByWithAggregationInput | PasswordResetOrderByWithAggregationInput[]
    by: PasswordResetScalarFieldEnum[] | PasswordResetScalarFieldEnum
    having?: PasswordResetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetCountAggregateInputType | true
    _avg?: PasswordResetAvgAggregateInputType
    _sum?: PasswordResetSumAggregateInputType
    _min?: PasswordResetMinAggregateInputType
    _max?: PasswordResetMaxAggregateInputType
  }

  export type PasswordResetGroupByOutputType = {
    id: number
    token: string
    userId: number
    expiresAt: Date
    used: boolean
    createdAt: Date
    usedAt: Date | null
    _count: PasswordResetCountAggregateOutputType | null
    _avg: PasswordResetAvgAggregateOutputType | null
    _sum: PasswordResetSumAggregateOutputType | null
    _min: PasswordResetMinAggregateOutputType | null
    _max: PasswordResetMaxAggregateOutputType | null
  }

  type GetPasswordResetGroupByPayload<T extends PasswordResetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    usedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    usedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    usedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    usedAt?: boolean
  }

  export type PasswordResetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "expiresAt" | "used" | "createdAt" | "usedAt", ExtArgs["result"]["passwordReset"]>
  export type PasswordResetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordReset"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: string
      userId: number
      expiresAt: Date
      used: boolean
      createdAt: Date
      usedAt: Date | null
    }, ExtArgs["result"]["passwordReset"]>
    composites: {}
  }

  type PasswordResetGetPayload<S extends boolean | null | undefined | PasswordResetDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetPayload, S>

  type PasswordResetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetCountAggregateInputType | true
    }

  export interface PasswordResetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordReset'], meta: { name: 'PasswordReset' } }
    /**
     * Find zero or one PasswordReset that matches the filter.
     * @param {PasswordResetFindUniqueArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetFindUniqueArgs>(args: SelectSubset<T, PasswordResetFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordReset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetFindUniqueOrThrowArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordReset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindFirstArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetFindFirstArgs>(args?: SelectSubset<T, PasswordResetFindFirstArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordReset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindFirstOrThrowArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResets
     * const passwordResets = await prisma.passwordReset.findMany()
     * 
     * // Get first 10 PasswordResets
     * const passwordResets = await prisma.passwordReset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetFindManyArgs>(args?: SelectSubset<T, PasswordResetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordReset.
     * @param {PasswordResetCreateArgs} args - Arguments to create a PasswordReset.
     * @example
     * // Create one PasswordReset
     * const PasswordReset = await prisma.passwordReset.create({
     *   data: {
     *     // ... data to create a PasswordReset
     *   }
     * })
     * 
     */
    create<T extends PasswordResetCreateArgs>(args: SelectSubset<T, PasswordResetCreateArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResets.
     * @param {PasswordResetCreateManyArgs} args - Arguments to create many PasswordResets.
     * @example
     * // Create many PasswordResets
     * const passwordReset = await prisma.passwordReset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetCreateManyArgs>(args?: SelectSubset<T, PasswordResetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResets and returns the data saved in the database.
     * @param {PasswordResetCreateManyAndReturnArgs} args - Arguments to create many PasswordResets.
     * @example
     * // Create many PasswordResets
     * const passwordReset = await prisma.passwordReset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResets and only return the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordReset.
     * @param {PasswordResetDeleteArgs} args - Arguments to delete one PasswordReset.
     * @example
     * // Delete one PasswordReset
     * const PasswordReset = await prisma.passwordReset.delete({
     *   where: {
     *     // ... filter to delete one PasswordReset
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetDeleteArgs>(args: SelectSubset<T, PasswordResetDeleteArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordReset.
     * @param {PasswordResetUpdateArgs} args - Arguments to update one PasswordReset.
     * @example
     * // Update one PasswordReset
     * const passwordReset = await prisma.passwordReset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetUpdateArgs>(args: SelectSubset<T, PasswordResetUpdateArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResets.
     * @param {PasswordResetDeleteManyArgs} args - Arguments to filter PasswordResets to delete.
     * @example
     * // Delete a few PasswordResets
     * const { count } = await prisma.passwordReset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetDeleteManyArgs>(args?: SelectSubset<T, PasswordResetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResets
     * const passwordReset = await prisma.passwordReset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetUpdateManyArgs>(args: SelectSubset<T, PasswordResetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResets and returns the data updated in the database.
     * @param {PasswordResetUpdateManyAndReturnArgs} args - Arguments to update many PasswordResets.
     * @example
     * // Update many PasswordResets
     * const passwordReset = await prisma.passwordReset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResets and only return the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordReset.
     * @param {PasswordResetUpsertArgs} args - Arguments to update or create a PasswordReset.
     * @example
     * // Update or create a PasswordReset
     * const passwordReset = await prisma.passwordReset.upsert({
     *   create: {
     *     // ... data to create a PasswordReset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordReset we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetUpsertArgs>(args: SelectSubset<T, PasswordResetUpsertArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetCountArgs} args - Arguments to filter PasswordResets to count.
     * @example
     * // Count the number of PasswordResets
     * const count = await prisma.passwordReset.count({
     *   where: {
     *     // ... the filter for the PasswordResets we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetCountArgs>(
      args?: Subset<T, PasswordResetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetAggregateArgs>(args: Subset<T, PasswordResetAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetAggregateType<T>>

    /**
     * Group by PasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordReset model
   */
  readonly fields: PasswordResetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordReset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordReset model
   */
  interface PasswordResetFieldRefs {
    readonly id: FieldRef<"PasswordReset", 'Int'>
    readonly token: FieldRef<"PasswordReset", 'String'>
    readonly userId: FieldRef<"PasswordReset", 'Int'>
    readonly expiresAt: FieldRef<"PasswordReset", 'DateTime'>
    readonly used: FieldRef<"PasswordReset", 'Boolean'>
    readonly createdAt: FieldRef<"PasswordReset", 'DateTime'>
    readonly usedAt: FieldRef<"PasswordReset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordReset findUnique
   */
  export type PasswordResetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset findUniqueOrThrow
   */
  export type PasswordResetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset findFirst
   */
  export type PasswordResetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResets.
     */
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset findFirstOrThrow
   */
  export type PasswordResetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResets.
     */
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset findMany
   */
  export type PasswordResetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResets to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset create
   */
  export type PasswordResetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordReset.
     */
    data: XOR<PasswordResetCreateInput, PasswordResetUncheckedCreateInput>
  }

  /**
   * PasswordReset createMany
   */
  export type PasswordResetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResets.
     */
    data: PasswordResetCreateManyInput | PasswordResetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordReset createManyAndReturn
   */
  export type PasswordResetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResets.
     */
    data: PasswordResetCreateManyInput | PasswordResetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordReset update
   */
  export type PasswordResetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordReset.
     */
    data: XOR<PasswordResetUpdateInput, PasswordResetUncheckedUpdateInput>
    /**
     * Choose, which PasswordReset to update.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset updateMany
   */
  export type PasswordResetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResets.
     */
    data: XOR<PasswordResetUpdateManyMutationInput, PasswordResetUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResets to update
     */
    where?: PasswordResetWhereInput
    /**
     * Limit how many PasswordResets to update.
     */
    limit?: number
  }

  /**
   * PasswordReset updateManyAndReturn
   */
  export type PasswordResetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResets.
     */
    data: XOR<PasswordResetUpdateManyMutationInput, PasswordResetUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResets to update
     */
    where?: PasswordResetWhereInput
    /**
     * Limit how many PasswordResets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordReset upsert
   */
  export type PasswordResetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordReset to update in case it exists.
     */
    where: PasswordResetWhereUniqueInput
    /**
     * In case the PasswordReset found by the `where` argument doesn't exist, create a new PasswordReset with this data.
     */
    create: XOR<PasswordResetCreateInput, PasswordResetUncheckedCreateInput>
    /**
     * In case the PasswordReset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetUpdateInput, PasswordResetUncheckedUpdateInput>
  }

  /**
   * PasswordReset delete
   */
  export type PasswordResetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter which PasswordReset to delete.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset deleteMany
   */
  export type PasswordResetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResets to delete
     */
    where?: PasswordResetWhereInput
    /**
     * Limit how many PasswordResets to delete.
     */
    limit?: number
  }

  /**
   * PasswordReset without action
   */
  export type PasswordResetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    price: number | null
    stock: number | null
    validatedBy: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    price: number | null
    stock: number | null
    validatedBy: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    price: number | null
    stock: number | null
    status: $Enums.PublicationStatus | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isValidated: boolean | null
    validatedAt: Date | null
    validatedBy: number | null
    rejectionReason: string | null
    submittedForValidationAt: Date | null
    hasCustomDesigns: boolean | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    price: number | null
    stock: number | null
    status: $Enums.PublicationStatus | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isValidated: boolean | null
    validatedAt: Date | null
    validatedBy: number | null
    rejectionReason: string | null
    submittedForValidationAt: Date | null
    hasCustomDesigns: boolean | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    price: number
    stock: number
    status: number
    description: number
    createdAt: number
    updatedAt: number
    isValidated: number
    validatedAt: number
    validatedBy: number
    rejectionReason: number
    submittedForValidationAt: number
    hasCustomDesigns: number
    designsMetadata: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    price?: true
    stock?: true
    validatedBy?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    price?: true
    stock?: true
    validatedBy?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    stock?: true
    status?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    isValidated?: true
    validatedAt?: true
    validatedBy?: true
    rejectionReason?: true
    submittedForValidationAt?: true
    hasCustomDesigns?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    stock?: true
    status?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    isValidated?: true
    validatedAt?: true
    validatedBy?: true
    rejectionReason?: true
    submittedForValidationAt?: true
    hasCustomDesigns?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    stock?: true
    status?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    isValidated?: true
    validatedAt?: true
    validatedBy?: true
    rejectionReason?: true
    submittedForValidationAt?: true
    hasCustomDesigns?: true
    designsMetadata?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    name: string
    price: number
    stock: number
    status: $Enums.PublicationStatus
    description: string
    createdAt: Date
    updatedAt: Date
    isValidated: boolean
    validatedAt: Date | null
    validatedBy: number | null
    rejectionReason: string | null
    submittedForValidationAt: Date | null
    hasCustomDesigns: boolean
    designsMetadata: JsonValue | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    stock?: boolean
    status?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isValidated?: boolean
    validatedAt?: boolean
    validatedBy?: boolean
    rejectionReason?: boolean
    submittedForValidationAt?: boolean
    hasCustomDesigns?: boolean
    designsMetadata?: boolean
    validator?: boolean | Product$validatorArgs<ExtArgs>
    categories?: boolean | Product$categoriesArgs<ExtArgs>
    sizes?: boolean | Product$sizesArgs<ExtArgs>
    colorVariations?: boolean | Product$colorVariationsArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    vendorProducts?: boolean | Product$vendorProductsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    stock?: boolean
    status?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isValidated?: boolean
    validatedAt?: boolean
    validatedBy?: boolean
    rejectionReason?: boolean
    submittedForValidationAt?: boolean
    hasCustomDesigns?: boolean
    designsMetadata?: boolean
    validator?: boolean | Product$validatorArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    stock?: boolean
    status?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isValidated?: boolean
    validatedAt?: boolean
    validatedBy?: boolean
    rejectionReason?: boolean
    submittedForValidationAt?: boolean
    hasCustomDesigns?: boolean
    designsMetadata?: boolean
    validator?: boolean | Product$validatorArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    stock?: boolean
    status?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isValidated?: boolean
    validatedAt?: boolean
    validatedBy?: boolean
    rejectionReason?: boolean
    submittedForValidationAt?: boolean
    hasCustomDesigns?: boolean
    designsMetadata?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "price" | "stock" | "status" | "description" | "createdAt" | "updatedAt" | "isValidated" | "validatedAt" | "validatedBy" | "rejectionReason" | "submittedForValidationAt" | "hasCustomDesigns" | "designsMetadata", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    validator?: boolean | Product$validatorArgs<ExtArgs>
    categories?: boolean | Product$categoriesArgs<ExtArgs>
    sizes?: boolean | Product$sizesArgs<ExtArgs>
    colorVariations?: boolean | Product$colorVariationsArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    vendorProducts?: boolean | Product$vendorProductsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    validator?: boolean | Product$validatorArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    validator?: boolean | Product$validatorArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      validator: Prisma.$UserPayload<ExtArgs> | null
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      sizes: Prisma.$ProductSizePayload<ExtArgs>[]
      colorVariations: Prisma.$ColorVariationPayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      vendorProducts: Prisma.$VendorProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      price: number
      stock: number
      status: $Enums.PublicationStatus
      description: string
      createdAt: Date
      updatedAt: Date
      isValidated: boolean
      validatedAt: Date | null
      validatedBy: number | null
      rejectionReason: string | null
      submittedForValidationAt: Date | null
      hasCustomDesigns: boolean
      designsMetadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    validator<T extends Product$validatorArgs<ExtArgs> = {}>(args?: Subset<T, Product$validatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    categories<T extends Product$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Product$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sizes<T extends Product$sizesArgs<ExtArgs> = {}>(args?: Subset<T, Product$sizesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    colorVariations<T extends Product$colorVariationsArgs<ExtArgs> = {}>(args?: Subset<T, Product$colorVariationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColorVariationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendorProducts<T extends Product$vendorProductsArgs<ExtArgs> = {}>(args?: Subset<T, Product$vendorProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly name: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Float'>
    readonly stock: FieldRef<"Product", 'Int'>
    readonly status: FieldRef<"Product", 'PublicationStatus'>
    readonly description: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly isValidated: FieldRef<"Product", 'Boolean'>
    readonly validatedAt: FieldRef<"Product", 'DateTime'>
    readonly validatedBy: FieldRef<"Product", 'Int'>
    readonly rejectionReason: FieldRef<"Product", 'String'>
    readonly submittedForValidationAt: FieldRef<"Product", 'DateTime'>
    readonly hasCustomDesigns: FieldRef<"Product", 'Boolean'>
    readonly designsMetadata: FieldRef<"Product", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.validator
   */
  export type Product$validatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Product.categories
   */
  export type Product$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Product.sizes
   */
  export type Product$sizesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    where?: ProductSizeWhereInput
    orderBy?: ProductSizeOrderByWithRelationInput | ProductSizeOrderByWithRelationInput[]
    cursor?: ProductSizeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductSizeScalarFieldEnum | ProductSizeScalarFieldEnum[]
  }

  /**
   * Product.colorVariations
   */
  export type Product$colorVariationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorVariation
     */
    select?: ColorVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorVariation
     */
    omit?: ColorVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorVariationInclude<ExtArgs> | null
    where?: ColorVariationWhereInput
    orderBy?: ColorVariationOrderByWithRelationInput | ColorVariationOrderByWithRelationInput[]
    cursor?: ColorVariationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ColorVariationScalarFieldEnum | ColorVariationScalarFieldEnum[]
  }

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product.vendorProducts
   */
  export type Product$vendorProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProduct
     */
    select?: VendorProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProduct
     */
    omit?: VendorProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductInclude<ExtArgs> | null
    where?: VendorProductWhereInput
    orderBy?: VendorProductOrderByWithRelationInput | VendorProductOrderByWithRelationInput[]
    cursor?: VendorProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorProductScalarFieldEnum | VendorProductScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductSize
   */

  export type AggregateProductSize = {
    _count: ProductSizeCountAggregateOutputType | null
    _avg: ProductSizeAvgAggregateOutputType | null
    _sum: ProductSizeSumAggregateOutputType | null
    _min: ProductSizeMinAggregateOutputType | null
    _max: ProductSizeMaxAggregateOutputType | null
  }

  export type ProductSizeAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProductSizeSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProductSizeMinAggregateOutputType = {
    id: number | null
    productId: number | null
    sizeName: string | null
  }

  export type ProductSizeMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    sizeName: string | null
  }

  export type ProductSizeCountAggregateOutputType = {
    id: number
    productId: number
    sizeName: number
    _all: number
  }


  export type ProductSizeAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProductSizeSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProductSizeMinAggregateInputType = {
    id?: true
    productId?: true
    sizeName?: true
  }

  export type ProductSizeMaxAggregateInputType = {
    id?: true
    productId?: true
    sizeName?: true
  }

  export type ProductSizeCountAggregateInputType = {
    id?: true
    productId?: true
    sizeName?: true
    _all?: true
  }

  export type ProductSizeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductSize to aggregate.
     */
    where?: ProductSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSizes to fetch.
     */
    orderBy?: ProductSizeOrderByWithRelationInput | ProductSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductSizes
    **/
    _count?: true | ProductSizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductSizeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSizeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductSizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductSizeMaxAggregateInputType
  }

  export type GetProductSizeAggregateType<T extends ProductSizeAggregateArgs> = {
        [P in keyof T & keyof AggregateProductSize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductSize[P]>
      : GetScalarType<T[P], AggregateProductSize[P]>
  }




  export type ProductSizeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductSizeWhereInput
    orderBy?: ProductSizeOrderByWithAggregationInput | ProductSizeOrderByWithAggregationInput[]
    by: ProductSizeScalarFieldEnum[] | ProductSizeScalarFieldEnum
    having?: ProductSizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductSizeCountAggregateInputType | true
    _avg?: ProductSizeAvgAggregateInputType
    _sum?: ProductSizeSumAggregateInputType
    _min?: ProductSizeMinAggregateInputType
    _max?: ProductSizeMaxAggregateInputType
  }

  export type ProductSizeGroupByOutputType = {
    id: number
    productId: number
    sizeName: string
    _count: ProductSizeCountAggregateOutputType | null
    _avg: ProductSizeAvgAggregateOutputType | null
    _sum: ProductSizeSumAggregateOutputType | null
    _min: ProductSizeMinAggregateOutputType | null
    _max: ProductSizeMaxAggregateOutputType | null
  }

  type GetProductSizeGroupByPayload<T extends ProductSizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductSizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductSizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductSizeGroupByOutputType[P]>
            : GetScalarType<T[P], ProductSizeGroupByOutputType[P]>
        }
      >
    >


  export type ProductSizeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    sizeName?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productSize"]>

  export type ProductSizeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    sizeName?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productSize"]>

  export type ProductSizeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    sizeName?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productSize"]>

  export type ProductSizeSelectScalar = {
    id?: boolean
    productId?: boolean
    sizeName?: boolean
  }

  export type ProductSizeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "sizeName", ExtArgs["result"]["productSize"]>
  export type ProductSizeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductSizeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductSizeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductSizePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductSize"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      sizeName: string
    }, ExtArgs["result"]["productSize"]>
    composites: {}
  }

  type ProductSizeGetPayload<S extends boolean | null | undefined | ProductSizeDefaultArgs> = $Result.GetResult<Prisma.$ProductSizePayload, S>

  type ProductSizeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductSizeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductSizeCountAggregateInputType | true
    }

  export interface ProductSizeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductSize'], meta: { name: 'ProductSize' } }
    /**
     * Find zero or one ProductSize that matches the filter.
     * @param {ProductSizeFindUniqueArgs} args - Arguments to find a ProductSize
     * @example
     * // Get one ProductSize
     * const productSize = await prisma.productSize.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductSizeFindUniqueArgs>(args: SelectSubset<T, ProductSizeFindUniqueArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductSize that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductSizeFindUniqueOrThrowArgs} args - Arguments to find a ProductSize
     * @example
     * // Get one ProductSize
     * const productSize = await prisma.productSize.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductSizeFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductSizeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductSize that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeFindFirstArgs} args - Arguments to find a ProductSize
     * @example
     * // Get one ProductSize
     * const productSize = await prisma.productSize.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductSizeFindFirstArgs>(args?: SelectSubset<T, ProductSizeFindFirstArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductSize that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeFindFirstOrThrowArgs} args - Arguments to find a ProductSize
     * @example
     * // Get one ProductSize
     * const productSize = await prisma.productSize.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductSizeFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductSizeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductSizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductSizes
     * const productSizes = await prisma.productSize.findMany()
     * 
     * // Get first 10 ProductSizes
     * const productSizes = await prisma.productSize.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productSizeWithIdOnly = await prisma.productSize.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductSizeFindManyArgs>(args?: SelectSubset<T, ProductSizeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductSize.
     * @param {ProductSizeCreateArgs} args - Arguments to create a ProductSize.
     * @example
     * // Create one ProductSize
     * const ProductSize = await prisma.productSize.create({
     *   data: {
     *     // ... data to create a ProductSize
     *   }
     * })
     * 
     */
    create<T extends ProductSizeCreateArgs>(args: SelectSubset<T, ProductSizeCreateArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductSizes.
     * @param {ProductSizeCreateManyArgs} args - Arguments to create many ProductSizes.
     * @example
     * // Create many ProductSizes
     * const productSize = await prisma.productSize.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductSizeCreateManyArgs>(args?: SelectSubset<T, ProductSizeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductSizes and returns the data saved in the database.
     * @param {ProductSizeCreateManyAndReturnArgs} args - Arguments to create many ProductSizes.
     * @example
     * // Create many ProductSizes
     * const productSize = await prisma.productSize.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductSizes and only return the `id`
     * const productSizeWithIdOnly = await prisma.productSize.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductSizeCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductSizeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductSize.
     * @param {ProductSizeDeleteArgs} args - Arguments to delete one ProductSize.
     * @example
     * // Delete one ProductSize
     * const ProductSize = await prisma.productSize.delete({
     *   where: {
     *     // ... filter to delete one ProductSize
     *   }
     * })
     * 
     */
    delete<T extends ProductSizeDeleteArgs>(args: SelectSubset<T, ProductSizeDeleteArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductSize.
     * @param {ProductSizeUpdateArgs} args - Arguments to update one ProductSize.
     * @example
     * // Update one ProductSize
     * const productSize = await prisma.productSize.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductSizeUpdateArgs>(args: SelectSubset<T, ProductSizeUpdateArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductSizes.
     * @param {ProductSizeDeleteManyArgs} args - Arguments to filter ProductSizes to delete.
     * @example
     * // Delete a few ProductSizes
     * const { count } = await prisma.productSize.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductSizeDeleteManyArgs>(args?: SelectSubset<T, ProductSizeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductSizes
     * const productSize = await prisma.productSize.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductSizeUpdateManyArgs>(args: SelectSubset<T, ProductSizeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductSizes and returns the data updated in the database.
     * @param {ProductSizeUpdateManyAndReturnArgs} args - Arguments to update many ProductSizes.
     * @example
     * // Update many ProductSizes
     * const productSize = await prisma.productSize.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductSizes and only return the `id`
     * const productSizeWithIdOnly = await prisma.productSize.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductSizeUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductSizeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductSize.
     * @param {ProductSizeUpsertArgs} args - Arguments to update or create a ProductSize.
     * @example
     * // Update or create a ProductSize
     * const productSize = await prisma.productSize.upsert({
     *   create: {
     *     // ... data to create a ProductSize
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductSize we want to update
     *   }
     * })
     */
    upsert<T extends ProductSizeUpsertArgs>(args: SelectSubset<T, ProductSizeUpsertArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeCountArgs} args - Arguments to filter ProductSizes to count.
     * @example
     * // Count the number of ProductSizes
     * const count = await prisma.productSize.count({
     *   where: {
     *     // ... the filter for the ProductSizes we want to count
     *   }
     * })
    **/
    count<T extends ProductSizeCountArgs>(
      args?: Subset<T, ProductSizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductSizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductSizeAggregateArgs>(args: Subset<T, ProductSizeAggregateArgs>): Prisma.PrismaPromise<GetProductSizeAggregateType<T>>

    /**
     * Group by ProductSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductSizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductSizeGroupByArgs['orderBy'] }
        : { orderBy?: ProductSizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductSizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductSizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductSize model
   */
  readonly fields: ProductSizeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductSize.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductSizeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductSize model
   */
  interface ProductSizeFieldRefs {
    readonly id: FieldRef<"ProductSize", 'Int'>
    readonly productId: FieldRef<"ProductSize", 'Int'>
    readonly sizeName: FieldRef<"ProductSize", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductSize findUnique
   */
  export type ProductSizeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductSize to fetch.
     */
    where: ProductSizeWhereUniqueInput
  }

  /**
   * ProductSize findUniqueOrThrow
   */
  export type ProductSizeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductSize to fetch.
     */
    where: ProductSizeWhereUniqueInput
  }

  /**
   * ProductSize findFirst
   */
  export type ProductSizeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductSize to fetch.
     */
    where?: ProductSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSizes to fetch.
     */
    orderBy?: ProductSizeOrderByWithRelationInput | ProductSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductSizes.
     */
    cursor?: ProductSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductSizes.
     */
    distinct?: ProductSizeScalarFieldEnum | ProductSizeScalarFieldEnum[]
  }

  /**
   * ProductSize findFirstOrThrow
   */
  export type ProductSizeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductSize to fetch.
     */
    where?: ProductSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSizes to fetch.
     */
    orderBy?: ProductSizeOrderByWithRelationInput | ProductSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductSizes.
     */
    cursor?: ProductSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductSizes.
     */
    distinct?: ProductSizeScalarFieldEnum | ProductSizeScalarFieldEnum[]
  }

  /**
   * ProductSize findMany
   */
  export type ProductSizeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductSizes to fetch.
     */
    where?: ProductSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSizes to fetch.
     */
    orderBy?: ProductSizeOrderByWithRelationInput | ProductSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductSizes.
     */
    cursor?: ProductSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSizes.
     */
    skip?: number
    distinct?: ProductSizeScalarFieldEnum | ProductSizeScalarFieldEnum[]
  }

  /**
   * ProductSize create
   */
  export type ProductSizeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductSize.
     */
    data: XOR<ProductSizeCreateInput, ProductSizeUncheckedCreateInput>
  }

  /**
   * ProductSize createMany
   */
  export type ProductSizeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductSizes.
     */
    data: ProductSizeCreateManyInput | ProductSizeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductSize createManyAndReturn
   */
  export type ProductSizeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * The data used to create many ProductSizes.
     */
    data: ProductSizeCreateManyInput | ProductSizeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductSize update
   */
  export type ProductSizeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductSize.
     */
    data: XOR<ProductSizeUpdateInput, ProductSizeUncheckedUpdateInput>
    /**
     * Choose, which ProductSize to update.
     */
    where: ProductSizeWhereUniqueInput
  }

  /**
   * ProductSize updateMany
   */
  export type ProductSizeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductSizes.
     */
    data: XOR<ProductSizeUpdateManyMutationInput, ProductSizeUncheckedUpdateManyInput>
    /**
     * Filter which ProductSizes to update
     */
    where?: ProductSizeWhereInput
    /**
     * Limit how many ProductSizes to update.
     */
    limit?: number
  }

  /**
   * ProductSize updateManyAndReturn
   */
  export type ProductSizeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * The data used to update ProductSizes.
     */
    data: XOR<ProductSizeUpdateManyMutationInput, ProductSizeUncheckedUpdateManyInput>
    /**
     * Filter which ProductSizes to update
     */
    where?: ProductSizeWhereInput
    /**
     * Limit how many ProductSizes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductSize upsert
   */
  export type ProductSizeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductSize to update in case it exists.
     */
    where: ProductSizeWhereUniqueInput
    /**
     * In case the ProductSize found by the `where` argument doesn't exist, create a new ProductSize with this data.
     */
    create: XOR<ProductSizeCreateInput, ProductSizeUncheckedCreateInput>
    /**
     * In case the ProductSize was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductSizeUpdateInput, ProductSizeUncheckedUpdateInput>
  }

  /**
   * ProductSize delete
   */
  export type ProductSizeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter which ProductSize to delete.
     */
    where: ProductSizeWhereUniqueInput
  }

  /**
   * ProductSize deleteMany
   */
  export type ProductSizeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductSizes to delete
     */
    where?: ProductSizeWhereInput
    /**
     * Limit how many ProductSizes to delete.
     */
    limit?: number
  }

  /**
   * ProductSize without action
   */
  export type ProductSizeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    name: string
    description: string | null
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly name: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model ColorVariation
   */

  export type AggregateColorVariation = {
    _count: ColorVariationCountAggregateOutputType | null
    _avg: ColorVariationAvgAggregateOutputType | null
    _sum: ColorVariationSumAggregateOutputType | null
    _min: ColorVariationMinAggregateOutputType | null
    _max: ColorVariationMaxAggregateOutputType | null
  }

  export type ColorVariationAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ColorVariationSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ColorVariationMinAggregateOutputType = {
    id: number | null
    name: string | null
    colorCode: string | null
    productId: number | null
  }

  export type ColorVariationMaxAggregateOutputType = {
    id: number | null
    name: string | null
    colorCode: string | null
    productId: number | null
  }

  export type ColorVariationCountAggregateOutputType = {
    id: number
    name: number
    colorCode: number
    productId: number
    _all: number
  }


  export type ColorVariationAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ColorVariationSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ColorVariationMinAggregateInputType = {
    id?: true
    name?: true
    colorCode?: true
    productId?: true
  }

  export type ColorVariationMaxAggregateInputType = {
    id?: true
    name?: true
    colorCode?: true
    productId?: true
  }

  export type ColorVariationCountAggregateInputType = {
    id?: true
    name?: true
    colorCode?: true
    productId?: true
    _all?: true
  }

  export type ColorVariationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ColorVariation to aggregate.
     */
    where?: ColorVariationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ColorVariations to fetch.
     */
    orderBy?: ColorVariationOrderByWithRelationInput | ColorVariationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ColorVariationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ColorVariations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ColorVariations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ColorVariations
    **/
    _count?: true | ColorVariationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ColorVariationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ColorVariationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ColorVariationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ColorVariationMaxAggregateInputType
  }

  export type GetColorVariationAggregateType<T extends ColorVariationAggregateArgs> = {
        [P in keyof T & keyof AggregateColorVariation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateColorVariation[P]>
      : GetScalarType<T[P], AggregateColorVariation[P]>
  }




  export type ColorVariationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ColorVariationWhereInput
    orderBy?: ColorVariationOrderByWithAggregationInput | ColorVariationOrderByWithAggregationInput[]
    by: ColorVariationScalarFieldEnum[] | ColorVariationScalarFieldEnum
    having?: ColorVariationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ColorVariationCountAggregateInputType | true
    _avg?: ColorVariationAvgAggregateInputType
    _sum?: ColorVariationSumAggregateInputType
    _min?: ColorVariationMinAggregateInputType
    _max?: ColorVariationMaxAggregateInputType
  }

  export type ColorVariationGroupByOutputType = {
    id: number
    name: string
    colorCode: string
    productId: number
    _count: ColorVariationCountAggregateOutputType | null
    _avg: ColorVariationAvgAggregateOutputType | null
    _sum: ColorVariationSumAggregateOutputType | null
    _min: ColorVariationMinAggregateOutputType | null
    _max: ColorVariationMaxAggregateOutputType | null
  }

  type GetColorVariationGroupByPayload<T extends ColorVariationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ColorVariationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ColorVariationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ColorVariationGroupByOutputType[P]>
            : GetScalarType<T[P], ColorVariationGroupByOutputType[P]>
        }
      >
    >


  export type ColorVariationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    colorCode?: boolean
    productId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    images?: boolean | ColorVariation$imagesArgs<ExtArgs>
    orderItems?: boolean | ColorVariation$orderItemsArgs<ExtArgs>
    vendorProductImages?: boolean | ColorVariation$vendorProductImagesArgs<ExtArgs>
    _count?: boolean | ColorVariationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["colorVariation"]>

  export type ColorVariationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    colorCode?: boolean
    productId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["colorVariation"]>

  export type ColorVariationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    colorCode?: boolean
    productId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["colorVariation"]>

  export type ColorVariationSelectScalar = {
    id?: boolean
    name?: boolean
    colorCode?: boolean
    productId?: boolean
  }

  export type ColorVariationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "colorCode" | "productId", ExtArgs["result"]["colorVariation"]>
  export type ColorVariationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    images?: boolean | ColorVariation$imagesArgs<ExtArgs>
    orderItems?: boolean | ColorVariation$orderItemsArgs<ExtArgs>
    vendorProductImages?: boolean | ColorVariation$vendorProductImagesArgs<ExtArgs>
    _count?: boolean | ColorVariationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ColorVariationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ColorVariationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ColorVariationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ColorVariation"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      images: Prisma.$ProductImagePayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      vendorProductImages: Prisma.$VendorProductImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      colorCode: string
      productId: number
    }, ExtArgs["result"]["colorVariation"]>
    composites: {}
  }

  type ColorVariationGetPayload<S extends boolean | null | undefined | ColorVariationDefaultArgs> = $Result.GetResult<Prisma.$ColorVariationPayload, S>

  type ColorVariationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ColorVariationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ColorVariationCountAggregateInputType | true
    }

  export interface ColorVariationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ColorVariation'], meta: { name: 'ColorVariation' } }
    /**
     * Find zero or one ColorVariation that matches the filter.
     * @param {ColorVariationFindUniqueArgs} args - Arguments to find a ColorVariation
     * @example
     * // Get one ColorVariation
     * const colorVariation = await prisma.colorVariation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ColorVariationFindUniqueArgs>(args: SelectSubset<T, ColorVariationFindUniqueArgs<ExtArgs>>): Prisma__ColorVariationClient<$Result.GetResult<Prisma.$ColorVariationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ColorVariation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ColorVariationFindUniqueOrThrowArgs} args - Arguments to find a ColorVariation
     * @example
     * // Get one ColorVariation
     * const colorVariation = await prisma.colorVariation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ColorVariationFindUniqueOrThrowArgs>(args: SelectSubset<T, ColorVariationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ColorVariationClient<$Result.GetResult<Prisma.$ColorVariationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ColorVariation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorVariationFindFirstArgs} args - Arguments to find a ColorVariation
     * @example
     * // Get one ColorVariation
     * const colorVariation = await prisma.colorVariation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ColorVariationFindFirstArgs>(args?: SelectSubset<T, ColorVariationFindFirstArgs<ExtArgs>>): Prisma__ColorVariationClient<$Result.GetResult<Prisma.$ColorVariationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ColorVariation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorVariationFindFirstOrThrowArgs} args - Arguments to find a ColorVariation
     * @example
     * // Get one ColorVariation
     * const colorVariation = await prisma.colorVariation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ColorVariationFindFirstOrThrowArgs>(args?: SelectSubset<T, ColorVariationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ColorVariationClient<$Result.GetResult<Prisma.$ColorVariationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ColorVariations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorVariationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ColorVariations
     * const colorVariations = await prisma.colorVariation.findMany()
     * 
     * // Get first 10 ColorVariations
     * const colorVariations = await prisma.colorVariation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const colorVariationWithIdOnly = await prisma.colorVariation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ColorVariationFindManyArgs>(args?: SelectSubset<T, ColorVariationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColorVariationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ColorVariation.
     * @param {ColorVariationCreateArgs} args - Arguments to create a ColorVariation.
     * @example
     * // Create one ColorVariation
     * const ColorVariation = await prisma.colorVariation.create({
     *   data: {
     *     // ... data to create a ColorVariation
     *   }
     * })
     * 
     */
    create<T extends ColorVariationCreateArgs>(args: SelectSubset<T, ColorVariationCreateArgs<ExtArgs>>): Prisma__ColorVariationClient<$Result.GetResult<Prisma.$ColorVariationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ColorVariations.
     * @param {ColorVariationCreateManyArgs} args - Arguments to create many ColorVariations.
     * @example
     * // Create many ColorVariations
     * const colorVariation = await prisma.colorVariation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ColorVariationCreateManyArgs>(args?: SelectSubset<T, ColorVariationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ColorVariations and returns the data saved in the database.
     * @param {ColorVariationCreateManyAndReturnArgs} args - Arguments to create many ColorVariations.
     * @example
     * // Create many ColorVariations
     * const colorVariation = await prisma.colorVariation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ColorVariations and only return the `id`
     * const colorVariationWithIdOnly = await prisma.colorVariation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ColorVariationCreateManyAndReturnArgs>(args?: SelectSubset<T, ColorVariationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColorVariationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ColorVariation.
     * @param {ColorVariationDeleteArgs} args - Arguments to delete one ColorVariation.
     * @example
     * // Delete one ColorVariation
     * const ColorVariation = await prisma.colorVariation.delete({
     *   where: {
     *     // ... filter to delete one ColorVariation
     *   }
     * })
     * 
     */
    delete<T extends ColorVariationDeleteArgs>(args: SelectSubset<T, ColorVariationDeleteArgs<ExtArgs>>): Prisma__ColorVariationClient<$Result.GetResult<Prisma.$ColorVariationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ColorVariation.
     * @param {ColorVariationUpdateArgs} args - Arguments to update one ColorVariation.
     * @example
     * // Update one ColorVariation
     * const colorVariation = await prisma.colorVariation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ColorVariationUpdateArgs>(args: SelectSubset<T, ColorVariationUpdateArgs<ExtArgs>>): Prisma__ColorVariationClient<$Result.GetResult<Prisma.$ColorVariationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ColorVariations.
     * @param {ColorVariationDeleteManyArgs} args - Arguments to filter ColorVariations to delete.
     * @example
     * // Delete a few ColorVariations
     * const { count } = await prisma.colorVariation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ColorVariationDeleteManyArgs>(args?: SelectSubset<T, ColorVariationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ColorVariations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorVariationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ColorVariations
     * const colorVariation = await prisma.colorVariation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ColorVariationUpdateManyArgs>(args: SelectSubset<T, ColorVariationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ColorVariations and returns the data updated in the database.
     * @param {ColorVariationUpdateManyAndReturnArgs} args - Arguments to update many ColorVariations.
     * @example
     * // Update many ColorVariations
     * const colorVariation = await prisma.colorVariation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ColorVariations and only return the `id`
     * const colorVariationWithIdOnly = await prisma.colorVariation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ColorVariationUpdateManyAndReturnArgs>(args: SelectSubset<T, ColorVariationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColorVariationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ColorVariation.
     * @param {ColorVariationUpsertArgs} args - Arguments to update or create a ColorVariation.
     * @example
     * // Update or create a ColorVariation
     * const colorVariation = await prisma.colorVariation.upsert({
     *   create: {
     *     // ... data to create a ColorVariation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ColorVariation we want to update
     *   }
     * })
     */
    upsert<T extends ColorVariationUpsertArgs>(args: SelectSubset<T, ColorVariationUpsertArgs<ExtArgs>>): Prisma__ColorVariationClient<$Result.GetResult<Prisma.$ColorVariationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ColorVariations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorVariationCountArgs} args - Arguments to filter ColorVariations to count.
     * @example
     * // Count the number of ColorVariations
     * const count = await prisma.colorVariation.count({
     *   where: {
     *     // ... the filter for the ColorVariations we want to count
     *   }
     * })
    **/
    count<T extends ColorVariationCountArgs>(
      args?: Subset<T, ColorVariationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ColorVariationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ColorVariation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorVariationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ColorVariationAggregateArgs>(args: Subset<T, ColorVariationAggregateArgs>): Prisma.PrismaPromise<GetColorVariationAggregateType<T>>

    /**
     * Group by ColorVariation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorVariationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ColorVariationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ColorVariationGroupByArgs['orderBy'] }
        : { orderBy?: ColorVariationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ColorVariationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetColorVariationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ColorVariation model
   */
  readonly fields: ColorVariationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ColorVariation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ColorVariationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    images<T extends ColorVariation$imagesArgs<ExtArgs> = {}>(args?: Subset<T, ColorVariation$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderItems<T extends ColorVariation$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, ColorVariation$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendorProductImages<T extends ColorVariation$vendorProductImagesArgs<ExtArgs> = {}>(args?: Subset<T, ColorVariation$vendorProductImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorProductImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ColorVariation model
   */
  interface ColorVariationFieldRefs {
    readonly id: FieldRef<"ColorVariation", 'Int'>
    readonly name: FieldRef<"ColorVariation", 'String'>
    readonly colorCode: FieldRef<"ColorVariation", 'String'>
    readonly productId: FieldRef<"ColorVariation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ColorVariation findUnique
   */
  export type ColorVariationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorVariation
     */
    select?: ColorVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorVariation
     */
    omit?: ColorVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorVariationInclude<ExtArgs> | null
    /**
     * Filter, which ColorVariation to fetch.
     */
    where: ColorVariationWhereUniqueInput
  }

  /**
   * ColorVariation findUniqueOrThrow
   */
  export type ColorVariationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorVariation
     */
    select?: ColorVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorVariation
     */
    omit?: ColorVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorVariationInclude<ExtArgs> | null
    /**
     * Filter, which ColorVariation to fetch.
     */
    where: ColorVariationWhereUniqueInput
  }

  /**
   * ColorVariation findFirst
   */
  export type ColorVariationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorVariation
     */
    select?: ColorVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorVariation
     */
    omit?: ColorVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorVariationInclude<ExtArgs> | null
    /**
     * Filter, which ColorVariation to fetch.
     */
    where?: ColorVariationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ColorVariations to fetch.
     */
    orderBy?: ColorVariationOrderByWithRelationInput | ColorVariationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ColorVariations.
     */
    cursor?: ColorVariationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ColorVariations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ColorVariations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ColorVariations.
     */
    distinct?: ColorVariationScalarFieldEnum | ColorVariationScalarFieldEnum[]
  }

  /**
   * ColorVariation findFirstOrThrow
   */
  export type ColorVariationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorVariation
     */
    select?: ColorVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorVariation
     */
    omit?: ColorVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorVariationInclude<ExtArgs> | null
    /**
     * Filter, which ColorVariation to fetch.
     */
    where?: ColorVariationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ColorVariations to fetch.
     */
    orderBy?: ColorVariationOrderByWithRelationInput | ColorVariationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ColorVariations.
     */
    cursor?: ColorVariationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ColorVariations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ColorVariations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ColorVariations.
     */
    distinct?: ColorVariationScalarFieldEnum | ColorVariationScalarFieldEnum[]
  }

  /**
   * ColorVariation findMany
   */
  export type ColorVariationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorVariation
     */
    select?: ColorVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorVariation
     */
    omit?: ColorVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorVariationInclude<ExtArgs> | null
    /**
     * Filter, which ColorVariations to fetch.
     */
    where?: ColorVariationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ColorVariations to fetch.
     */
    orderBy?: ColorVariationOrderByWithRelationInput | ColorVariationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ColorVariations.
     */
    cursor?: ColorVariationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ColorVariations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ColorVariations.
     */
    skip?: number
    distinct?: ColorVariationScalarFieldEnum | ColorVariationScalarFieldEnum[]
  }

  /**
   * ColorVariation create
   */
  export type ColorVariationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorVariation
     */
    select?: ColorVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorVariation
     */
    omit?: ColorVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorVariationInclude<ExtArgs> | null
    /**
     * The data needed to create a ColorVariation.
     */
    data: XOR<ColorVariationCreateInput, ColorVariationUncheckedCreateInput>
  }

  /**
   * ColorVariation createMany
   */
  export type ColorVariationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ColorVariations.
     */
    data: ColorVariationCreateManyInput | ColorVariationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ColorVariation createManyAndReturn
   */
  export type ColorVariationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorVariation
     */
    select?: ColorVariationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ColorVariation
     */
    omit?: ColorVariationOmit<ExtArgs> | null
    /**
     * The data used to create many ColorVariations.
     */
    data: ColorVariationCreateManyInput | ColorVariationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorVariationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ColorVariation update
   */
  export type ColorVariationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorVariation
     */
    select?: ColorVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorVariation
     */
    omit?: ColorVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorVariationInclude<ExtArgs> | null
    /**
     * The data needed to update a ColorVariation.
     */
    data: XOR<ColorVariationUpdateInput, ColorVariationUncheckedUpdateInput>
    /**
     * Choose, which ColorVariation to update.
     */
    where: ColorVariationWhereUniqueInput
  }

  /**
   * ColorVariation updateMany
   */
  export type ColorVariationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ColorVariations.
     */
    data: XOR<ColorVariationUpdateManyMutationInput, ColorVariationUncheckedUpdateManyInput>
    /**
     * Filter which ColorVariations to update
     */
    where?: ColorVariationWhereInput
    /**
     * Limit how many ColorVariations to update.
     */
    limit?: number
  }

  /**
   * ColorVariation updateManyAndReturn
   */
  export type ColorVariationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorVariation
     */
    select?: ColorVariationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ColorVariation
     */
    omit?: ColorVariationOmit<ExtArgs> | null
    /**
     * The data used to update ColorVariations.
     */
    data: XOR<ColorVariationUpdateManyMutationInput, ColorVariationUncheckedUpdateManyInput>
    /**
     * Filter which ColorVariations to update
     */
    where?: ColorVariationWhereInput
    /**
     * Limit how many ColorVariations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorVariationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ColorVariation upsert
   */
  export type ColorVariationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorVariation
     */
    select?: ColorVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorVariation
     */
    omit?: ColorVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorVariationInclude<ExtArgs> | null
    /**
     * The filter to search for the ColorVariation to update in case it exists.
     */
    where: ColorVariationWhereUniqueInput
    /**
     * In case the ColorVariation found by the `where` argument doesn't exist, create a new ColorVariation with this data.
     */
    create: XOR<ColorVariationCreateInput, ColorVariationUncheckedCreateInput>
    /**
     * In case the ColorVariation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ColorVariationUpdateInput, ColorVariationUncheckedUpdateInput>
  }

  /**
   * ColorVariation delete
   */
  export type ColorVariationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorVariation
     */
    select?: ColorVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorVariation
     */
    omit?: ColorVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorVariationInclude<ExtArgs> | null
    /**
     * Filter which ColorVariation to delete.
     */
    where: ColorVariationWhereUniqueInput
  }

  /**
   * ColorVariation deleteMany
   */
  export type ColorVariationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ColorVariations to delete
     */
    where?: ColorVariationWhereInput
    /**
     * Limit how many ColorVariations to delete.
     */
    limit?: number
  }

  /**
   * ColorVariation.images
   */
  export type ColorVariation$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    where?: ProductImageWhereInput
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    cursor?: ProductImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ColorVariation.orderItems
   */
  export type ColorVariation$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * ColorVariation.vendorProductImages
   */
  export type ColorVariation$vendorProductImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProductImage
     */
    select?: VendorProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProductImage
     */
    omit?: VendorProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductImageInclude<ExtArgs> | null
    where?: VendorProductImageWhereInput
    orderBy?: VendorProductImageOrderByWithRelationInput | VendorProductImageOrderByWithRelationInput[]
    cursor?: VendorProductImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorProductImageScalarFieldEnum | VendorProductImageScalarFieldEnum[]
  }

  /**
   * ColorVariation without action
   */
  export type ColorVariationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorVariation
     */
    select?: ColorVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorVariation
     */
    omit?: ColorVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorVariationInclude<ExtArgs> | null
  }


  /**
   * Model ProductImage
   */

  export type AggregateProductImage = {
    _count: ProductImageCountAggregateOutputType | null
    _avg: ProductImageAvgAggregateOutputType | null
    _sum: ProductImageSumAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  export type ProductImageAvgAggregateOutputType = {
    id: number | null
    naturalWidth: number | null
    naturalHeight: number | null
    designSize: number | null
    colorVariationId: number | null
  }

  export type ProductImageSumAggregateOutputType = {
    id: number | null
    naturalWidth: number | null
    naturalHeight: number | null
    designSize: number | null
    colorVariationId: number | null
  }

  export type ProductImageMinAggregateOutputType = {
    id: number | null
    view: string | null
    url: string | null
    publicId: string | null
    naturalWidth: number | null
    naturalHeight: number | null
    designUrl: string | null
    designPublicId: string | null
    designFileName: string | null
    designUploadDate: Date | null
    designSize: number | null
    designOriginalName: string | null
    designDescription: string | null
    isDesignActive: boolean | null
    colorVariationId: number | null
  }

  export type ProductImageMaxAggregateOutputType = {
    id: number | null
    view: string | null
    url: string | null
    publicId: string | null
    naturalWidth: number | null
    naturalHeight: number | null
    designUrl: string | null
    designPublicId: string | null
    designFileName: string | null
    designUploadDate: Date | null
    designSize: number | null
    designOriginalName: string | null
    designDescription: string | null
    isDesignActive: boolean | null
    colorVariationId: number | null
  }

  export type ProductImageCountAggregateOutputType = {
    id: number
    view: number
    url: number
    publicId: number
    naturalWidth: number
    naturalHeight: number
    designUrl: number
    designPublicId: number
    designFileName: number
    designUploadDate: number
    designSize: number
    designOriginalName: number
    designDescription: number
    isDesignActive: number
    colorVariationId: number
    _all: number
  }


  export type ProductImageAvgAggregateInputType = {
    id?: true
    naturalWidth?: true
    naturalHeight?: true
    designSize?: true
    colorVariationId?: true
  }

  export type ProductImageSumAggregateInputType = {
    id?: true
    naturalWidth?: true
    naturalHeight?: true
    designSize?: true
    colorVariationId?: true
  }

  export type ProductImageMinAggregateInputType = {
    id?: true
    view?: true
    url?: true
    publicId?: true
    naturalWidth?: true
    naturalHeight?: true
    designUrl?: true
    designPublicId?: true
    designFileName?: true
    designUploadDate?: true
    designSize?: true
    designOriginalName?: true
    designDescription?: true
    isDesignActive?: true
    colorVariationId?: true
  }

  export type ProductImageMaxAggregateInputType = {
    id?: true
    view?: true
    url?: true
    publicId?: true
    naturalWidth?: true
    naturalHeight?: true
    designUrl?: true
    designPublicId?: true
    designFileName?: true
    designUploadDate?: true
    designSize?: true
    designOriginalName?: true
    designDescription?: true
    isDesignActive?: true
    colorVariationId?: true
  }

  export type ProductImageCountAggregateInputType = {
    id?: true
    view?: true
    url?: true
    publicId?: true
    naturalWidth?: true
    naturalHeight?: true
    designUrl?: true
    designPublicId?: true
    designFileName?: true
    designUploadDate?: true
    designSize?: true
    designOriginalName?: true
    designDescription?: true
    isDesignActive?: true
    colorVariationId?: true
    _all?: true
  }

  export type ProductImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImage to aggregate.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductImages
    **/
    _count?: true | ProductImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductImageMaxAggregateInputType
  }

  export type GetProductImageAggregateType<T extends ProductImageAggregateArgs> = {
        [P in keyof T & keyof AggregateProductImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductImage[P]>
      : GetScalarType<T[P], AggregateProductImage[P]>
  }




  export type ProductImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImageWhereInput
    orderBy?: ProductImageOrderByWithAggregationInput | ProductImageOrderByWithAggregationInput[]
    by: ProductImageScalarFieldEnum[] | ProductImageScalarFieldEnum
    having?: ProductImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductImageCountAggregateInputType | true
    _avg?: ProductImageAvgAggregateInputType
    _sum?: ProductImageSumAggregateInputType
    _min?: ProductImageMinAggregateInputType
    _max?: ProductImageMaxAggregateInputType
  }

  export type ProductImageGroupByOutputType = {
    id: number
    view: string
    url: string
    publicId: string
    naturalWidth: number | null
    naturalHeight: number | null
    designUrl: string | null
    designPublicId: string | null
    designFileName: string | null
    designUploadDate: Date | null
    designSize: number | null
    designOriginalName: string | null
    designDescription: string | null
    isDesignActive: boolean
    colorVariationId: number
    _count: ProductImageCountAggregateOutputType | null
    _avg: ProductImageAvgAggregateOutputType | null
    _sum: ProductImageSumAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  type GetProductImageGroupByPayload<T extends ProductImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
            : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
        }
      >
    >


  export type ProductImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    view?: boolean
    url?: boolean
    publicId?: boolean
    naturalWidth?: boolean
    naturalHeight?: boolean
    designUrl?: boolean
    designPublicId?: boolean
    designFileName?: boolean
    designUploadDate?: boolean
    designSize?: boolean
    designOriginalName?: boolean
    designDescription?: boolean
    isDesignActive?: boolean
    colorVariationId?: boolean
    colorVariation?: boolean | ColorVariationDefaultArgs<ExtArgs>
    delimitations?: boolean | ProductImage$delimitationsArgs<ExtArgs>
    _count?: boolean | ProductImageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productImage"]>

  export type ProductImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    view?: boolean
    url?: boolean
    publicId?: boolean
    naturalWidth?: boolean
    naturalHeight?: boolean
    designUrl?: boolean
    designPublicId?: boolean
    designFileName?: boolean
    designUploadDate?: boolean
    designSize?: boolean
    designOriginalName?: boolean
    designDescription?: boolean
    isDesignActive?: boolean
    colorVariationId?: boolean
    colorVariation?: boolean | ColorVariationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productImage"]>

  export type ProductImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    view?: boolean
    url?: boolean
    publicId?: boolean
    naturalWidth?: boolean
    naturalHeight?: boolean
    designUrl?: boolean
    designPublicId?: boolean
    designFileName?: boolean
    designUploadDate?: boolean
    designSize?: boolean
    designOriginalName?: boolean
    designDescription?: boolean
    isDesignActive?: boolean
    colorVariationId?: boolean
    colorVariation?: boolean | ColorVariationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productImage"]>

  export type ProductImageSelectScalar = {
    id?: boolean
    view?: boolean
    url?: boolean
    publicId?: boolean
    naturalWidth?: boolean
    naturalHeight?: boolean
    designUrl?: boolean
    designPublicId?: boolean
    designFileName?: boolean
    designUploadDate?: boolean
    designSize?: boolean
    designOriginalName?: boolean
    designDescription?: boolean
    isDesignActive?: boolean
    colorVariationId?: boolean
  }

  export type ProductImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "view" | "url" | "publicId" | "naturalWidth" | "naturalHeight" | "designUrl" | "designPublicId" | "designFileName" | "designUploadDate" | "designSize" | "designOriginalName" | "designDescription" | "isDesignActive" | "colorVariationId", ExtArgs["result"]["productImage"]>
  export type ProductImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    colorVariation?: boolean | ColorVariationDefaultArgs<ExtArgs>
    delimitations?: boolean | ProductImage$delimitationsArgs<ExtArgs>
    _count?: boolean | ProductImageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    colorVariation?: boolean | ColorVariationDefaultArgs<ExtArgs>
  }
  export type ProductImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    colorVariation?: boolean | ColorVariationDefaultArgs<ExtArgs>
  }

  export type $ProductImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductImage"
    objects: {
      colorVariation: Prisma.$ColorVariationPayload<ExtArgs>
      delimitations: Prisma.$DelimitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      view: string
      url: string
      publicId: string
      naturalWidth: number | null
      naturalHeight: number | null
      designUrl: string | null
      designPublicId: string | null
      designFileName: string | null
      designUploadDate: Date | null
      designSize: number | null
      designOriginalName: string | null
      designDescription: string | null
      isDesignActive: boolean
      colorVariationId: number
    }, ExtArgs["result"]["productImage"]>
    composites: {}
  }

  type ProductImageGetPayload<S extends boolean | null | undefined | ProductImageDefaultArgs> = $Result.GetResult<Prisma.$ProductImagePayload, S>

  type ProductImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductImageCountAggregateInputType | true
    }

  export interface ProductImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductImage'], meta: { name: 'ProductImage' } }
    /**
     * Find zero or one ProductImage that matches the filter.
     * @param {ProductImageFindUniqueArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductImageFindUniqueArgs>(args: SelectSubset<T, ProductImageFindUniqueArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductImageFindUniqueOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductImageFindFirstArgs>(args?: SelectSubset<T, ProductImageFindFirstArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductImages
     * const productImages = await prisma.productImage.findMany()
     * 
     * // Get first 10 ProductImages
     * const productImages = await prisma.productImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productImageWithIdOnly = await prisma.productImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductImageFindManyArgs>(args?: SelectSubset<T, ProductImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductImage.
     * @param {ProductImageCreateArgs} args - Arguments to create a ProductImage.
     * @example
     * // Create one ProductImage
     * const ProductImage = await prisma.productImage.create({
     *   data: {
     *     // ... data to create a ProductImage
     *   }
     * })
     * 
     */
    create<T extends ProductImageCreateArgs>(args: SelectSubset<T, ProductImageCreateArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductImages.
     * @param {ProductImageCreateManyArgs} args - Arguments to create many ProductImages.
     * @example
     * // Create many ProductImages
     * const productImage = await prisma.productImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductImageCreateManyArgs>(args?: SelectSubset<T, ProductImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductImages and returns the data saved in the database.
     * @param {ProductImageCreateManyAndReturnArgs} args - Arguments to create many ProductImages.
     * @example
     * // Create many ProductImages
     * const productImage = await prisma.productImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductImages and only return the `id`
     * const productImageWithIdOnly = await prisma.productImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductImageCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductImage.
     * @param {ProductImageDeleteArgs} args - Arguments to delete one ProductImage.
     * @example
     * // Delete one ProductImage
     * const ProductImage = await prisma.productImage.delete({
     *   where: {
     *     // ... filter to delete one ProductImage
     *   }
     * })
     * 
     */
    delete<T extends ProductImageDeleteArgs>(args: SelectSubset<T, ProductImageDeleteArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductImage.
     * @param {ProductImageUpdateArgs} args - Arguments to update one ProductImage.
     * @example
     * // Update one ProductImage
     * const productImage = await prisma.productImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductImageUpdateArgs>(args: SelectSubset<T, ProductImageUpdateArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductImages.
     * @param {ProductImageDeleteManyArgs} args - Arguments to filter ProductImages to delete.
     * @example
     * // Delete a few ProductImages
     * const { count } = await prisma.productImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductImageDeleteManyArgs>(args?: SelectSubset<T, ProductImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductImages
     * const productImage = await prisma.productImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductImageUpdateManyArgs>(args: SelectSubset<T, ProductImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductImages and returns the data updated in the database.
     * @param {ProductImageUpdateManyAndReturnArgs} args - Arguments to update many ProductImages.
     * @example
     * // Update many ProductImages
     * const productImage = await prisma.productImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductImages and only return the `id`
     * const productImageWithIdOnly = await prisma.productImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductImageUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductImage.
     * @param {ProductImageUpsertArgs} args - Arguments to update or create a ProductImage.
     * @example
     * // Update or create a ProductImage
     * const productImage = await prisma.productImage.upsert({
     *   create: {
     *     // ... data to create a ProductImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductImage we want to update
     *   }
     * })
     */
    upsert<T extends ProductImageUpsertArgs>(args: SelectSubset<T, ProductImageUpsertArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageCountArgs} args - Arguments to filter ProductImages to count.
     * @example
     * // Count the number of ProductImages
     * const count = await prisma.productImage.count({
     *   where: {
     *     // ... the filter for the ProductImages we want to count
     *   }
     * })
    **/
    count<T extends ProductImageCountArgs>(
      args?: Subset<T, ProductImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductImageAggregateArgs>(args: Subset<T, ProductImageAggregateArgs>): Prisma.PrismaPromise<GetProductImageAggregateType<T>>

    /**
     * Group by ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductImageGroupByArgs['orderBy'] }
        : { orderBy?: ProductImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductImage model
   */
  readonly fields: ProductImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    colorVariation<T extends ColorVariationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ColorVariationDefaultArgs<ExtArgs>>): Prisma__ColorVariationClient<$Result.GetResult<Prisma.$ColorVariationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    delimitations<T extends ProductImage$delimitationsArgs<ExtArgs> = {}>(args?: Subset<T, ProductImage$delimitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DelimitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductImage model
   */
  interface ProductImageFieldRefs {
    readonly id: FieldRef<"ProductImage", 'Int'>
    readonly view: FieldRef<"ProductImage", 'String'>
    readonly url: FieldRef<"ProductImage", 'String'>
    readonly publicId: FieldRef<"ProductImage", 'String'>
    readonly naturalWidth: FieldRef<"ProductImage", 'Int'>
    readonly naturalHeight: FieldRef<"ProductImage", 'Int'>
    readonly designUrl: FieldRef<"ProductImage", 'String'>
    readonly designPublicId: FieldRef<"ProductImage", 'String'>
    readonly designFileName: FieldRef<"ProductImage", 'String'>
    readonly designUploadDate: FieldRef<"ProductImage", 'DateTime'>
    readonly designSize: FieldRef<"ProductImage", 'Int'>
    readonly designOriginalName: FieldRef<"ProductImage", 'String'>
    readonly designDescription: FieldRef<"ProductImage", 'String'>
    readonly isDesignActive: FieldRef<"ProductImage", 'Boolean'>
    readonly colorVariationId: FieldRef<"ProductImage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProductImage findUnique
   */
  export type ProductImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage findUniqueOrThrow
   */
  export type ProductImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage findFirst
   */
  export type ProductImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductImage findFirstOrThrow
   */
  export type ProductImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductImage findMany
   */
  export type ProductImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImages to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductImage create
   */
  export type ProductImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductImage.
     */
    data: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
  }

  /**
   * ProductImage createMany
   */
  export type ProductImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductImages.
     */
    data: ProductImageCreateManyInput | ProductImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductImage createManyAndReturn
   */
  export type ProductImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * The data used to create many ProductImages.
     */
    data: ProductImageCreateManyInput | ProductImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductImage update
   */
  export type ProductImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductImage.
     */
    data: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
    /**
     * Choose, which ProductImage to update.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage updateMany
   */
  export type ProductImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductImages.
     */
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyInput>
    /**
     * Filter which ProductImages to update
     */
    where?: ProductImageWhereInput
    /**
     * Limit how many ProductImages to update.
     */
    limit?: number
  }

  /**
   * ProductImage updateManyAndReturn
   */
  export type ProductImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * The data used to update ProductImages.
     */
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyInput>
    /**
     * Filter which ProductImages to update
     */
    where?: ProductImageWhereInput
    /**
     * Limit how many ProductImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductImage upsert
   */
  export type ProductImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductImage to update in case it exists.
     */
    where: ProductImageWhereUniqueInput
    /**
     * In case the ProductImage found by the `where` argument doesn't exist, create a new ProductImage with this data.
     */
    create: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
    /**
     * In case the ProductImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
  }

  /**
   * ProductImage delete
   */
  export type ProductImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter which ProductImage to delete.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage deleteMany
   */
  export type ProductImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImages to delete
     */
    where?: ProductImageWhereInput
    /**
     * Limit how many ProductImages to delete.
     */
    limit?: number
  }

  /**
   * ProductImage.delimitations
   */
  export type ProductImage$delimitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delimitation
     */
    select?: DelimitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delimitation
     */
    omit?: DelimitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelimitationInclude<ExtArgs> | null
    where?: DelimitationWhereInput
    orderBy?: DelimitationOrderByWithRelationInput | DelimitationOrderByWithRelationInput[]
    cursor?: DelimitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DelimitationScalarFieldEnum | DelimitationScalarFieldEnum[]
  }

  /**
   * ProductImage without action
   */
  export type ProductImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
  }


  /**
   * Model Delimitation
   */

  export type AggregateDelimitation = {
    _count: DelimitationCountAggregateOutputType | null
    _avg: DelimitationAvgAggregateOutputType | null
    _sum: DelimitationSumAggregateOutputType | null
    _min: DelimitationMinAggregateOutputType | null
    _max: DelimitationMaxAggregateOutputType | null
  }

  export type DelimitationAvgAggregateOutputType = {
    id: number | null
    x: number | null
    y: number | null
    width: number | null
    height: number | null
    rotation: number | null
    absoluteX: number | null
    absoluteY: number | null
    absoluteWidth: number | null
    absoluteHeight: number | null
    originalImageWidth: number | null
    originalImageHeight: number | null
    productImageId: number | null
    referenceWidth: number | null
    referenceHeight: number | null
  }

  export type DelimitationSumAggregateOutputType = {
    id: number | null
    x: number | null
    y: number | null
    width: number | null
    height: number | null
    rotation: number | null
    absoluteX: number | null
    absoluteY: number | null
    absoluteWidth: number | null
    absoluteHeight: number | null
    originalImageWidth: number | null
    originalImageHeight: number | null
    productImageId: number | null
    referenceWidth: number | null
    referenceHeight: number | null
  }

  export type DelimitationMinAggregateOutputType = {
    id: number | null
    x: number | null
    y: number | null
    width: number | null
    height: number | null
    rotation: number | null
    name: string | null
    coordinateType: $Enums.CoordinateType | null
    absoluteX: number | null
    absoluteY: number | null
    absoluteWidth: number | null
    absoluteHeight: number | null
    originalImageWidth: number | null
    originalImageHeight: number | null
    productImageId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    referenceWidth: number | null
    referenceHeight: number | null
  }

  export type DelimitationMaxAggregateOutputType = {
    id: number | null
    x: number | null
    y: number | null
    width: number | null
    height: number | null
    rotation: number | null
    name: string | null
    coordinateType: $Enums.CoordinateType | null
    absoluteX: number | null
    absoluteY: number | null
    absoluteWidth: number | null
    absoluteHeight: number | null
    originalImageWidth: number | null
    originalImageHeight: number | null
    productImageId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    referenceWidth: number | null
    referenceHeight: number | null
  }

  export type DelimitationCountAggregateOutputType = {
    id: number
    x: number
    y: number
    width: number
    height: number
    rotation: number
    name: number
    coordinateType: number
    absoluteX: number
    absoluteY: number
    absoluteWidth: number
    absoluteHeight: number
    originalImageWidth: number
    originalImageHeight: number
    productImageId: number
    createdAt: number
    updatedAt: number
    referenceWidth: number
    referenceHeight: number
    _all: number
  }


  export type DelimitationAvgAggregateInputType = {
    id?: true
    x?: true
    y?: true
    width?: true
    height?: true
    rotation?: true
    absoluteX?: true
    absoluteY?: true
    absoluteWidth?: true
    absoluteHeight?: true
    originalImageWidth?: true
    originalImageHeight?: true
    productImageId?: true
    referenceWidth?: true
    referenceHeight?: true
  }

  export type DelimitationSumAggregateInputType = {
    id?: true
    x?: true
    y?: true
    width?: true
    height?: true
    rotation?: true
    absoluteX?: true
    absoluteY?: true
    absoluteWidth?: true
    absoluteHeight?: true
    originalImageWidth?: true
    originalImageHeight?: true
    productImageId?: true
    referenceWidth?: true
    referenceHeight?: true
  }

  export type DelimitationMinAggregateInputType = {
    id?: true
    x?: true
    y?: true
    width?: true
    height?: true
    rotation?: true
    name?: true
    coordinateType?: true
    absoluteX?: true
    absoluteY?: true
    absoluteWidth?: true
    absoluteHeight?: true
    originalImageWidth?: true
    originalImageHeight?: true
    productImageId?: true
    createdAt?: true
    updatedAt?: true
    referenceWidth?: true
    referenceHeight?: true
  }

  export type DelimitationMaxAggregateInputType = {
    id?: true
    x?: true
    y?: true
    width?: true
    height?: true
    rotation?: true
    name?: true
    coordinateType?: true
    absoluteX?: true
    absoluteY?: true
    absoluteWidth?: true
    absoluteHeight?: true
    originalImageWidth?: true
    originalImageHeight?: true
    productImageId?: true
    createdAt?: true
    updatedAt?: true
    referenceWidth?: true
    referenceHeight?: true
  }

  export type DelimitationCountAggregateInputType = {
    id?: true
    x?: true
    y?: true
    width?: true
    height?: true
    rotation?: true
    name?: true
    coordinateType?: true
    absoluteX?: true
    absoluteY?: true
    absoluteWidth?: true
    absoluteHeight?: true
    originalImageWidth?: true
    originalImageHeight?: true
    productImageId?: true
    createdAt?: true
    updatedAt?: true
    referenceWidth?: true
    referenceHeight?: true
    _all?: true
  }

  export type DelimitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Delimitation to aggregate.
     */
    where?: DelimitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Delimitations to fetch.
     */
    orderBy?: DelimitationOrderByWithRelationInput | DelimitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DelimitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Delimitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Delimitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Delimitations
    **/
    _count?: true | DelimitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DelimitationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DelimitationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DelimitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DelimitationMaxAggregateInputType
  }

  export type GetDelimitationAggregateType<T extends DelimitationAggregateArgs> = {
        [P in keyof T & keyof AggregateDelimitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDelimitation[P]>
      : GetScalarType<T[P], AggregateDelimitation[P]>
  }




  export type DelimitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DelimitationWhereInput
    orderBy?: DelimitationOrderByWithAggregationInput | DelimitationOrderByWithAggregationInput[]
    by: DelimitationScalarFieldEnum[] | DelimitationScalarFieldEnum
    having?: DelimitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DelimitationCountAggregateInputType | true
    _avg?: DelimitationAvgAggregateInputType
    _sum?: DelimitationSumAggregateInputType
    _min?: DelimitationMinAggregateInputType
    _max?: DelimitationMaxAggregateInputType
  }

  export type DelimitationGroupByOutputType = {
    id: number
    x: number
    y: number
    width: number
    height: number
    rotation: number
    name: string | null
    coordinateType: $Enums.CoordinateType
    absoluteX: number | null
    absoluteY: number | null
    absoluteWidth: number | null
    absoluteHeight: number | null
    originalImageWidth: number | null
    originalImageHeight: number | null
    productImageId: number
    createdAt: Date
    updatedAt: Date
    referenceWidth: number
    referenceHeight: number
    _count: DelimitationCountAggregateOutputType | null
    _avg: DelimitationAvgAggregateOutputType | null
    _sum: DelimitationSumAggregateOutputType | null
    _min: DelimitationMinAggregateOutputType | null
    _max: DelimitationMaxAggregateOutputType | null
  }

  type GetDelimitationGroupByPayload<T extends DelimitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DelimitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DelimitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DelimitationGroupByOutputType[P]>
            : GetScalarType<T[P], DelimitationGroupByOutputType[P]>
        }
      >
    >


  export type DelimitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    x?: boolean
    y?: boolean
    width?: boolean
    height?: boolean
    rotation?: boolean
    name?: boolean
    coordinateType?: boolean
    absoluteX?: boolean
    absoluteY?: boolean
    absoluteWidth?: boolean
    absoluteHeight?: boolean
    originalImageWidth?: boolean
    originalImageHeight?: boolean
    productImageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referenceWidth?: boolean
    referenceHeight?: boolean
    productImage?: boolean | ProductImageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delimitation"]>

  export type DelimitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    x?: boolean
    y?: boolean
    width?: boolean
    height?: boolean
    rotation?: boolean
    name?: boolean
    coordinateType?: boolean
    absoluteX?: boolean
    absoluteY?: boolean
    absoluteWidth?: boolean
    absoluteHeight?: boolean
    originalImageWidth?: boolean
    originalImageHeight?: boolean
    productImageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referenceWidth?: boolean
    referenceHeight?: boolean
    productImage?: boolean | ProductImageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delimitation"]>

  export type DelimitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    x?: boolean
    y?: boolean
    width?: boolean
    height?: boolean
    rotation?: boolean
    name?: boolean
    coordinateType?: boolean
    absoluteX?: boolean
    absoluteY?: boolean
    absoluteWidth?: boolean
    absoluteHeight?: boolean
    originalImageWidth?: boolean
    originalImageHeight?: boolean
    productImageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referenceWidth?: boolean
    referenceHeight?: boolean
    productImage?: boolean | ProductImageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delimitation"]>

  export type DelimitationSelectScalar = {
    id?: boolean
    x?: boolean
    y?: boolean
    width?: boolean
    height?: boolean
    rotation?: boolean
    name?: boolean
    coordinateType?: boolean
    absoluteX?: boolean
    absoluteY?: boolean
    absoluteWidth?: boolean
    absoluteHeight?: boolean
    originalImageWidth?: boolean
    originalImageHeight?: boolean
    productImageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referenceWidth?: boolean
    referenceHeight?: boolean
  }

  export type DelimitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "x" | "y" | "width" | "height" | "rotation" | "name" | "coordinateType" | "absoluteX" | "absoluteY" | "absoluteWidth" | "absoluteHeight" | "originalImageWidth" | "originalImageHeight" | "productImageId" | "createdAt" | "updatedAt" | "referenceWidth" | "referenceHeight", ExtArgs["result"]["delimitation"]>
  export type DelimitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productImage?: boolean | ProductImageDefaultArgs<ExtArgs>
  }
  export type DelimitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productImage?: boolean | ProductImageDefaultArgs<ExtArgs>
  }
  export type DelimitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productImage?: boolean | ProductImageDefaultArgs<ExtArgs>
  }

  export type $DelimitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Delimitation"
    objects: {
      productImage: Prisma.$ProductImagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      x: number
      y: number
      width: number
      height: number
      rotation: number
      name: string | null
      coordinateType: $Enums.CoordinateType
      absoluteX: number | null
      absoluteY: number | null
      absoluteWidth: number | null
      absoluteHeight: number | null
      originalImageWidth: number | null
      originalImageHeight: number | null
      productImageId: number
      createdAt: Date
      updatedAt: Date
      referenceWidth: number
      referenceHeight: number
    }, ExtArgs["result"]["delimitation"]>
    composites: {}
  }

  type DelimitationGetPayload<S extends boolean | null | undefined | DelimitationDefaultArgs> = $Result.GetResult<Prisma.$DelimitationPayload, S>

  type DelimitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DelimitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DelimitationCountAggregateInputType | true
    }

  export interface DelimitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Delimitation'], meta: { name: 'Delimitation' } }
    /**
     * Find zero or one Delimitation that matches the filter.
     * @param {DelimitationFindUniqueArgs} args - Arguments to find a Delimitation
     * @example
     * // Get one Delimitation
     * const delimitation = await prisma.delimitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DelimitationFindUniqueArgs>(args: SelectSubset<T, DelimitationFindUniqueArgs<ExtArgs>>): Prisma__DelimitationClient<$Result.GetResult<Prisma.$DelimitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Delimitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DelimitationFindUniqueOrThrowArgs} args - Arguments to find a Delimitation
     * @example
     * // Get one Delimitation
     * const delimitation = await prisma.delimitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DelimitationFindUniqueOrThrowArgs>(args: SelectSubset<T, DelimitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DelimitationClient<$Result.GetResult<Prisma.$DelimitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Delimitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelimitationFindFirstArgs} args - Arguments to find a Delimitation
     * @example
     * // Get one Delimitation
     * const delimitation = await prisma.delimitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DelimitationFindFirstArgs>(args?: SelectSubset<T, DelimitationFindFirstArgs<ExtArgs>>): Prisma__DelimitationClient<$Result.GetResult<Prisma.$DelimitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Delimitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelimitationFindFirstOrThrowArgs} args - Arguments to find a Delimitation
     * @example
     * // Get one Delimitation
     * const delimitation = await prisma.delimitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DelimitationFindFirstOrThrowArgs>(args?: SelectSubset<T, DelimitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DelimitationClient<$Result.GetResult<Prisma.$DelimitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Delimitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelimitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Delimitations
     * const delimitations = await prisma.delimitation.findMany()
     * 
     * // Get first 10 Delimitations
     * const delimitations = await prisma.delimitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const delimitationWithIdOnly = await prisma.delimitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DelimitationFindManyArgs>(args?: SelectSubset<T, DelimitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DelimitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Delimitation.
     * @param {DelimitationCreateArgs} args - Arguments to create a Delimitation.
     * @example
     * // Create one Delimitation
     * const Delimitation = await prisma.delimitation.create({
     *   data: {
     *     // ... data to create a Delimitation
     *   }
     * })
     * 
     */
    create<T extends DelimitationCreateArgs>(args: SelectSubset<T, DelimitationCreateArgs<ExtArgs>>): Prisma__DelimitationClient<$Result.GetResult<Prisma.$DelimitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Delimitations.
     * @param {DelimitationCreateManyArgs} args - Arguments to create many Delimitations.
     * @example
     * // Create many Delimitations
     * const delimitation = await prisma.delimitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DelimitationCreateManyArgs>(args?: SelectSubset<T, DelimitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Delimitations and returns the data saved in the database.
     * @param {DelimitationCreateManyAndReturnArgs} args - Arguments to create many Delimitations.
     * @example
     * // Create many Delimitations
     * const delimitation = await prisma.delimitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Delimitations and only return the `id`
     * const delimitationWithIdOnly = await prisma.delimitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DelimitationCreateManyAndReturnArgs>(args?: SelectSubset<T, DelimitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DelimitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Delimitation.
     * @param {DelimitationDeleteArgs} args - Arguments to delete one Delimitation.
     * @example
     * // Delete one Delimitation
     * const Delimitation = await prisma.delimitation.delete({
     *   where: {
     *     // ... filter to delete one Delimitation
     *   }
     * })
     * 
     */
    delete<T extends DelimitationDeleteArgs>(args: SelectSubset<T, DelimitationDeleteArgs<ExtArgs>>): Prisma__DelimitationClient<$Result.GetResult<Prisma.$DelimitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Delimitation.
     * @param {DelimitationUpdateArgs} args - Arguments to update one Delimitation.
     * @example
     * // Update one Delimitation
     * const delimitation = await prisma.delimitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DelimitationUpdateArgs>(args: SelectSubset<T, DelimitationUpdateArgs<ExtArgs>>): Prisma__DelimitationClient<$Result.GetResult<Prisma.$DelimitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Delimitations.
     * @param {DelimitationDeleteManyArgs} args - Arguments to filter Delimitations to delete.
     * @example
     * // Delete a few Delimitations
     * const { count } = await prisma.delimitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DelimitationDeleteManyArgs>(args?: SelectSubset<T, DelimitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Delimitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelimitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Delimitations
     * const delimitation = await prisma.delimitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DelimitationUpdateManyArgs>(args: SelectSubset<T, DelimitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Delimitations and returns the data updated in the database.
     * @param {DelimitationUpdateManyAndReturnArgs} args - Arguments to update many Delimitations.
     * @example
     * // Update many Delimitations
     * const delimitation = await prisma.delimitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Delimitations and only return the `id`
     * const delimitationWithIdOnly = await prisma.delimitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DelimitationUpdateManyAndReturnArgs>(args: SelectSubset<T, DelimitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DelimitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Delimitation.
     * @param {DelimitationUpsertArgs} args - Arguments to update or create a Delimitation.
     * @example
     * // Update or create a Delimitation
     * const delimitation = await prisma.delimitation.upsert({
     *   create: {
     *     // ... data to create a Delimitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Delimitation we want to update
     *   }
     * })
     */
    upsert<T extends DelimitationUpsertArgs>(args: SelectSubset<T, DelimitationUpsertArgs<ExtArgs>>): Prisma__DelimitationClient<$Result.GetResult<Prisma.$DelimitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Delimitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelimitationCountArgs} args - Arguments to filter Delimitations to count.
     * @example
     * // Count the number of Delimitations
     * const count = await prisma.delimitation.count({
     *   where: {
     *     // ... the filter for the Delimitations we want to count
     *   }
     * })
    **/
    count<T extends DelimitationCountArgs>(
      args?: Subset<T, DelimitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DelimitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Delimitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelimitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DelimitationAggregateArgs>(args: Subset<T, DelimitationAggregateArgs>): Prisma.PrismaPromise<GetDelimitationAggregateType<T>>

    /**
     * Group by Delimitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelimitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DelimitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DelimitationGroupByArgs['orderBy'] }
        : { orderBy?: DelimitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DelimitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDelimitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Delimitation model
   */
  readonly fields: DelimitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Delimitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DelimitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productImage<T extends ProductImageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductImageDefaultArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Delimitation model
   */
  interface DelimitationFieldRefs {
    readonly id: FieldRef<"Delimitation", 'Int'>
    readonly x: FieldRef<"Delimitation", 'Float'>
    readonly y: FieldRef<"Delimitation", 'Float'>
    readonly width: FieldRef<"Delimitation", 'Float'>
    readonly height: FieldRef<"Delimitation", 'Float'>
    readonly rotation: FieldRef<"Delimitation", 'Float'>
    readonly name: FieldRef<"Delimitation", 'String'>
    readonly coordinateType: FieldRef<"Delimitation", 'CoordinateType'>
    readonly absoluteX: FieldRef<"Delimitation", 'Float'>
    readonly absoluteY: FieldRef<"Delimitation", 'Float'>
    readonly absoluteWidth: FieldRef<"Delimitation", 'Float'>
    readonly absoluteHeight: FieldRef<"Delimitation", 'Float'>
    readonly originalImageWidth: FieldRef<"Delimitation", 'Int'>
    readonly originalImageHeight: FieldRef<"Delimitation", 'Int'>
    readonly productImageId: FieldRef<"Delimitation", 'Int'>
    readonly createdAt: FieldRef<"Delimitation", 'DateTime'>
    readonly updatedAt: FieldRef<"Delimitation", 'DateTime'>
    readonly referenceWidth: FieldRef<"Delimitation", 'Int'>
    readonly referenceHeight: FieldRef<"Delimitation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Delimitation findUnique
   */
  export type DelimitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delimitation
     */
    select?: DelimitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delimitation
     */
    omit?: DelimitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelimitationInclude<ExtArgs> | null
    /**
     * Filter, which Delimitation to fetch.
     */
    where: DelimitationWhereUniqueInput
  }

  /**
   * Delimitation findUniqueOrThrow
   */
  export type DelimitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delimitation
     */
    select?: DelimitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delimitation
     */
    omit?: DelimitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelimitationInclude<ExtArgs> | null
    /**
     * Filter, which Delimitation to fetch.
     */
    where: DelimitationWhereUniqueInput
  }

  /**
   * Delimitation findFirst
   */
  export type DelimitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delimitation
     */
    select?: DelimitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delimitation
     */
    omit?: DelimitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelimitationInclude<ExtArgs> | null
    /**
     * Filter, which Delimitation to fetch.
     */
    where?: DelimitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Delimitations to fetch.
     */
    orderBy?: DelimitationOrderByWithRelationInput | DelimitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Delimitations.
     */
    cursor?: DelimitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Delimitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Delimitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Delimitations.
     */
    distinct?: DelimitationScalarFieldEnum | DelimitationScalarFieldEnum[]
  }

  /**
   * Delimitation findFirstOrThrow
   */
  export type DelimitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delimitation
     */
    select?: DelimitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delimitation
     */
    omit?: DelimitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelimitationInclude<ExtArgs> | null
    /**
     * Filter, which Delimitation to fetch.
     */
    where?: DelimitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Delimitations to fetch.
     */
    orderBy?: DelimitationOrderByWithRelationInput | DelimitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Delimitations.
     */
    cursor?: DelimitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Delimitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Delimitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Delimitations.
     */
    distinct?: DelimitationScalarFieldEnum | DelimitationScalarFieldEnum[]
  }

  /**
   * Delimitation findMany
   */
  export type DelimitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delimitation
     */
    select?: DelimitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delimitation
     */
    omit?: DelimitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelimitationInclude<ExtArgs> | null
    /**
     * Filter, which Delimitations to fetch.
     */
    where?: DelimitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Delimitations to fetch.
     */
    orderBy?: DelimitationOrderByWithRelationInput | DelimitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Delimitations.
     */
    cursor?: DelimitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Delimitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Delimitations.
     */
    skip?: number
    distinct?: DelimitationScalarFieldEnum | DelimitationScalarFieldEnum[]
  }

  /**
   * Delimitation create
   */
  export type DelimitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delimitation
     */
    select?: DelimitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delimitation
     */
    omit?: DelimitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelimitationInclude<ExtArgs> | null
    /**
     * The data needed to create a Delimitation.
     */
    data: XOR<DelimitationCreateInput, DelimitationUncheckedCreateInput>
  }

  /**
   * Delimitation createMany
   */
  export type DelimitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Delimitations.
     */
    data: DelimitationCreateManyInput | DelimitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Delimitation createManyAndReturn
   */
  export type DelimitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delimitation
     */
    select?: DelimitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Delimitation
     */
    omit?: DelimitationOmit<ExtArgs> | null
    /**
     * The data used to create many Delimitations.
     */
    data: DelimitationCreateManyInput | DelimitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelimitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Delimitation update
   */
  export type DelimitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delimitation
     */
    select?: DelimitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delimitation
     */
    omit?: DelimitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelimitationInclude<ExtArgs> | null
    /**
     * The data needed to update a Delimitation.
     */
    data: XOR<DelimitationUpdateInput, DelimitationUncheckedUpdateInput>
    /**
     * Choose, which Delimitation to update.
     */
    where: DelimitationWhereUniqueInput
  }

  /**
   * Delimitation updateMany
   */
  export type DelimitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Delimitations.
     */
    data: XOR<DelimitationUpdateManyMutationInput, DelimitationUncheckedUpdateManyInput>
    /**
     * Filter which Delimitations to update
     */
    where?: DelimitationWhereInput
    /**
     * Limit how many Delimitations to update.
     */
    limit?: number
  }

  /**
   * Delimitation updateManyAndReturn
   */
  export type DelimitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delimitation
     */
    select?: DelimitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Delimitation
     */
    omit?: DelimitationOmit<ExtArgs> | null
    /**
     * The data used to update Delimitations.
     */
    data: XOR<DelimitationUpdateManyMutationInput, DelimitationUncheckedUpdateManyInput>
    /**
     * Filter which Delimitations to update
     */
    where?: DelimitationWhereInput
    /**
     * Limit how many Delimitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelimitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Delimitation upsert
   */
  export type DelimitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delimitation
     */
    select?: DelimitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delimitation
     */
    omit?: DelimitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelimitationInclude<ExtArgs> | null
    /**
     * The filter to search for the Delimitation to update in case it exists.
     */
    where: DelimitationWhereUniqueInput
    /**
     * In case the Delimitation found by the `where` argument doesn't exist, create a new Delimitation with this data.
     */
    create: XOR<DelimitationCreateInput, DelimitationUncheckedCreateInput>
    /**
     * In case the Delimitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DelimitationUpdateInput, DelimitationUncheckedUpdateInput>
  }

  /**
   * Delimitation delete
   */
  export type DelimitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delimitation
     */
    select?: DelimitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delimitation
     */
    omit?: DelimitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelimitationInclude<ExtArgs> | null
    /**
     * Filter which Delimitation to delete.
     */
    where: DelimitationWhereUniqueInput
  }

  /**
   * Delimitation deleteMany
   */
  export type DelimitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Delimitations to delete
     */
    where?: DelimitationWhereInput
    /**
     * Limit how many Delimitations to delete.
     */
    limit?: number
  }

  /**
   * Delimitation without action
   */
  export type DelimitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delimitation
     */
    select?: DelimitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delimitation
     */
    omit?: DelimitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelimitationInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    totalAmount: number | null
    validatedBy: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    userId: number | null
    totalAmount: number | null
    validatedBy: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    orderNumber: string | null
    userId: number | null
    status: $Enums.OrderStatus | null
    totalAmount: number | null
    phoneNumber: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    validatedAt: Date | null
    validatedBy: number | null
    shippingName: string | null
    shippingStreet: string | null
    shippingCity: string | null
    shippingRegion: string | null
    shippingPostalCode: string | null
    shippingCountry: string | null
    shippingAddressFull: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    orderNumber: string | null
    userId: number | null
    status: $Enums.OrderStatus | null
    totalAmount: number | null
    phoneNumber: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    validatedAt: Date | null
    validatedBy: number | null
    shippingName: string | null
    shippingStreet: string | null
    shippingCity: string | null
    shippingRegion: string | null
    shippingPostalCode: string | null
    shippingCountry: string | null
    shippingAddressFull: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    userId: number
    status: number
    totalAmount: number
    phoneNumber: number
    notes: number
    createdAt: number
    updatedAt: number
    validatedAt: number
    validatedBy: number
    shippingName: number
    shippingStreet: number
    shippingCity: number
    shippingRegion: number
    shippingPostalCode: number
    shippingCountry: number
    shippingAddressFull: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    userId?: true
    totalAmount?: true
    validatedBy?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    userId?: true
    totalAmount?: true
    validatedBy?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    userId?: true
    status?: true
    totalAmount?: true
    phoneNumber?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    validatedAt?: true
    validatedBy?: true
    shippingName?: true
    shippingStreet?: true
    shippingCity?: true
    shippingRegion?: true
    shippingPostalCode?: true
    shippingCountry?: true
    shippingAddressFull?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    userId?: true
    status?: true
    totalAmount?: true
    phoneNumber?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    validatedAt?: true
    validatedBy?: true
    shippingName?: true
    shippingStreet?: true
    shippingCity?: true
    shippingRegion?: true
    shippingPostalCode?: true
    shippingCountry?: true
    shippingAddressFull?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    userId?: true
    status?: true
    totalAmount?: true
    phoneNumber?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    validatedAt?: true
    validatedBy?: true
    shippingName?: true
    shippingStreet?: true
    shippingCity?: true
    shippingRegion?: true
    shippingPostalCode?: true
    shippingCountry?: true
    shippingAddressFull?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: number
    orderNumber: string
    userId: number
    status: $Enums.OrderStatus
    totalAmount: number
    phoneNumber: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    validatedAt: Date | null
    validatedBy: number | null
    shippingName: string | null
    shippingStreet: string | null
    shippingCity: string | null
    shippingRegion: string | null
    shippingPostalCode: string | null
    shippingCountry: string | null
    shippingAddressFull: string | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    userId?: boolean
    status?: boolean
    totalAmount?: boolean
    phoneNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    validatedAt?: boolean
    validatedBy?: boolean
    shippingName?: boolean
    shippingStreet?: boolean
    shippingCity?: boolean
    shippingRegion?: boolean
    shippingPostalCode?: boolean
    shippingCountry?: boolean
    shippingAddressFull?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    validator?: boolean | Order$validatorArgs<ExtArgs>
    orderItems?: boolean | Order$orderItemsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    userId?: boolean
    status?: boolean
    totalAmount?: boolean
    phoneNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    validatedAt?: boolean
    validatedBy?: boolean
    shippingName?: boolean
    shippingStreet?: boolean
    shippingCity?: boolean
    shippingRegion?: boolean
    shippingPostalCode?: boolean
    shippingCountry?: boolean
    shippingAddressFull?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    validator?: boolean | Order$validatorArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    userId?: boolean
    status?: boolean
    totalAmount?: boolean
    phoneNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    validatedAt?: boolean
    validatedBy?: boolean
    shippingName?: boolean
    shippingStreet?: boolean
    shippingCity?: boolean
    shippingRegion?: boolean
    shippingPostalCode?: boolean
    shippingCountry?: boolean
    shippingAddressFull?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    validator?: boolean | Order$validatorArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    userId?: boolean
    status?: boolean
    totalAmount?: boolean
    phoneNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    validatedAt?: boolean
    validatedBy?: boolean
    shippingName?: boolean
    shippingStreet?: boolean
    shippingCity?: boolean
    shippingRegion?: boolean
    shippingPostalCode?: boolean
    shippingCountry?: boolean
    shippingAddressFull?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNumber" | "userId" | "status" | "totalAmount" | "phoneNumber" | "notes" | "createdAt" | "updatedAt" | "validatedAt" | "validatedBy" | "shippingName" | "shippingStreet" | "shippingCity" | "shippingRegion" | "shippingPostalCode" | "shippingCountry" | "shippingAddressFull", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    validator?: boolean | Order$validatorArgs<ExtArgs>
    orderItems?: boolean | Order$orderItemsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    validator?: boolean | Order$validatorArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    validator?: boolean | Order$validatorArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      validator: Prisma.$UserPayload<ExtArgs> | null
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderNumber: string
      userId: number
      status: $Enums.OrderStatus
      totalAmount: number
      phoneNumber: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
      validatedAt: Date | null
      validatedBy: number | null
      shippingName: string | null
      shippingStreet: string | null
      shippingCity: string | null
      shippingRegion: string | null
      shippingPostalCode: string | null
      shippingCountry: string | null
      shippingAddressFull: string | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    validator<T extends Order$validatorArgs<ExtArgs> = {}>(args?: Subset<T, Order$validatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orderItems<T extends Order$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'Int'>
    readonly orderNumber: FieldRef<"Order", 'String'>
    readonly userId: FieldRef<"Order", 'Int'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly totalAmount: FieldRef<"Order", 'Float'>
    readonly phoneNumber: FieldRef<"Order", 'String'>
    readonly notes: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly validatedAt: FieldRef<"Order", 'DateTime'>
    readonly validatedBy: FieldRef<"Order", 'Int'>
    readonly shippingName: FieldRef<"Order", 'String'>
    readonly shippingStreet: FieldRef<"Order", 'String'>
    readonly shippingCity: FieldRef<"Order", 'String'>
    readonly shippingRegion: FieldRef<"Order", 'String'>
    readonly shippingPostalCode: FieldRef<"Order", 'String'>
    readonly shippingCountry: FieldRef<"Order", 'String'>
    readonly shippingAddressFull: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.validator
   */
  export type Order$validatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Order.orderItems
   */
  export type Order$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    unitPrice: number | null
    colorId: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    unitPrice: number | null
    colorId: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    unitPrice: number | null
    size: string | null
    color: string | null
    colorId: number | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    unitPrice: number | null
    size: string | null
    color: string | null
    colorId: number | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    quantity: number
    unitPrice: number
    size: number
    color: number
    colorId: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    colorId?: true
  }

  export type OrderItemSumAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    colorId?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    size?: true
    color?: true
    colorId?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    size?: true
    color?: true
    colorId?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    size?: true
    color?: true
    colorId?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: number
    orderId: number
    productId: number
    quantity: number
    unitPrice: number
    size: string | null
    color: string | null
    colorId: number | null
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    size?: boolean
    color?: boolean
    colorId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    colorVariation?: boolean | OrderItem$colorVariationArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    size?: boolean
    color?: boolean
    colorId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    colorVariation?: boolean | OrderItem$colorVariationArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    size?: boolean
    color?: boolean
    colorId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    colorVariation?: boolean | OrderItem$colorVariationArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    size?: boolean
    color?: boolean
    colorId?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "productId" | "quantity" | "unitPrice" | "size" | "color" | "colorId", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    colorVariation?: boolean | OrderItem$colorVariationArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    colorVariation?: boolean | OrderItem$colorVariationArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    colorVariation?: boolean | OrderItem$colorVariationArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      colorVariation: Prisma.$ColorVariationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      productId: number
      quantity: number
      unitPrice: number
      size: string | null
      color: string | null
      colorId: number | null
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    colorVariation<T extends OrderItem$colorVariationArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$colorVariationArgs<ExtArgs>>): Prisma__ColorVariationClient<$Result.GetResult<Prisma.$ColorVariationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'Int'>
    readonly orderId: FieldRef<"OrderItem", 'Int'>
    readonly productId: FieldRef<"OrderItem", 'Int'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly unitPrice: FieldRef<"OrderItem", 'Float'>
    readonly size: FieldRef<"OrderItem", 'String'>
    readonly color: FieldRef<"OrderItem", 'String'>
    readonly colorId: FieldRef<"OrderItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem.colorVariation
   */
  export type OrderItem$colorVariationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorVariation
     */
    select?: ColorVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorVariation
     */
    omit?: ColorVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorVariationInclude<ExtArgs> | null
    where?: ColorVariationWhereInput
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    isRead: number
    metadata: number
    createdAt: number
    updatedAt: number
    expiresAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    userId: number
    type: $Enums.NotificationType
    title: string
    message: string
    isRead: boolean
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    expiresAt: Date | null
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "message" | "isRead" | "metadata" | "createdAt" | "updatedAt" | "expiresAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      type: $Enums.NotificationType
      title: string
      message: string
      isRead: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly userId: FieldRef<"Notification", 'Int'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
    readonly expiresAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Design
   */

  export type AggregateDesign = {
    _count: DesignCountAggregateOutputType | null
    _avg: DesignAvgAggregateOutputType | null
    _sum: DesignSumAggregateOutputType | null
    _min: DesignMinAggregateOutputType | null
    _max: DesignMaxAggregateOutputType | null
  }

  export type DesignAvgAggregateOutputType = {
    id: number | null
    vendorId: number | null
    price: number | null
    fileSize: number | null
    validatedBy: number | null
    views: number | null
    likes: number | null
    earnings: number | null
    usageCount: number | null
  }

  export type DesignSumAggregateOutputType = {
    id: number | null
    vendorId: number | null
    price: number | null
    fileSize: number | null
    validatedBy: number | null
    views: number | null
    likes: number | null
    earnings: number | null
    usageCount: number | null
  }

  export type DesignMinAggregateOutputType = {
    id: number | null
    vendorId: number | null
    name: string | null
    description: string | null
    price: number | null
    category: $Enums.DesignCategory | null
    imageUrl: string | null
    thumbnailUrl: string | null
    cloudinaryPublicId: string | null
    thumbnailPublicId: string | null
    fileSize: number | null
    originalFileName: string | null
    format: string | null
    isDraft: boolean | null
    isPublished: boolean | null
    isPending: boolean | null
    isValidated: boolean | null
    validatedAt: Date | null
    validatedBy: number | null
    rejectionReason: string | null
    submittedForValidationAt: Date | null
    views: number | null
    likes: number | null
    earnings: number | null
    usageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
  }

  export type DesignMaxAggregateOutputType = {
    id: number | null
    vendorId: number | null
    name: string | null
    description: string | null
    price: number | null
    category: $Enums.DesignCategory | null
    imageUrl: string | null
    thumbnailUrl: string | null
    cloudinaryPublicId: string | null
    thumbnailPublicId: string | null
    fileSize: number | null
    originalFileName: string | null
    format: string | null
    isDraft: boolean | null
    isPublished: boolean | null
    isPending: boolean | null
    isValidated: boolean | null
    validatedAt: Date | null
    validatedBy: number | null
    rejectionReason: string | null
    submittedForValidationAt: Date | null
    views: number | null
    likes: number | null
    earnings: number | null
    usageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
  }

  export type DesignCountAggregateOutputType = {
    id: number
    vendorId: number
    name: number
    description: number
    price: number
    category: number
    imageUrl: number
    thumbnailUrl: number
    cloudinaryPublicId: number
    thumbnailPublicId: number
    fileSize: number
    originalFileName: number
    dimensions: number
    format: number
    tags: number
    isDraft: number
    isPublished: number
    isPending: number
    isValidated: number
    validatedAt: number
    validatedBy: number
    rejectionReason: number
    submittedForValidationAt: number
    views: number
    likes: number
    earnings: number
    usageCount: number
    createdAt: number
    updatedAt: number
    publishedAt: number
    _all: number
  }


  export type DesignAvgAggregateInputType = {
    id?: true
    vendorId?: true
    price?: true
    fileSize?: true
    validatedBy?: true
    views?: true
    likes?: true
    earnings?: true
    usageCount?: true
  }

  export type DesignSumAggregateInputType = {
    id?: true
    vendorId?: true
    price?: true
    fileSize?: true
    validatedBy?: true
    views?: true
    likes?: true
    earnings?: true
    usageCount?: true
  }

  export type DesignMinAggregateInputType = {
    id?: true
    vendorId?: true
    name?: true
    description?: true
    price?: true
    category?: true
    imageUrl?: true
    thumbnailUrl?: true
    cloudinaryPublicId?: true
    thumbnailPublicId?: true
    fileSize?: true
    originalFileName?: true
    format?: true
    isDraft?: true
    isPublished?: true
    isPending?: true
    isValidated?: true
    validatedAt?: true
    validatedBy?: true
    rejectionReason?: true
    submittedForValidationAt?: true
    views?: true
    likes?: true
    earnings?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
  }

  export type DesignMaxAggregateInputType = {
    id?: true
    vendorId?: true
    name?: true
    description?: true
    price?: true
    category?: true
    imageUrl?: true
    thumbnailUrl?: true
    cloudinaryPublicId?: true
    thumbnailPublicId?: true
    fileSize?: true
    originalFileName?: true
    format?: true
    isDraft?: true
    isPublished?: true
    isPending?: true
    isValidated?: true
    validatedAt?: true
    validatedBy?: true
    rejectionReason?: true
    submittedForValidationAt?: true
    views?: true
    likes?: true
    earnings?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
  }

  export type DesignCountAggregateInputType = {
    id?: true
    vendorId?: true
    name?: true
    description?: true
    price?: true
    category?: true
    imageUrl?: true
    thumbnailUrl?: true
    cloudinaryPublicId?: true
    thumbnailPublicId?: true
    fileSize?: true
    originalFileName?: true
    dimensions?: true
    format?: true
    tags?: true
    isDraft?: true
    isPublished?: true
    isPending?: true
    isValidated?: true
    validatedAt?: true
    validatedBy?: true
    rejectionReason?: true
    submittedForValidationAt?: true
    views?: true
    likes?: true
    earnings?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    _all?: true
  }

  export type DesignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Design to aggregate.
     */
    where?: DesignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designs to fetch.
     */
    orderBy?: DesignOrderByWithRelationInput | DesignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DesignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Designs
    **/
    _count?: true | DesignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DesignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DesignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DesignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DesignMaxAggregateInputType
  }

  export type GetDesignAggregateType<T extends DesignAggregateArgs> = {
        [P in keyof T & keyof AggregateDesign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDesign[P]>
      : GetScalarType<T[P], AggregateDesign[P]>
  }




  export type DesignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignWhereInput
    orderBy?: DesignOrderByWithAggregationInput | DesignOrderByWithAggregationInput[]
    by: DesignScalarFieldEnum[] | DesignScalarFieldEnum
    having?: DesignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DesignCountAggregateInputType | true
    _avg?: DesignAvgAggregateInputType
    _sum?: DesignSumAggregateInputType
    _min?: DesignMinAggregateInputType
    _max?: DesignMaxAggregateInputType
  }

  export type DesignGroupByOutputType = {
    id: number
    vendorId: number
    name: string
    description: string | null
    price: number
    category: $Enums.DesignCategory
    imageUrl: string
    thumbnailUrl: string | null
    cloudinaryPublicId: string
    thumbnailPublicId: string | null
    fileSize: number
    originalFileName: string
    dimensions: JsonValue
    format: string
    tags: string[]
    isDraft: boolean
    isPublished: boolean
    isPending: boolean
    isValidated: boolean
    validatedAt: Date | null
    validatedBy: number | null
    rejectionReason: string | null
    submittedForValidationAt: Date | null
    views: number
    likes: number
    earnings: number
    usageCount: number
    createdAt: Date
    updatedAt: Date
    publishedAt: Date | null
    _count: DesignCountAggregateOutputType | null
    _avg: DesignAvgAggregateOutputType | null
    _sum: DesignSumAggregateOutputType | null
    _min: DesignMinAggregateOutputType | null
    _max: DesignMaxAggregateOutputType | null
  }

  type GetDesignGroupByPayload<T extends DesignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DesignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DesignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DesignGroupByOutputType[P]>
            : GetScalarType<T[P], DesignGroupByOutputType[P]>
        }
      >
    >


  export type DesignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    category?: boolean
    imageUrl?: boolean
    thumbnailUrl?: boolean
    cloudinaryPublicId?: boolean
    thumbnailPublicId?: boolean
    fileSize?: boolean
    originalFileName?: boolean
    dimensions?: boolean
    format?: boolean
    tags?: boolean
    isDraft?: boolean
    isPublished?: boolean
    isPending?: boolean
    isValidated?: boolean
    validatedAt?: boolean
    validatedBy?: boolean
    rejectionReason?: boolean
    submittedForValidationAt?: boolean
    views?: boolean
    likes?: boolean
    earnings?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    validator?: boolean | Design$validatorArgs<ExtArgs>
  }, ExtArgs["result"]["design"]>

  export type DesignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    category?: boolean
    imageUrl?: boolean
    thumbnailUrl?: boolean
    cloudinaryPublicId?: boolean
    thumbnailPublicId?: boolean
    fileSize?: boolean
    originalFileName?: boolean
    dimensions?: boolean
    format?: boolean
    tags?: boolean
    isDraft?: boolean
    isPublished?: boolean
    isPending?: boolean
    isValidated?: boolean
    validatedAt?: boolean
    validatedBy?: boolean
    rejectionReason?: boolean
    submittedForValidationAt?: boolean
    views?: boolean
    likes?: boolean
    earnings?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    validator?: boolean | Design$validatorArgs<ExtArgs>
  }, ExtArgs["result"]["design"]>

  export type DesignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    category?: boolean
    imageUrl?: boolean
    thumbnailUrl?: boolean
    cloudinaryPublicId?: boolean
    thumbnailPublicId?: boolean
    fileSize?: boolean
    originalFileName?: boolean
    dimensions?: boolean
    format?: boolean
    tags?: boolean
    isDraft?: boolean
    isPublished?: boolean
    isPending?: boolean
    isValidated?: boolean
    validatedAt?: boolean
    validatedBy?: boolean
    rejectionReason?: boolean
    submittedForValidationAt?: boolean
    views?: boolean
    likes?: boolean
    earnings?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    validator?: boolean | Design$validatorArgs<ExtArgs>
  }, ExtArgs["result"]["design"]>

  export type DesignSelectScalar = {
    id?: boolean
    vendorId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    category?: boolean
    imageUrl?: boolean
    thumbnailUrl?: boolean
    cloudinaryPublicId?: boolean
    thumbnailPublicId?: boolean
    fileSize?: boolean
    originalFileName?: boolean
    dimensions?: boolean
    format?: boolean
    tags?: boolean
    isDraft?: boolean
    isPublished?: boolean
    isPending?: boolean
    isValidated?: boolean
    validatedAt?: boolean
    validatedBy?: boolean
    rejectionReason?: boolean
    submittedForValidationAt?: boolean
    views?: boolean
    likes?: boolean
    earnings?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
  }

  export type DesignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendorId" | "name" | "description" | "price" | "category" | "imageUrl" | "thumbnailUrl" | "cloudinaryPublicId" | "thumbnailPublicId" | "fileSize" | "originalFileName" | "dimensions" | "format" | "tags" | "isDraft" | "isPublished" | "isPending" | "isValidated" | "validatedAt" | "validatedBy" | "rejectionReason" | "submittedForValidationAt" | "views" | "likes" | "earnings" | "usageCount" | "createdAt" | "updatedAt" | "publishedAt", ExtArgs["result"]["design"]>
  export type DesignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    validator?: boolean | Design$validatorArgs<ExtArgs>
  }
  export type DesignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    validator?: boolean | Design$validatorArgs<ExtArgs>
  }
  export type DesignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    validator?: boolean | Design$validatorArgs<ExtArgs>
  }

  export type $DesignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Design"
    objects: {
      vendor: Prisma.$UserPayload<ExtArgs>
      validator: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      vendorId: number
      name: string
      description: string | null
      price: number
      category: $Enums.DesignCategory
      imageUrl: string
      thumbnailUrl: string | null
      cloudinaryPublicId: string
      thumbnailPublicId: string | null
      fileSize: number
      originalFileName: string
      dimensions: Prisma.JsonValue
      format: string
      tags: string[]
      isDraft: boolean
      isPublished: boolean
      isPending: boolean
      isValidated: boolean
      validatedAt: Date | null
      validatedBy: number | null
      rejectionReason: string | null
      submittedForValidationAt: Date | null
      views: number
      likes: number
      earnings: number
      usageCount: number
      createdAt: Date
      updatedAt: Date
      publishedAt: Date | null
    }, ExtArgs["result"]["design"]>
    composites: {}
  }

  type DesignGetPayload<S extends boolean | null | undefined | DesignDefaultArgs> = $Result.GetResult<Prisma.$DesignPayload, S>

  type DesignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DesignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DesignCountAggregateInputType | true
    }

  export interface DesignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Design'], meta: { name: 'Design' } }
    /**
     * Find zero or one Design that matches the filter.
     * @param {DesignFindUniqueArgs} args - Arguments to find a Design
     * @example
     * // Get one Design
     * const design = await prisma.design.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DesignFindUniqueArgs>(args: SelectSubset<T, DesignFindUniqueArgs<ExtArgs>>): Prisma__DesignClient<$Result.GetResult<Prisma.$DesignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Design that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DesignFindUniqueOrThrowArgs} args - Arguments to find a Design
     * @example
     * // Get one Design
     * const design = await prisma.design.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DesignFindUniqueOrThrowArgs>(args: SelectSubset<T, DesignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DesignClient<$Result.GetResult<Prisma.$DesignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Design that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignFindFirstArgs} args - Arguments to find a Design
     * @example
     * // Get one Design
     * const design = await prisma.design.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DesignFindFirstArgs>(args?: SelectSubset<T, DesignFindFirstArgs<ExtArgs>>): Prisma__DesignClient<$Result.GetResult<Prisma.$DesignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Design that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignFindFirstOrThrowArgs} args - Arguments to find a Design
     * @example
     * // Get one Design
     * const design = await prisma.design.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DesignFindFirstOrThrowArgs>(args?: SelectSubset<T, DesignFindFirstOrThrowArgs<ExtArgs>>): Prisma__DesignClient<$Result.GetResult<Prisma.$DesignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Designs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Designs
     * const designs = await prisma.design.findMany()
     * 
     * // Get first 10 Designs
     * const designs = await prisma.design.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const designWithIdOnly = await prisma.design.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DesignFindManyArgs>(args?: SelectSubset<T, DesignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Design.
     * @param {DesignCreateArgs} args - Arguments to create a Design.
     * @example
     * // Create one Design
     * const Design = await prisma.design.create({
     *   data: {
     *     // ... data to create a Design
     *   }
     * })
     * 
     */
    create<T extends DesignCreateArgs>(args: SelectSubset<T, DesignCreateArgs<ExtArgs>>): Prisma__DesignClient<$Result.GetResult<Prisma.$DesignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Designs.
     * @param {DesignCreateManyArgs} args - Arguments to create many Designs.
     * @example
     * // Create many Designs
     * const design = await prisma.design.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DesignCreateManyArgs>(args?: SelectSubset<T, DesignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Designs and returns the data saved in the database.
     * @param {DesignCreateManyAndReturnArgs} args - Arguments to create many Designs.
     * @example
     * // Create many Designs
     * const design = await prisma.design.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Designs and only return the `id`
     * const designWithIdOnly = await prisma.design.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DesignCreateManyAndReturnArgs>(args?: SelectSubset<T, DesignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Design.
     * @param {DesignDeleteArgs} args - Arguments to delete one Design.
     * @example
     * // Delete one Design
     * const Design = await prisma.design.delete({
     *   where: {
     *     // ... filter to delete one Design
     *   }
     * })
     * 
     */
    delete<T extends DesignDeleteArgs>(args: SelectSubset<T, DesignDeleteArgs<ExtArgs>>): Prisma__DesignClient<$Result.GetResult<Prisma.$DesignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Design.
     * @param {DesignUpdateArgs} args - Arguments to update one Design.
     * @example
     * // Update one Design
     * const design = await prisma.design.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DesignUpdateArgs>(args: SelectSubset<T, DesignUpdateArgs<ExtArgs>>): Prisma__DesignClient<$Result.GetResult<Prisma.$DesignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Designs.
     * @param {DesignDeleteManyArgs} args - Arguments to filter Designs to delete.
     * @example
     * // Delete a few Designs
     * const { count } = await prisma.design.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DesignDeleteManyArgs>(args?: SelectSubset<T, DesignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Designs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Designs
     * const design = await prisma.design.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DesignUpdateManyArgs>(args: SelectSubset<T, DesignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Designs and returns the data updated in the database.
     * @param {DesignUpdateManyAndReturnArgs} args - Arguments to update many Designs.
     * @example
     * // Update many Designs
     * const design = await prisma.design.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Designs and only return the `id`
     * const designWithIdOnly = await prisma.design.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DesignUpdateManyAndReturnArgs>(args: SelectSubset<T, DesignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Design.
     * @param {DesignUpsertArgs} args - Arguments to update or create a Design.
     * @example
     * // Update or create a Design
     * const design = await prisma.design.upsert({
     *   create: {
     *     // ... data to create a Design
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Design we want to update
     *   }
     * })
     */
    upsert<T extends DesignUpsertArgs>(args: SelectSubset<T, DesignUpsertArgs<ExtArgs>>): Prisma__DesignClient<$Result.GetResult<Prisma.$DesignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Designs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignCountArgs} args - Arguments to filter Designs to count.
     * @example
     * // Count the number of Designs
     * const count = await prisma.design.count({
     *   where: {
     *     // ... the filter for the Designs we want to count
     *   }
     * })
    **/
    count<T extends DesignCountArgs>(
      args?: Subset<T, DesignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DesignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Design.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DesignAggregateArgs>(args: Subset<T, DesignAggregateArgs>): Prisma.PrismaPromise<GetDesignAggregateType<T>>

    /**
     * Group by Design.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DesignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DesignGroupByArgs['orderBy'] }
        : { orderBy?: DesignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DesignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDesignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Design model
   */
  readonly fields: DesignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Design.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DesignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    validator<T extends Design$validatorArgs<ExtArgs> = {}>(args?: Subset<T, Design$validatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Design model
   */
  interface DesignFieldRefs {
    readonly id: FieldRef<"Design", 'Int'>
    readonly vendorId: FieldRef<"Design", 'Int'>
    readonly name: FieldRef<"Design", 'String'>
    readonly description: FieldRef<"Design", 'String'>
    readonly price: FieldRef<"Design", 'Float'>
    readonly category: FieldRef<"Design", 'DesignCategory'>
    readonly imageUrl: FieldRef<"Design", 'String'>
    readonly thumbnailUrl: FieldRef<"Design", 'String'>
    readonly cloudinaryPublicId: FieldRef<"Design", 'String'>
    readonly thumbnailPublicId: FieldRef<"Design", 'String'>
    readonly fileSize: FieldRef<"Design", 'Int'>
    readonly originalFileName: FieldRef<"Design", 'String'>
    readonly dimensions: FieldRef<"Design", 'Json'>
    readonly format: FieldRef<"Design", 'String'>
    readonly tags: FieldRef<"Design", 'String[]'>
    readonly isDraft: FieldRef<"Design", 'Boolean'>
    readonly isPublished: FieldRef<"Design", 'Boolean'>
    readonly isPending: FieldRef<"Design", 'Boolean'>
    readonly isValidated: FieldRef<"Design", 'Boolean'>
    readonly validatedAt: FieldRef<"Design", 'DateTime'>
    readonly validatedBy: FieldRef<"Design", 'Int'>
    readonly rejectionReason: FieldRef<"Design", 'String'>
    readonly submittedForValidationAt: FieldRef<"Design", 'DateTime'>
    readonly views: FieldRef<"Design", 'Int'>
    readonly likes: FieldRef<"Design", 'Int'>
    readonly earnings: FieldRef<"Design", 'Float'>
    readonly usageCount: FieldRef<"Design", 'Int'>
    readonly createdAt: FieldRef<"Design", 'DateTime'>
    readonly updatedAt: FieldRef<"Design", 'DateTime'>
    readonly publishedAt: FieldRef<"Design", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Design findUnique
   */
  export type DesignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Design
     */
    select?: DesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Design
     */
    omit?: DesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignInclude<ExtArgs> | null
    /**
     * Filter, which Design to fetch.
     */
    where: DesignWhereUniqueInput
  }

  /**
   * Design findUniqueOrThrow
   */
  export type DesignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Design
     */
    select?: DesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Design
     */
    omit?: DesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignInclude<ExtArgs> | null
    /**
     * Filter, which Design to fetch.
     */
    where: DesignWhereUniqueInput
  }

  /**
   * Design findFirst
   */
  export type DesignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Design
     */
    select?: DesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Design
     */
    omit?: DesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignInclude<ExtArgs> | null
    /**
     * Filter, which Design to fetch.
     */
    where?: DesignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designs to fetch.
     */
    orderBy?: DesignOrderByWithRelationInput | DesignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Designs.
     */
    cursor?: DesignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Designs.
     */
    distinct?: DesignScalarFieldEnum | DesignScalarFieldEnum[]
  }

  /**
   * Design findFirstOrThrow
   */
  export type DesignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Design
     */
    select?: DesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Design
     */
    omit?: DesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignInclude<ExtArgs> | null
    /**
     * Filter, which Design to fetch.
     */
    where?: DesignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designs to fetch.
     */
    orderBy?: DesignOrderByWithRelationInput | DesignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Designs.
     */
    cursor?: DesignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Designs.
     */
    distinct?: DesignScalarFieldEnum | DesignScalarFieldEnum[]
  }

  /**
   * Design findMany
   */
  export type DesignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Design
     */
    select?: DesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Design
     */
    omit?: DesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignInclude<ExtArgs> | null
    /**
     * Filter, which Designs to fetch.
     */
    where?: DesignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designs to fetch.
     */
    orderBy?: DesignOrderByWithRelationInput | DesignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Designs.
     */
    cursor?: DesignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designs.
     */
    skip?: number
    distinct?: DesignScalarFieldEnum | DesignScalarFieldEnum[]
  }

  /**
   * Design create
   */
  export type DesignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Design
     */
    select?: DesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Design
     */
    omit?: DesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignInclude<ExtArgs> | null
    /**
     * The data needed to create a Design.
     */
    data: XOR<DesignCreateInput, DesignUncheckedCreateInput>
  }

  /**
   * Design createMany
   */
  export type DesignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Designs.
     */
    data: DesignCreateManyInput | DesignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Design createManyAndReturn
   */
  export type DesignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Design
     */
    select?: DesignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Design
     */
    omit?: DesignOmit<ExtArgs> | null
    /**
     * The data used to create many Designs.
     */
    data: DesignCreateManyInput | DesignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Design update
   */
  export type DesignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Design
     */
    select?: DesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Design
     */
    omit?: DesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignInclude<ExtArgs> | null
    /**
     * The data needed to update a Design.
     */
    data: XOR<DesignUpdateInput, DesignUncheckedUpdateInput>
    /**
     * Choose, which Design to update.
     */
    where: DesignWhereUniqueInput
  }

  /**
   * Design updateMany
   */
  export type DesignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Designs.
     */
    data: XOR<DesignUpdateManyMutationInput, DesignUncheckedUpdateManyInput>
    /**
     * Filter which Designs to update
     */
    where?: DesignWhereInput
    /**
     * Limit how many Designs to update.
     */
    limit?: number
  }

  /**
   * Design updateManyAndReturn
   */
  export type DesignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Design
     */
    select?: DesignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Design
     */
    omit?: DesignOmit<ExtArgs> | null
    /**
     * The data used to update Designs.
     */
    data: XOR<DesignUpdateManyMutationInput, DesignUncheckedUpdateManyInput>
    /**
     * Filter which Designs to update
     */
    where?: DesignWhereInput
    /**
     * Limit how many Designs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Design upsert
   */
  export type DesignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Design
     */
    select?: DesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Design
     */
    omit?: DesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignInclude<ExtArgs> | null
    /**
     * The filter to search for the Design to update in case it exists.
     */
    where: DesignWhereUniqueInput
    /**
     * In case the Design found by the `where` argument doesn't exist, create a new Design with this data.
     */
    create: XOR<DesignCreateInput, DesignUncheckedCreateInput>
    /**
     * In case the Design was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DesignUpdateInput, DesignUncheckedUpdateInput>
  }

  /**
   * Design delete
   */
  export type DesignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Design
     */
    select?: DesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Design
     */
    omit?: DesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignInclude<ExtArgs> | null
    /**
     * Filter which Design to delete.
     */
    where: DesignWhereUniqueInput
  }

  /**
   * Design deleteMany
   */
  export type DesignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Designs to delete
     */
    where?: DesignWhereInput
    /**
     * Limit how many Designs to delete.
     */
    limit?: number
  }

  /**
   * Design.validator
   */
  export type Design$validatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Design without action
   */
  export type DesignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Design
     */
    select?: DesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Design
     */
    omit?: DesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignInclude<ExtArgs> | null
  }


  /**
   * Model VendorProduct
   */

  export type AggregateVendorProduct = {
    _count: VendorProductCountAggregateOutputType | null
    _avg: VendorProductAvgAggregateOutputType | null
    _sum: VendorProductSumAggregateOutputType | null
    _min: VendorProductMinAggregateOutputType | null
    _max: VendorProductMaxAggregateOutputType | null
  }

  export type VendorProductAvgAggregateOutputType = {
    id: number | null
    baseProductId: number | null
    vendorId: number | null
    price: number | null
    stock: number | null
    adminProductPrice: number | null
    designScale: number | null
    vendorStock: number | null
    basePriceAdmin: number | null
    validatedBy: number | null
  }

  export type VendorProductSumAggregateOutputType = {
    id: number | null
    baseProductId: number | null
    vendorId: number | null
    price: number | null
    stock: number | null
    adminProductPrice: number | null
    designScale: number | null
    vendorStock: number | null
    basePriceAdmin: number | null
    validatedBy: number | null
  }

  export type VendorProductMinAggregateOutputType = {
    id: number | null
    baseProductId: number | null
    vendorId: number | null
    name: string | null
    description: string | null
    price: number | null
    stock: number | null
    status: $Enums.VendorProductStatus | null
    adminProductName: string | null
    adminProductDescription: string | null
    adminProductPrice: number | null
    designBase64: string | null
    designCloudinaryUrl: string | null
    designCloudinaryPublicId: string | null
    designPositioning: string | null
    designScale: number | null
    designApplicationMode: string | null
    vendorName: string | null
    vendorDescription: string | null
    vendorStock: number | null
    basePriceAdmin: number | null
    isValidated: boolean | null
    validatedAt: Date | null
    validatedBy: number | null
    rejectionReason: string | null
    submittedForValidationAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorProductMaxAggregateOutputType = {
    id: number | null
    baseProductId: number | null
    vendorId: number | null
    name: string | null
    description: string | null
    price: number | null
    stock: number | null
    status: $Enums.VendorProductStatus | null
    adminProductName: string | null
    adminProductDescription: string | null
    adminProductPrice: number | null
    designBase64: string | null
    designCloudinaryUrl: string | null
    designCloudinaryPublicId: string | null
    designPositioning: string | null
    designScale: number | null
    designApplicationMode: string | null
    vendorName: string | null
    vendorDescription: string | null
    vendorStock: number | null
    basePriceAdmin: number | null
    isValidated: boolean | null
    validatedAt: Date | null
    validatedBy: number | null
    rejectionReason: string | null
    submittedForValidationAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorProductCountAggregateOutputType = {
    id: number
    baseProductId: number
    vendorId: number
    name: number
    description: number
    price: number
    stock: number
    status: number
    adminProductName: number
    adminProductDescription: number
    adminProductPrice: number
    designBase64: number
    designCloudinaryUrl: number
    designCloudinaryPublicId: number
    designPositioning: number
    designScale: number
    designApplicationMode: number
    sizes: number
    colors: number
    vendorName: number
    vendorDescription: number
    vendorStock: number
    basePriceAdmin: number
    isValidated: number
    validatedAt: number
    validatedBy: number
    rejectionReason: number
    submittedForValidationAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorProductAvgAggregateInputType = {
    id?: true
    baseProductId?: true
    vendorId?: true
    price?: true
    stock?: true
    adminProductPrice?: true
    designScale?: true
    vendorStock?: true
    basePriceAdmin?: true
    validatedBy?: true
  }

  export type VendorProductSumAggregateInputType = {
    id?: true
    baseProductId?: true
    vendorId?: true
    price?: true
    stock?: true
    adminProductPrice?: true
    designScale?: true
    vendorStock?: true
    basePriceAdmin?: true
    validatedBy?: true
  }

  export type VendorProductMinAggregateInputType = {
    id?: true
    baseProductId?: true
    vendorId?: true
    name?: true
    description?: true
    price?: true
    stock?: true
    status?: true
    adminProductName?: true
    adminProductDescription?: true
    adminProductPrice?: true
    designBase64?: true
    designCloudinaryUrl?: true
    designCloudinaryPublicId?: true
    designPositioning?: true
    designScale?: true
    designApplicationMode?: true
    vendorName?: true
    vendorDescription?: true
    vendorStock?: true
    basePriceAdmin?: true
    isValidated?: true
    validatedAt?: true
    validatedBy?: true
    rejectionReason?: true
    submittedForValidationAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorProductMaxAggregateInputType = {
    id?: true
    baseProductId?: true
    vendorId?: true
    name?: true
    description?: true
    price?: true
    stock?: true
    status?: true
    adminProductName?: true
    adminProductDescription?: true
    adminProductPrice?: true
    designBase64?: true
    designCloudinaryUrl?: true
    designCloudinaryPublicId?: true
    designPositioning?: true
    designScale?: true
    designApplicationMode?: true
    vendorName?: true
    vendorDescription?: true
    vendorStock?: true
    basePriceAdmin?: true
    isValidated?: true
    validatedAt?: true
    validatedBy?: true
    rejectionReason?: true
    submittedForValidationAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorProductCountAggregateInputType = {
    id?: true
    baseProductId?: true
    vendorId?: true
    name?: true
    description?: true
    price?: true
    stock?: true
    status?: true
    adminProductName?: true
    adminProductDescription?: true
    adminProductPrice?: true
    designBase64?: true
    designCloudinaryUrl?: true
    designCloudinaryPublicId?: true
    designPositioning?: true
    designScale?: true
    designApplicationMode?: true
    sizes?: true
    colors?: true
    vendorName?: true
    vendorDescription?: true
    vendorStock?: true
    basePriceAdmin?: true
    isValidated?: true
    validatedAt?: true
    validatedBy?: true
    rejectionReason?: true
    submittedForValidationAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorProduct to aggregate.
     */
    where?: VendorProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorProducts to fetch.
     */
    orderBy?: VendorProductOrderByWithRelationInput | VendorProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorProducts
    **/
    _count?: true | VendorProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorProductMaxAggregateInputType
  }

  export type GetVendorProductAggregateType<T extends VendorProductAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorProduct[P]>
      : GetScalarType<T[P], AggregateVendorProduct[P]>
  }




  export type VendorProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorProductWhereInput
    orderBy?: VendorProductOrderByWithAggregationInput | VendorProductOrderByWithAggregationInput[]
    by: VendorProductScalarFieldEnum[] | VendorProductScalarFieldEnum
    having?: VendorProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorProductCountAggregateInputType | true
    _avg?: VendorProductAvgAggregateInputType
    _sum?: VendorProductSumAggregateInputType
    _min?: VendorProductMinAggregateInputType
    _max?: VendorProductMaxAggregateInputType
  }

  export type VendorProductGroupByOutputType = {
    id: number
    baseProductId: number
    vendorId: number
    name: string
    description: string | null
    price: number
    stock: number
    status: $Enums.VendorProductStatus
    adminProductName: string | null
    adminProductDescription: string | null
    adminProductPrice: number | null
    designBase64: string | null
    designCloudinaryUrl: string | null
    designCloudinaryPublicId: string | null
    designPositioning: string | null
    designScale: number | null
    designApplicationMode: string | null
    sizes: JsonValue
    colors: JsonValue
    vendorName: string | null
    vendorDescription: string | null
    vendorStock: number
    basePriceAdmin: number
    isValidated: boolean
    validatedAt: Date | null
    validatedBy: number | null
    rejectionReason: string | null
    submittedForValidationAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: VendorProductCountAggregateOutputType | null
    _avg: VendorProductAvgAggregateOutputType | null
    _sum: VendorProductSumAggregateOutputType | null
    _min: VendorProductMinAggregateOutputType | null
    _max: VendorProductMaxAggregateOutputType | null
  }

  type GetVendorProductGroupByPayload<T extends VendorProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorProductGroupByOutputType[P]>
            : GetScalarType<T[P], VendorProductGroupByOutputType[P]>
        }
      >
    >


  export type VendorProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    baseProductId?: boolean
    vendorId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    status?: boolean
    adminProductName?: boolean
    adminProductDescription?: boolean
    adminProductPrice?: boolean
    designBase64?: boolean
    designCloudinaryUrl?: boolean
    designCloudinaryPublicId?: boolean
    designPositioning?: boolean
    designScale?: boolean
    designApplicationMode?: boolean
    sizes?: boolean
    colors?: boolean
    vendorName?: boolean
    vendorDescription?: boolean
    vendorStock?: boolean
    basePriceAdmin?: boolean
    isValidated?: boolean
    validatedAt?: boolean
    validatedBy?: boolean
    rejectionReason?: boolean
    submittedForValidationAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    validator?: boolean | VendorProduct$validatorArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    baseProduct?: boolean | ProductDefaultArgs<ExtArgs>
    images?: boolean | VendorProduct$imagesArgs<ExtArgs>
    transformations?: boolean | VendorProduct$transformationsArgs<ExtArgs>
    _count?: boolean | VendorProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorProduct"]>

  export type VendorProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    baseProductId?: boolean
    vendorId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    status?: boolean
    adminProductName?: boolean
    adminProductDescription?: boolean
    adminProductPrice?: boolean
    designBase64?: boolean
    designCloudinaryUrl?: boolean
    designCloudinaryPublicId?: boolean
    designPositioning?: boolean
    designScale?: boolean
    designApplicationMode?: boolean
    sizes?: boolean
    colors?: boolean
    vendorName?: boolean
    vendorDescription?: boolean
    vendorStock?: boolean
    basePriceAdmin?: boolean
    isValidated?: boolean
    validatedAt?: boolean
    validatedBy?: boolean
    rejectionReason?: boolean
    submittedForValidationAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    validator?: boolean | VendorProduct$validatorArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    baseProduct?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorProduct"]>

  export type VendorProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    baseProductId?: boolean
    vendorId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    status?: boolean
    adminProductName?: boolean
    adminProductDescription?: boolean
    adminProductPrice?: boolean
    designBase64?: boolean
    designCloudinaryUrl?: boolean
    designCloudinaryPublicId?: boolean
    designPositioning?: boolean
    designScale?: boolean
    designApplicationMode?: boolean
    sizes?: boolean
    colors?: boolean
    vendorName?: boolean
    vendorDescription?: boolean
    vendorStock?: boolean
    basePriceAdmin?: boolean
    isValidated?: boolean
    validatedAt?: boolean
    validatedBy?: boolean
    rejectionReason?: boolean
    submittedForValidationAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    validator?: boolean | VendorProduct$validatorArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    baseProduct?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorProduct"]>

  export type VendorProductSelectScalar = {
    id?: boolean
    baseProductId?: boolean
    vendorId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    status?: boolean
    adminProductName?: boolean
    adminProductDescription?: boolean
    adminProductPrice?: boolean
    designBase64?: boolean
    designCloudinaryUrl?: boolean
    designCloudinaryPublicId?: boolean
    designPositioning?: boolean
    designScale?: boolean
    designApplicationMode?: boolean
    sizes?: boolean
    colors?: boolean
    vendorName?: boolean
    vendorDescription?: boolean
    vendorStock?: boolean
    basePriceAdmin?: boolean
    isValidated?: boolean
    validatedAt?: boolean
    validatedBy?: boolean
    rejectionReason?: boolean
    submittedForValidationAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VendorProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "baseProductId" | "vendorId" | "name" | "description" | "price" | "stock" | "status" | "adminProductName" | "adminProductDescription" | "adminProductPrice" | "designBase64" | "designCloudinaryUrl" | "designCloudinaryPublicId" | "designPositioning" | "designScale" | "designApplicationMode" | "sizes" | "colors" | "vendorName" | "vendorDescription" | "vendorStock" | "basePriceAdmin" | "isValidated" | "validatedAt" | "validatedBy" | "rejectionReason" | "submittedForValidationAt" | "createdAt" | "updatedAt", ExtArgs["result"]["vendorProduct"]>
  export type VendorProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    validator?: boolean | VendorProduct$validatorArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    baseProduct?: boolean | ProductDefaultArgs<ExtArgs>
    images?: boolean | VendorProduct$imagesArgs<ExtArgs>
    transformations?: boolean | VendorProduct$transformationsArgs<ExtArgs>
    _count?: boolean | VendorProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VendorProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    validator?: boolean | VendorProduct$validatorArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    baseProduct?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type VendorProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    validator?: boolean | VendorProduct$validatorArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    baseProduct?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $VendorProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorProduct"
    objects: {
      validator: Prisma.$UserPayload<ExtArgs> | null
      vendor: Prisma.$UserPayload<ExtArgs>
      baseProduct: Prisma.$ProductPayload<ExtArgs>
      images: Prisma.$VendorProductImagePayload<ExtArgs>[]
      transformations: Prisma.$DesignTransformationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      baseProductId: number
      vendorId: number
      name: string
      description: string | null
      price: number
      stock: number
      status: $Enums.VendorProductStatus
      adminProductName: string | null
      adminProductDescription: string | null
      adminProductPrice: number | null
      designBase64: string | null
      designCloudinaryUrl: string | null
      designCloudinaryPublicId: string | null
      designPositioning: string | null
      designScale: number | null
      designApplicationMode: string | null
      sizes: Prisma.JsonValue
      colors: Prisma.JsonValue
      vendorName: string | null
      vendorDescription: string | null
      vendorStock: number
      basePriceAdmin: number
      isValidated: boolean
      validatedAt: Date | null
      validatedBy: number | null
      rejectionReason: string | null
      submittedForValidationAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vendorProduct"]>
    composites: {}
  }

  type VendorProductGetPayload<S extends boolean | null | undefined | VendorProductDefaultArgs> = $Result.GetResult<Prisma.$VendorProductPayload, S>

  type VendorProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorProductCountAggregateInputType | true
    }

  export interface VendorProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorProduct'], meta: { name: 'VendorProduct' } }
    /**
     * Find zero or one VendorProduct that matches the filter.
     * @param {VendorProductFindUniqueArgs} args - Arguments to find a VendorProduct
     * @example
     * // Get one VendorProduct
     * const vendorProduct = await prisma.vendorProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorProductFindUniqueArgs>(args: SelectSubset<T, VendorProductFindUniqueArgs<ExtArgs>>): Prisma__VendorProductClient<$Result.GetResult<Prisma.$VendorProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorProductFindUniqueOrThrowArgs} args - Arguments to find a VendorProduct
     * @example
     * // Get one VendorProduct
     * const vendorProduct = await prisma.vendorProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorProductFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorProductClient<$Result.GetResult<Prisma.$VendorProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProductFindFirstArgs} args - Arguments to find a VendorProduct
     * @example
     * // Get one VendorProduct
     * const vendorProduct = await prisma.vendorProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorProductFindFirstArgs>(args?: SelectSubset<T, VendorProductFindFirstArgs<ExtArgs>>): Prisma__VendorProductClient<$Result.GetResult<Prisma.$VendorProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProductFindFirstOrThrowArgs} args - Arguments to find a VendorProduct
     * @example
     * // Get one VendorProduct
     * const vendorProduct = await prisma.vendorProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorProductFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorProductClient<$Result.GetResult<Prisma.$VendorProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorProducts
     * const vendorProducts = await prisma.vendorProduct.findMany()
     * 
     * // Get first 10 VendorProducts
     * const vendorProducts = await prisma.vendorProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorProductWithIdOnly = await prisma.vendorProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorProductFindManyArgs>(args?: SelectSubset<T, VendorProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorProduct.
     * @param {VendorProductCreateArgs} args - Arguments to create a VendorProduct.
     * @example
     * // Create one VendorProduct
     * const VendorProduct = await prisma.vendorProduct.create({
     *   data: {
     *     // ... data to create a VendorProduct
     *   }
     * })
     * 
     */
    create<T extends VendorProductCreateArgs>(args: SelectSubset<T, VendorProductCreateArgs<ExtArgs>>): Prisma__VendorProductClient<$Result.GetResult<Prisma.$VendorProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorProducts.
     * @param {VendorProductCreateManyArgs} args - Arguments to create many VendorProducts.
     * @example
     * // Create many VendorProducts
     * const vendorProduct = await prisma.vendorProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorProductCreateManyArgs>(args?: SelectSubset<T, VendorProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorProducts and returns the data saved in the database.
     * @param {VendorProductCreateManyAndReturnArgs} args - Arguments to create many VendorProducts.
     * @example
     * // Create many VendorProducts
     * const vendorProduct = await prisma.vendorProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorProducts and only return the `id`
     * const vendorProductWithIdOnly = await prisma.vendorProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorProductCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorProduct.
     * @param {VendorProductDeleteArgs} args - Arguments to delete one VendorProduct.
     * @example
     * // Delete one VendorProduct
     * const VendorProduct = await prisma.vendorProduct.delete({
     *   where: {
     *     // ... filter to delete one VendorProduct
     *   }
     * })
     * 
     */
    delete<T extends VendorProductDeleteArgs>(args: SelectSubset<T, VendorProductDeleteArgs<ExtArgs>>): Prisma__VendorProductClient<$Result.GetResult<Prisma.$VendorProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorProduct.
     * @param {VendorProductUpdateArgs} args - Arguments to update one VendorProduct.
     * @example
     * // Update one VendorProduct
     * const vendorProduct = await prisma.vendorProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorProductUpdateArgs>(args: SelectSubset<T, VendorProductUpdateArgs<ExtArgs>>): Prisma__VendorProductClient<$Result.GetResult<Prisma.$VendorProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorProducts.
     * @param {VendorProductDeleteManyArgs} args - Arguments to filter VendorProducts to delete.
     * @example
     * // Delete a few VendorProducts
     * const { count } = await prisma.vendorProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorProductDeleteManyArgs>(args?: SelectSubset<T, VendorProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorProducts
     * const vendorProduct = await prisma.vendorProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorProductUpdateManyArgs>(args: SelectSubset<T, VendorProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorProducts and returns the data updated in the database.
     * @param {VendorProductUpdateManyAndReturnArgs} args - Arguments to update many VendorProducts.
     * @example
     * // Update many VendorProducts
     * const vendorProduct = await prisma.vendorProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorProducts and only return the `id`
     * const vendorProductWithIdOnly = await prisma.vendorProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorProductUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorProduct.
     * @param {VendorProductUpsertArgs} args - Arguments to update or create a VendorProduct.
     * @example
     * // Update or create a VendorProduct
     * const vendorProduct = await prisma.vendorProduct.upsert({
     *   create: {
     *     // ... data to create a VendorProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorProduct we want to update
     *   }
     * })
     */
    upsert<T extends VendorProductUpsertArgs>(args: SelectSubset<T, VendorProductUpsertArgs<ExtArgs>>): Prisma__VendorProductClient<$Result.GetResult<Prisma.$VendorProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProductCountArgs} args - Arguments to filter VendorProducts to count.
     * @example
     * // Count the number of VendorProducts
     * const count = await prisma.vendorProduct.count({
     *   where: {
     *     // ... the filter for the VendorProducts we want to count
     *   }
     * })
    **/
    count<T extends VendorProductCountArgs>(
      args?: Subset<T, VendorProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorProductAggregateArgs>(args: Subset<T, VendorProductAggregateArgs>): Prisma.PrismaPromise<GetVendorProductAggregateType<T>>

    /**
     * Group by VendorProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorProductGroupByArgs['orderBy'] }
        : { orderBy?: VendorProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorProduct model
   */
  readonly fields: VendorProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    validator<T extends VendorProduct$validatorArgs<ExtArgs> = {}>(args?: Subset<T, VendorProduct$validatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vendor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    baseProduct<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    images<T extends VendorProduct$imagesArgs<ExtArgs> = {}>(args?: Subset<T, VendorProduct$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorProductImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transformations<T extends VendorProduct$transformationsArgs<ExtArgs> = {}>(args?: Subset<T, VendorProduct$transformationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignTransformationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorProduct model
   */
  interface VendorProductFieldRefs {
    readonly id: FieldRef<"VendorProduct", 'Int'>
    readonly baseProductId: FieldRef<"VendorProduct", 'Int'>
    readonly vendorId: FieldRef<"VendorProduct", 'Int'>
    readonly name: FieldRef<"VendorProduct", 'String'>
    readonly description: FieldRef<"VendorProduct", 'String'>
    readonly price: FieldRef<"VendorProduct", 'Int'>
    readonly stock: FieldRef<"VendorProduct", 'Int'>
    readonly status: FieldRef<"VendorProduct", 'VendorProductStatus'>
    readonly adminProductName: FieldRef<"VendorProduct", 'String'>
    readonly adminProductDescription: FieldRef<"VendorProduct", 'String'>
    readonly adminProductPrice: FieldRef<"VendorProduct", 'Int'>
    readonly designBase64: FieldRef<"VendorProduct", 'String'>
    readonly designCloudinaryUrl: FieldRef<"VendorProduct", 'String'>
    readonly designCloudinaryPublicId: FieldRef<"VendorProduct", 'String'>
    readonly designPositioning: FieldRef<"VendorProduct", 'String'>
    readonly designScale: FieldRef<"VendorProduct", 'Float'>
    readonly designApplicationMode: FieldRef<"VendorProduct", 'String'>
    readonly sizes: FieldRef<"VendorProduct", 'Json'>
    readonly colors: FieldRef<"VendorProduct", 'Json'>
    readonly vendorName: FieldRef<"VendorProduct", 'String'>
    readonly vendorDescription: FieldRef<"VendorProduct", 'String'>
    readonly vendorStock: FieldRef<"VendorProduct", 'Int'>
    readonly basePriceAdmin: FieldRef<"VendorProduct", 'Float'>
    readonly isValidated: FieldRef<"VendorProduct", 'Boolean'>
    readonly validatedAt: FieldRef<"VendorProduct", 'DateTime'>
    readonly validatedBy: FieldRef<"VendorProduct", 'Int'>
    readonly rejectionReason: FieldRef<"VendorProduct", 'String'>
    readonly submittedForValidationAt: FieldRef<"VendorProduct", 'DateTime'>
    readonly createdAt: FieldRef<"VendorProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"VendorProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorProduct findUnique
   */
  export type VendorProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProduct
     */
    select?: VendorProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProduct
     */
    omit?: VendorProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductInclude<ExtArgs> | null
    /**
     * Filter, which VendorProduct to fetch.
     */
    where: VendorProductWhereUniqueInput
  }

  /**
   * VendorProduct findUniqueOrThrow
   */
  export type VendorProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProduct
     */
    select?: VendorProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProduct
     */
    omit?: VendorProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductInclude<ExtArgs> | null
    /**
     * Filter, which VendorProduct to fetch.
     */
    where: VendorProductWhereUniqueInput
  }

  /**
   * VendorProduct findFirst
   */
  export type VendorProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProduct
     */
    select?: VendorProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProduct
     */
    omit?: VendorProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductInclude<ExtArgs> | null
    /**
     * Filter, which VendorProduct to fetch.
     */
    where?: VendorProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorProducts to fetch.
     */
    orderBy?: VendorProductOrderByWithRelationInput | VendorProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorProducts.
     */
    cursor?: VendorProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorProducts.
     */
    distinct?: VendorProductScalarFieldEnum | VendorProductScalarFieldEnum[]
  }

  /**
   * VendorProduct findFirstOrThrow
   */
  export type VendorProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProduct
     */
    select?: VendorProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProduct
     */
    omit?: VendorProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductInclude<ExtArgs> | null
    /**
     * Filter, which VendorProduct to fetch.
     */
    where?: VendorProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorProducts to fetch.
     */
    orderBy?: VendorProductOrderByWithRelationInput | VendorProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorProducts.
     */
    cursor?: VendorProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorProducts.
     */
    distinct?: VendorProductScalarFieldEnum | VendorProductScalarFieldEnum[]
  }

  /**
   * VendorProduct findMany
   */
  export type VendorProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProduct
     */
    select?: VendorProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProduct
     */
    omit?: VendorProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductInclude<ExtArgs> | null
    /**
     * Filter, which VendorProducts to fetch.
     */
    where?: VendorProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorProducts to fetch.
     */
    orderBy?: VendorProductOrderByWithRelationInput | VendorProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorProducts.
     */
    cursor?: VendorProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorProducts.
     */
    skip?: number
    distinct?: VendorProductScalarFieldEnum | VendorProductScalarFieldEnum[]
  }

  /**
   * VendorProduct create
   */
  export type VendorProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProduct
     */
    select?: VendorProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProduct
     */
    omit?: VendorProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorProduct.
     */
    data: XOR<VendorProductCreateInput, VendorProductUncheckedCreateInput>
  }

  /**
   * VendorProduct createMany
   */
  export type VendorProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorProducts.
     */
    data: VendorProductCreateManyInput | VendorProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorProduct createManyAndReturn
   */
  export type VendorProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProduct
     */
    select?: VendorProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProduct
     */
    omit?: VendorProductOmit<ExtArgs> | null
    /**
     * The data used to create many VendorProducts.
     */
    data: VendorProductCreateManyInput | VendorProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorProduct update
   */
  export type VendorProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProduct
     */
    select?: VendorProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProduct
     */
    omit?: VendorProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorProduct.
     */
    data: XOR<VendorProductUpdateInput, VendorProductUncheckedUpdateInput>
    /**
     * Choose, which VendorProduct to update.
     */
    where: VendorProductWhereUniqueInput
  }

  /**
   * VendorProduct updateMany
   */
  export type VendorProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorProducts.
     */
    data: XOR<VendorProductUpdateManyMutationInput, VendorProductUncheckedUpdateManyInput>
    /**
     * Filter which VendorProducts to update
     */
    where?: VendorProductWhereInput
    /**
     * Limit how many VendorProducts to update.
     */
    limit?: number
  }

  /**
   * VendorProduct updateManyAndReturn
   */
  export type VendorProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProduct
     */
    select?: VendorProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProduct
     */
    omit?: VendorProductOmit<ExtArgs> | null
    /**
     * The data used to update VendorProducts.
     */
    data: XOR<VendorProductUpdateManyMutationInput, VendorProductUncheckedUpdateManyInput>
    /**
     * Filter which VendorProducts to update
     */
    where?: VendorProductWhereInput
    /**
     * Limit how many VendorProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorProduct upsert
   */
  export type VendorProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProduct
     */
    select?: VendorProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProduct
     */
    omit?: VendorProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorProduct to update in case it exists.
     */
    where: VendorProductWhereUniqueInput
    /**
     * In case the VendorProduct found by the `where` argument doesn't exist, create a new VendorProduct with this data.
     */
    create: XOR<VendorProductCreateInput, VendorProductUncheckedCreateInput>
    /**
     * In case the VendorProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorProductUpdateInput, VendorProductUncheckedUpdateInput>
  }

  /**
   * VendorProduct delete
   */
  export type VendorProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProduct
     */
    select?: VendorProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProduct
     */
    omit?: VendorProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductInclude<ExtArgs> | null
    /**
     * Filter which VendorProduct to delete.
     */
    where: VendorProductWhereUniqueInput
  }

  /**
   * VendorProduct deleteMany
   */
  export type VendorProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorProducts to delete
     */
    where?: VendorProductWhereInput
    /**
     * Limit how many VendorProducts to delete.
     */
    limit?: number
  }

  /**
   * VendorProduct.validator
   */
  export type VendorProduct$validatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * VendorProduct.images
   */
  export type VendorProduct$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProductImage
     */
    select?: VendorProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProductImage
     */
    omit?: VendorProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductImageInclude<ExtArgs> | null
    where?: VendorProductImageWhereInput
    orderBy?: VendorProductImageOrderByWithRelationInput | VendorProductImageOrderByWithRelationInput[]
    cursor?: VendorProductImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorProductImageScalarFieldEnum | VendorProductImageScalarFieldEnum[]
  }

  /**
   * VendorProduct.transformations
   */
  export type VendorProduct$transformationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignTransformation
     */
    select?: DesignTransformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignTransformation
     */
    omit?: DesignTransformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignTransformationInclude<ExtArgs> | null
    where?: DesignTransformationWhereInput
    orderBy?: DesignTransformationOrderByWithRelationInput | DesignTransformationOrderByWithRelationInput[]
    cursor?: DesignTransformationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DesignTransformationScalarFieldEnum | DesignTransformationScalarFieldEnum[]
  }

  /**
   * VendorProduct without action
   */
  export type VendorProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProduct
     */
    select?: VendorProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProduct
     */
    omit?: VendorProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductInclude<ExtArgs> | null
  }


  /**
   * Model VendorProductImage
   */

  export type AggregateVendorProductImage = {
    _count: VendorProductImageCountAggregateOutputType | null
    _avg: VendorProductImageAvgAggregateOutputType | null
    _sum: VendorProductImageSumAggregateOutputType | null
    _min: VendorProductImageMinAggregateOutputType | null
    _max: VendorProductImageMaxAggregateOutputType | null
  }

  export type VendorProductImageAvgAggregateOutputType = {
    id: number | null
    vendorProductId: number | null
    colorId: number | null
    width: number | null
    height: number | null
    fileSize: number | null
  }

  export type VendorProductImageSumAggregateOutputType = {
    id: number | null
    vendorProductId: number | null
    colorId: number | null
    width: number | null
    height: number | null
    fileSize: number | null
  }

  export type VendorProductImageMinAggregateOutputType = {
    id: number | null
    vendorProductId: number | null
    colorId: number | null
    colorName: string | null
    colorCode: string | null
    imageType: string | null
    cloudinaryUrl: string | null
    cloudinaryPublicId: string | null
    originalImageKey: string | null
    width: number | null
    height: number | null
    fileSize: number | null
    format: string | null
    createdAt: Date | null
    uploadedAt: Date | null
  }

  export type VendorProductImageMaxAggregateOutputType = {
    id: number | null
    vendorProductId: number | null
    colorId: number | null
    colorName: string | null
    colorCode: string | null
    imageType: string | null
    cloudinaryUrl: string | null
    cloudinaryPublicId: string | null
    originalImageKey: string | null
    width: number | null
    height: number | null
    fileSize: number | null
    format: string | null
    createdAt: Date | null
    uploadedAt: Date | null
  }

  export type VendorProductImageCountAggregateOutputType = {
    id: number
    vendorProductId: number
    colorId: number
    colorName: number
    colorCode: number
    imageType: number
    cloudinaryUrl: number
    cloudinaryPublicId: number
    originalImageKey: number
    width: number
    height: number
    fileSize: number
    format: number
    createdAt: number
    uploadedAt: number
    _all: number
  }


  export type VendorProductImageAvgAggregateInputType = {
    id?: true
    vendorProductId?: true
    colorId?: true
    width?: true
    height?: true
    fileSize?: true
  }

  export type VendorProductImageSumAggregateInputType = {
    id?: true
    vendorProductId?: true
    colorId?: true
    width?: true
    height?: true
    fileSize?: true
  }

  export type VendorProductImageMinAggregateInputType = {
    id?: true
    vendorProductId?: true
    colorId?: true
    colorName?: true
    colorCode?: true
    imageType?: true
    cloudinaryUrl?: true
    cloudinaryPublicId?: true
    originalImageKey?: true
    width?: true
    height?: true
    fileSize?: true
    format?: true
    createdAt?: true
    uploadedAt?: true
  }

  export type VendorProductImageMaxAggregateInputType = {
    id?: true
    vendorProductId?: true
    colorId?: true
    colorName?: true
    colorCode?: true
    imageType?: true
    cloudinaryUrl?: true
    cloudinaryPublicId?: true
    originalImageKey?: true
    width?: true
    height?: true
    fileSize?: true
    format?: true
    createdAt?: true
    uploadedAt?: true
  }

  export type VendorProductImageCountAggregateInputType = {
    id?: true
    vendorProductId?: true
    colorId?: true
    colorName?: true
    colorCode?: true
    imageType?: true
    cloudinaryUrl?: true
    cloudinaryPublicId?: true
    originalImageKey?: true
    width?: true
    height?: true
    fileSize?: true
    format?: true
    createdAt?: true
    uploadedAt?: true
    _all?: true
  }

  export type VendorProductImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorProductImage to aggregate.
     */
    where?: VendorProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorProductImages to fetch.
     */
    orderBy?: VendorProductImageOrderByWithRelationInput | VendorProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorProductImages
    **/
    _count?: true | VendorProductImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorProductImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorProductImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorProductImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorProductImageMaxAggregateInputType
  }

  export type GetVendorProductImageAggregateType<T extends VendorProductImageAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorProductImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorProductImage[P]>
      : GetScalarType<T[P], AggregateVendorProductImage[P]>
  }




  export type VendorProductImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorProductImageWhereInput
    orderBy?: VendorProductImageOrderByWithAggregationInput | VendorProductImageOrderByWithAggregationInput[]
    by: VendorProductImageScalarFieldEnum[] | VendorProductImageScalarFieldEnum
    having?: VendorProductImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorProductImageCountAggregateInputType | true
    _avg?: VendorProductImageAvgAggregateInputType
    _sum?: VendorProductImageSumAggregateInputType
    _min?: VendorProductImageMinAggregateInputType
    _max?: VendorProductImageMaxAggregateInputType
  }

  export type VendorProductImageGroupByOutputType = {
    id: number
    vendorProductId: number
    colorId: number | null
    colorName: string | null
    colorCode: string | null
    imageType: string
    cloudinaryUrl: string
    cloudinaryPublicId: string
    originalImageKey: string | null
    width: number | null
    height: number | null
    fileSize: number | null
    format: string | null
    createdAt: Date
    uploadedAt: Date
    _count: VendorProductImageCountAggregateOutputType | null
    _avg: VendorProductImageAvgAggregateOutputType | null
    _sum: VendorProductImageSumAggregateOutputType | null
    _min: VendorProductImageMinAggregateOutputType | null
    _max: VendorProductImageMaxAggregateOutputType | null
  }

  type GetVendorProductImageGroupByPayload<T extends VendorProductImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorProductImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorProductImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorProductImageGroupByOutputType[P]>
            : GetScalarType<T[P], VendorProductImageGroupByOutputType[P]>
        }
      >
    >


  export type VendorProductImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorProductId?: boolean
    colorId?: boolean
    colorName?: boolean
    colorCode?: boolean
    imageType?: boolean
    cloudinaryUrl?: boolean
    cloudinaryPublicId?: boolean
    originalImageKey?: boolean
    width?: boolean
    height?: boolean
    fileSize?: boolean
    format?: boolean
    createdAt?: boolean
    uploadedAt?: boolean
    vendorProduct?: boolean | VendorProductDefaultArgs<ExtArgs>
    colorVariation?: boolean | VendorProductImage$colorVariationArgs<ExtArgs>
  }, ExtArgs["result"]["vendorProductImage"]>

  export type VendorProductImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorProductId?: boolean
    colorId?: boolean
    colorName?: boolean
    colorCode?: boolean
    imageType?: boolean
    cloudinaryUrl?: boolean
    cloudinaryPublicId?: boolean
    originalImageKey?: boolean
    width?: boolean
    height?: boolean
    fileSize?: boolean
    format?: boolean
    createdAt?: boolean
    uploadedAt?: boolean
    vendorProduct?: boolean | VendorProductDefaultArgs<ExtArgs>
    colorVariation?: boolean | VendorProductImage$colorVariationArgs<ExtArgs>
  }, ExtArgs["result"]["vendorProductImage"]>

  export type VendorProductImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorProductId?: boolean
    colorId?: boolean
    colorName?: boolean
    colorCode?: boolean
    imageType?: boolean
    cloudinaryUrl?: boolean
    cloudinaryPublicId?: boolean
    originalImageKey?: boolean
    width?: boolean
    height?: boolean
    fileSize?: boolean
    format?: boolean
    createdAt?: boolean
    uploadedAt?: boolean
    vendorProduct?: boolean | VendorProductDefaultArgs<ExtArgs>
    colorVariation?: boolean | VendorProductImage$colorVariationArgs<ExtArgs>
  }, ExtArgs["result"]["vendorProductImage"]>

  export type VendorProductImageSelectScalar = {
    id?: boolean
    vendorProductId?: boolean
    colorId?: boolean
    colorName?: boolean
    colorCode?: boolean
    imageType?: boolean
    cloudinaryUrl?: boolean
    cloudinaryPublicId?: boolean
    originalImageKey?: boolean
    width?: boolean
    height?: boolean
    fileSize?: boolean
    format?: boolean
    createdAt?: boolean
    uploadedAt?: boolean
  }

  export type VendorProductImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendorProductId" | "colorId" | "colorName" | "colorCode" | "imageType" | "cloudinaryUrl" | "cloudinaryPublicId" | "originalImageKey" | "width" | "height" | "fileSize" | "format" | "createdAt" | "uploadedAt", ExtArgs["result"]["vendorProductImage"]>
  export type VendorProductImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendorProduct?: boolean | VendorProductDefaultArgs<ExtArgs>
    colorVariation?: boolean | VendorProductImage$colorVariationArgs<ExtArgs>
  }
  export type VendorProductImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendorProduct?: boolean | VendorProductDefaultArgs<ExtArgs>
    colorVariation?: boolean | VendorProductImage$colorVariationArgs<ExtArgs>
  }
  export type VendorProductImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendorProduct?: boolean | VendorProductDefaultArgs<ExtArgs>
    colorVariation?: boolean | VendorProductImage$colorVariationArgs<ExtArgs>
  }

  export type $VendorProductImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorProductImage"
    objects: {
      vendorProduct: Prisma.$VendorProductPayload<ExtArgs>
      colorVariation: Prisma.$ColorVariationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      vendorProductId: number
      colorId: number | null
      colorName: string | null
      colorCode: string | null
      imageType: string
      cloudinaryUrl: string
      cloudinaryPublicId: string
      originalImageKey: string | null
      width: number | null
      height: number | null
      fileSize: number | null
      format: string | null
      createdAt: Date
      uploadedAt: Date
    }, ExtArgs["result"]["vendorProductImage"]>
    composites: {}
  }

  type VendorProductImageGetPayload<S extends boolean | null | undefined | VendorProductImageDefaultArgs> = $Result.GetResult<Prisma.$VendorProductImagePayload, S>

  type VendorProductImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorProductImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorProductImageCountAggregateInputType | true
    }

  export interface VendorProductImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorProductImage'], meta: { name: 'VendorProductImage' } }
    /**
     * Find zero or one VendorProductImage that matches the filter.
     * @param {VendorProductImageFindUniqueArgs} args - Arguments to find a VendorProductImage
     * @example
     * // Get one VendorProductImage
     * const vendorProductImage = await prisma.vendorProductImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorProductImageFindUniqueArgs>(args: SelectSubset<T, VendorProductImageFindUniqueArgs<ExtArgs>>): Prisma__VendorProductImageClient<$Result.GetResult<Prisma.$VendorProductImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorProductImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorProductImageFindUniqueOrThrowArgs} args - Arguments to find a VendorProductImage
     * @example
     * // Get one VendorProductImage
     * const vendorProductImage = await prisma.vendorProductImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorProductImageFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorProductImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorProductImageClient<$Result.GetResult<Prisma.$VendorProductImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorProductImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProductImageFindFirstArgs} args - Arguments to find a VendorProductImage
     * @example
     * // Get one VendorProductImage
     * const vendorProductImage = await prisma.vendorProductImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorProductImageFindFirstArgs>(args?: SelectSubset<T, VendorProductImageFindFirstArgs<ExtArgs>>): Prisma__VendorProductImageClient<$Result.GetResult<Prisma.$VendorProductImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorProductImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProductImageFindFirstOrThrowArgs} args - Arguments to find a VendorProductImage
     * @example
     * // Get one VendorProductImage
     * const vendorProductImage = await prisma.vendorProductImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorProductImageFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorProductImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorProductImageClient<$Result.GetResult<Prisma.$VendorProductImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorProductImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProductImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorProductImages
     * const vendorProductImages = await prisma.vendorProductImage.findMany()
     * 
     * // Get first 10 VendorProductImages
     * const vendorProductImages = await prisma.vendorProductImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorProductImageWithIdOnly = await prisma.vendorProductImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorProductImageFindManyArgs>(args?: SelectSubset<T, VendorProductImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorProductImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorProductImage.
     * @param {VendorProductImageCreateArgs} args - Arguments to create a VendorProductImage.
     * @example
     * // Create one VendorProductImage
     * const VendorProductImage = await prisma.vendorProductImage.create({
     *   data: {
     *     // ... data to create a VendorProductImage
     *   }
     * })
     * 
     */
    create<T extends VendorProductImageCreateArgs>(args: SelectSubset<T, VendorProductImageCreateArgs<ExtArgs>>): Prisma__VendorProductImageClient<$Result.GetResult<Prisma.$VendorProductImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorProductImages.
     * @param {VendorProductImageCreateManyArgs} args - Arguments to create many VendorProductImages.
     * @example
     * // Create many VendorProductImages
     * const vendorProductImage = await prisma.vendorProductImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorProductImageCreateManyArgs>(args?: SelectSubset<T, VendorProductImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorProductImages and returns the data saved in the database.
     * @param {VendorProductImageCreateManyAndReturnArgs} args - Arguments to create many VendorProductImages.
     * @example
     * // Create many VendorProductImages
     * const vendorProductImage = await prisma.vendorProductImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorProductImages and only return the `id`
     * const vendorProductImageWithIdOnly = await prisma.vendorProductImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorProductImageCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorProductImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorProductImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorProductImage.
     * @param {VendorProductImageDeleteArgs} args - Arguments to delete one VendorProductImage.
     * @example
     * // Delete one VendorProductImage
     * const VendorProductImage = await prisma.vendorProductImage.delete({
     *   where: {
     *     // ... filter to delete one VendorProductImage
     *   }
     * })
     * 
     */
    delete<T extends VendorProductImageDeleteArgs>(args: SelectSubset<T, VendorProductImageDeleteArgs<ExtArgs>>): Prisma__VendorProductImageClient<$Result.GetResult<Prisma.$VendorProductImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorProductImage.
     * @param {VendorProductImageUpdateArgs} args - Arguments to update one VendorProductImage.
     * @example
     * // Update one VendorProductImage
     * const vendorProductImage = await prisma.vendorProductImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorProductImageUpdateArgs>(args: SelectSubset<T, VendorProductImageUpdateArgs<ExtArgs>>): Prisma__VendorProductImageClient<$Result.GetResult<Prisma.$VendorProductImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorProductImages.
     * @param {VendorProductImageDeleteManyArgs} args - Arguments to filter VendorProductImages to delete.
     * @example
     * // Delete a few VendorProductImages
     * const { count } = await prisma.vendorProductImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorProductImageDeleteManyArgs>(args?: SelectSubset<T, VendorProductImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProductImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorProductImages
     * const vendorProductImage = await prisma.vendorProductImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorProductImageUpdateManyArgs>(args: SelectSubset<T, VendorProductImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorProductImages and returns the data updated in the database.
     * @param {VendorProductImageUpdateManyAndReturnArgs} args - Arguments to update many VendorProductImages.
     * @example
     * // Update many VendorProductImages
     * const vendorProductImage = await prisma.vendorProductImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorProductImages and only return the `id`
     * const vendorProductImageWithIdOnly = await prisma.vendorProductImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorProductImageUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorProductImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorProductImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorProductImage.
     * @param {VendorProductImageUpsertArgs} args - Arguments to update or create a VendorProductImage.
     * @example
     * // Update or create a VendorProductImage
     * const vendorProductImage = await prisma.vendorProductImage.upsert({
     *   create: {
     *     // ... data to create a VendorProductImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorProductImage we want to update
     *   }
     * })
     */
    upsert<T extends VendorProductImageUpsertArgs>(args: SelectSubset<T, VendorProductImageUpsertArgs<ExtArgs>>): Prisma__VendorProductImageClient<$Result.GetResult<Prisma.$VendorProductImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProductImageCountArgs} args - Arguments to filter VendorProductImages to count.
     * @example
     * // Count the number of VendorProductImages
     * const count = await prisma.vendorProductImage.count({
     *   where: {
     *     // ... the filter for the VendorProductImages we want to count
     *   }
     * })
    **/
    count<T extends VendorProductImageCountArgs>(
      args?: Subset<T, VendorProductImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorProductImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProductImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorProductImageAggregateArgs>(args: Subset<T, VendorProductImageAggregateArgs>): Prisma.PrismaPromise<GetVendorProductImageAggregateType<T>>

    /**
     * Group by VendorProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProductImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorProductImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorProductImageGroupByArgs['orderBy'] }
        : { orderBy?: VendorProductImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorProductImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorProductImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorProductImage model
   */
  readonly fields: VendorProductImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorProductImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorProductImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendorProduct<T extends VendorProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorProductDefaultArgs<ExtArgs>>): Prisma__VendorProductClient<$Result.GetResult<Prisma.$VendorProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    colorVariation<T extends VendorProductImage$colorVariationArgs<ExtArgs> = {}>(args?: Subset<T, VendorProductImage$colorVariationArgs<ExtArgs>>): Prisma__ColorVariationClient<$Result.GetResult<Prisma.$ColorVariationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorProductImage model
   */
  interface VendorProductImageFieldRefs {
    readonly id: FieldRef<"VendorProductImage", 'Int'>
    readonly vendorProductId: FieldRef<"VendorProductImage", 'Int'>
    readonly colorId: FieldRef<"VendorProductImage", 'Int'>
    readonly colorName: FieldRef<"VendorProductImage", 'String'>
    readonly colorCode: FieldRef<"VendorProductImage", 'String'>
    readonly imageType: FieldRef<"VendorProductImage", 'String'>
    readonly cloudinaryUrl: FieldRef<"VendorProductImage", 'String'>
    readonly cloudinaryPublicId: FieldRef<"VendorProductImage", 'String'>
    readonly originalImageKey: FieldRef<"VendorProductImage", 'String'>
    readonly width: FieldRef<"VendorProductImage", 'Int'>
    readonly height: FieldRef<"VendorProductImage", 'Int'>
    readonly fileSize: FieldRef<"VendorProductImage", 'Int'>
    readonly format: FieldRef<"VendorProductImage", 'String'>
    readonly createdAt: FieldRef<"VendorProductImage", 'DateTime'>
    readonly uploadedAt: FieldRef<"VendorProductImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorProductImage findUnique
   */
  export type VendorProductImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProductImage
     */
    select?: VendorProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProductImage
     */
    omit?: VendorProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductImageInclude<ExtArgs> | null
    /**
     * Filter, which VendorProductImage to fetch.
     */
    where: VendorProductImageWhereUniqueInput
  }

  /**
   * VendorProductImage findUniqueOrThrow
   */
  export type VendorProductImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProductImage
     */
    select?: VendorProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProductImage
     */
    omit?: VendorProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductImageInclude<ExtArgs> | null
    /**
     * Filter, which VendorProductImage to fetch.
     */
    where: VendorProductImageWhereUniqueInput
  }

  /**
   * VendorProductImage findFirst
   */
  export type VendorProductImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProductImage
     */
    select?: VendorProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProductImage
     */
    omit?: VendorProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductImageInclude<ExtArgs> | null
    /**
     * Filter, which VendorProductImage to fetch.
     */
    where?: VendorProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorProductImages to fetch.
     */
    orderBy?: VendorProductImageOrderByWithRelationInput | VendorProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorProductImages.
     */
    cursor?: VendorProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorProductImages.
     */
    distinct?: VendorProductImageScalarFieldEnum | VendorProductImageScalarFieldEnum[]
  }

  /**
   * VendorProductImage findFirstOrThrow
   */
  export type VendorProductImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProductImage
     */
    select?: VendorProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProductImage
     */
    omit?: VendorProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductImageInclude<ExtArgs> | null
    /**
     * Filter, which VendorProductImage to fetch.
     */
    where?: VendorProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorProductImages to fetch.
     */
    orderBy?: VendorProductImageOrderByWithRelationInput | VendorProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorProductImages.
     */
    cursor?: VendorProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorProductImages.
     */
    distinct?: VendorProductImageScalarFieldEnum | VendorProductImageScalarFieldEnum[]
  }

  /**
   * VendorProductImage findMany
   */
  export type VendorProductImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProductImage
     */
    select?: VendorProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProductImage
     */
    omit?: VendorProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductImageInclude<ExtArgs> | null
    /**
     * Filter, which VendorProductImages to fetch.
     */
    where?: VendorProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorProductImages to fetch.
     */
    orderBy?: VendorProductImageOrderByWithRelationInput | VendorProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorProductImages.
     */
    cursor?: VendorProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorProductImages.
     */
    skip?: number
    distinct?: VendorProductImageScalarFieldEnum | VendorProductImageScalarFieldEnum[]
  }

  /**
   * VendorProductImage create
   */
  export type VendorProductImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProductImage
     */
    select?: VendorProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProductImage
     */
    omit?: VendorProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductImageInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorProductImage.
     */
    data: XOR<VendorProductImageCreateInput, VendorProductImageUncheckedCreateInput>
  }

  /**
   * VendorProductImage createMany
   */
  export type VendorProductImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorProductImages.
     */
    data: VendorProductImageCreateManyInput | VendorProductImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorProductImage createManyAndReturn
   */
  export type VendorProductImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProductImage
     */
    select?: VendorProductImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProductImage
     */
    omit?: VendorProductImageOmit<ExtArgs> | null
    /**
     * The data used to create many VendorProductImages.
     */
    data: VendorProductImageCreateManyInput | VendorProductImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorProductImage update
   */
  export type VendorProductImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProductImage
     */
    select?: VendorProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProductImage
     */
    omit?: VendorProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductImageInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorProductImage.
     */
    data: XOR<VendorProductImageUpdateInput, VendorProductImageUncheckedUpdateInput>
    /**
     * Choose, which VendorProductImage to update.
     */
    where: VendorProductImageWhereUniqueInput
  }

  /**
   * VendorProductImage updateMany
   */
  export type VendorProductImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorProductImages.
     */
    data: XOR<VendorProductImageUpdateManyMutationInput, VendorProductImageUncheckedUpdateManyInput>
    /**
     * Filter which VendorProductImages to update
     */
    where?: VendorProductImageWhereInput
    /**
     * Limit how many VendorProductImages to update.
     */
    limit?: number
  }

  /**
   * VendorProductImage updateManyAndReturn
   */
  export type VendorProductImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProductImage
     */
    select?: VendorProductImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProductImage
     */
    omit?: VendorProductImageOmit<ExtArgs> | null
    /**
     * The data used to update VendorProductImages.
     */
    data: XOR<VendorProductImageUpdateManyMutationInput, VendorProductImageUncheckedUpdateManyInput>
    /**
     * Filter which VendorProductImages to update
     */
    where?: VendorProductImageWhereInput
    /**
     * Limit how many VendorProductImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorProductImage upsert
   */
  export type VendorProductImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProductImage
     */
    select?: VendorProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProductImage
     */
    omit?: VendorProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductImageInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorProductImage to update in case it exists.
     */
    where: VendorProductImageWhereUniqueInput
    /**
     * In case the VendorProductImage found by the `where` argument doesn't exist, create a new VendorProductImage with this data.
     */
    create: XOR<VendorProductImageCreateInput, VendorProductImageUncheckedCreateInput>
    /**
     * In case the VendorProductImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorProductImageUpdateInput, VendorProductImageUncheckedUpdateInput>
  }

  /**
   * VendorProductImage delete
   */
  export type VendorProductImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProductImage
     */
    select?: VendorProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProductImage
     */
    omit?: VendorProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductImageInclude<ExtArgs> | null
    /**
     * Filter which VendorProductImage to delete.
     */
    where: VendorProductImageWhereUniqueInput
  }

  /**
   * VendorProductImage deleteMany
   */
  export type VendorProductImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorProductImages to delete
     */
    where?: VendorProductImageWhereInput
    /**
     * Limit how many VendorProductImages to delete.
     */
    limit?: number
  }

  /**
   * VendorProductImage.colorVariation
   */
  export type VendorProductImage$colorVariationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorVariation
     */
    select?: ColorVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorVariation
     */
    omit?: ColorVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorVariationInclude<ExtArgs> | null
    where?: ColorVariationWhereInput
  }

  /**
   * VendorProductImage without action
   */
  export type VendorProductImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProductImage
     */
    select?: VendorProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorProductImage
     */
    omit?: VendorProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProductImageInclude<ExtArgs> | null
  }


  /**
   * Model DesignTransformation
   */

  export type AggregateDesignTransformation = {
    _count: DesignTransformationCountAggregateOutputType | null
    _avg: DesignTransformationAvgAggregateOutputType | null
    _sum: DesignTransformationSumAggregateOutputType | null
    _min: DesignTransformationMinAggregateOutputType | null
    _max: DesignTransformationMaxAggregateOutputType | null
  }

  export type DesignTransformationAvgAggregateOutputType = {
    id: number | null
    vendorProductId: number | null
    delimitationIndex: number | null
    xOffset: number | null
    yOffset: number | null
    scaleFactor: number | null
  }

  export type DesignTransformationSumAggregateOutputType = {
    id: number | null
    vendorProductId: number | null
    delimitationIndex: number | null
    xOffset: number | null
    yOffset: number | null
    scaleFactor: number | null
  }

  export type DesignTransformationMinAggregateOutputType = {
    id: number | null
    vendorProductId: number | null
    delimitationIndex: number | null
    xOffset: number | null
    yOffset: number | null
    scaleFactor: number | null
    positioning: $Enums.DesignPositioning | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DesignTransformationMaxAggregateOutputType = {
    id: number | null
    vendorProductId: number | null
    delimitationIndex: number | null
    xOffset: number | null
    yOffset: number | null
    scaleFactor: number | null
    positioning: $Enums.DesignPositioning | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DesignTransformationCountAggregateOutputType = {
    id: number
    vendorProductId: number
    delimitationIndex: number
    xOffset: number
    yOffset: number
    scaleFactor: number
    positioning: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DesignTransformationAvgAggregateInputType = {
    id?: true
    vendorProductId?: true
    delimitationIndex?: true
    xOffset?: true
    yOffset?: true
    scaleFactor?: true
  }

  export type DesignTransformationSumAggregateInputType = {
    id?: true
    vendorProductId?: true
    delimitationIndex?: true
    xOffset?: true
    yOffset?: true
    scaleFactor?: true
  }

  export type DesignTransformationMinAggregateInputType = {
    id?: true
    vendorProductId?: true
    delimitationIndex?: true
    xOffset?: true
    yOffset?: true
    scaleFactor?: true
    positioning?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DesignTransformationMaxAggregateInputType = {
    id?: true
    vendorProductId?: true
    delimitationIndex?: true
    xOffset?: true
    yOffset?: true
    scaleFactor?: true
    positioning?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DesignTransformationCountAggregateInputType = {
    id?: true
    vendorProductId?: true
    delimitationIndex?: true
    xOffset?: true
    yOffset?: true
    scaleFactor?: true
    positioning?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DesignTransformationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DesignTransformation to aggregate.
     */
    where?: DesignTransformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignTransformations to fetch.
     */
    orderBy?: DesignTransformationOrderByWithRelationInput | DesignTransformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DesignTransformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignTransformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignTransformations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DesignTransformations
    **/
    _count?: true | DesignTransformationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DesignTransformationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DesignTransformationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DesignTransformationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DesignTransformationMaxAggregateInputType
  }

  export type GetDesignTransformationAggregateType<T extends DesignTransformationAggregateArgs> = {
        [P in keyof T & keyof AggregateDesignTransformation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDesignTransformation[P]>
      : GetScalarType<T[P], AggregateDesignTransformation[P]>
  }




  export type DesignTransformationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignTransformationWhereInput
    orderBy?: DesignTransformationOrderByWithAggregationInput | DesignTransformationOrderByWithAggregationInput[]
    by: DesignTransformationScalarFieldEnum[] | DesignTransformationScalarFieldEnum
    having?: DesignTransformationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DesignTransformationCountAggregateInputType | true
    _avg?: DesignTransformationAvgAggregateInputType
    _sum?: DesignTransformationSumAggregateInputType
    _min?: DesignTransformationMinAggregateInputType
    _max?: DesignTransformationMaxAggregateInputType
  }

  export type DesignTransformationGroupByOutputType = {
    id: number
    vendorProductId: number
    delimitationIndex: number
    xOffset: number
    yOffset: number
    scaleFactor: number
    positioning: $Enums.DesignPositioning
    createdAt: Date
    updatedAt: Date
    _count: DesignTransformationCountAggregateOutputType | null
    _avg: DesignTransformationAvgAggregateOutputType | null
    _sum: DesignTransformationSumAggregateOutputType | null
    _min: DesignTransformationMinAggregateOutputType | null
    _max: DesignTransformationMaxAggregateOutputType | null
  }

  type GetDesignTransformationGroupByPayload<T extends DesignTransformationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DesignTransformationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DesignTransformationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DesignTransformationGroupByOutputType[P]>
            : GetScalarType<T[P], DesignTransformationGroupByOutputType[P]>
        }
      >
    >


  export type DesignTransformationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorProductId?: boolean
    delimitationIndex?: boolean
    xOffset?: boolean
    yOffset?: boolean
    scaleFactor?: boolean
    positioning?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendorProduct?: boolean | VendorProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designTransformation"]>

  export type DesignTransformationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorProductId?: boolean
    delimitationIndex?: boolean
    xOffset?: boolean
    yOffset?: boolean
    scaleFactor?: boolean
    positioning?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendorProduct?: boolean | VendorProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designTransformation"]>

  export type DesignTransformationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorProductId?: boolean
    delimitationIndex?: boolean
    xOffset?: boolean
    yOffset?: boolean
    scaleFactor?: boolean
    positioning?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendorProduct?: boolean | VendorProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designTransformation"]>

  export type DesignTransformationSelectScalar = {
    id?: boolean
    vendorProductId?: boolean
    delimitationIndex?: boolean
    xOffset?: boolean
    yOffset?: boolean
    scaleFactor?: boolean
    positioning?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DesignTransformationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendorProductId" | "delimitationIndex" | "xOffset" | "yOffset" | "scaleFactor" | "positioning" | "createdAt" | "updatedAt", ExtArgs["result"]["designTransformation"]>
  export type DesignTransformationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendorProduct?: boolean | VendorProductDefaultArgs<ExtArgs>
  }
  export type DesignTransformationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendorProduct?: boolean | VendorProductDefaultArgs<ExtArgs>
  }
  export type DesignTransformationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendorProduct?: boolean | VendorProductDefaultArgs<ExtArgs>
  }

  export type $DesignTransformationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DesignTransformation"
    objects: {
      vendorProduct: Prisma.$VendorProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      vendorProductId: number
      delimitationIndex: number
      xOffset: number
      yOffset: number
      scaleFactor: number
      positioning: $Enums.DesignPositioning
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["designTransformation"]>
    composites: {}
  }

  type DesignTransformationGetPayload<S extends boolean | null | undefined | DesignTransformationDefaultArgs> = $Result.GetResult<Prisma.$DesignTransformationPayload, S>

  type DesignTransformationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DesignTransformationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DesignTransformationCountAggregateInputType | true
    }

  export interface DesignTransformationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DesignTransformation'], meta: { name: 'DesignTransformation' } }
    /**
     * Find zero or one DesignTransformation that matches the filter.
     * @param {DesignTransformationFindUniqueArgs} args - Arguments to find a DesignTransformation
     * @example
     * // Get one DesignTransformation
     * const designTransformation = await prisma.designTransformation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DesignTransformationFindUniqueArgs>(args: SelectSubset<T, DesignTransformationFindUniqueArgs<ExtArgs>>): Prisma__DesignTransformationClient<$Result.GetResult<Prisma.$DesignTransformationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DesignTransformation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DesignTransformationFindUniqueOrThrowArgs} args - Arguments to find a DesignTransformation
     * @example
     * // Get one DesignTransformation
     * const designTransformation = await prisma.designTransformation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DesignTransformationFindUniqueOrThrowArgs>(args: SelectSubset<T, DesignTransformationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DesignTransformationClient<$Result.GetResult<Prisma.$DesignTransformationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DesignTransformation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignTransformationFindFirstArgs} args - Arguments to find a DesignTransformation
     * @example
     * // Get one DesignTransformation
     * const designTransformation = await prisma.designTransformation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DesignTransformationFindFirstArgs>(args?: SelectSubset<T, DesignTransformationFindFirstArgs<ExtArgs>>): Prisma__DesignTransformationClient<$Result.GetResult<Prisma.$DesignTransformationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DesignTransformation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignTransformationFindFirstOrThrowArgs} args - Arguments to find a DesignTransformation
     * @example
     * // Get one DesignTransformation
     * const designTransformation = await prisma.designTransformation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DesignTransformationFindFirstOrThrowArgs>(args?: SelectSubset<T, DesignTransformationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DesignTransformationClient<$Result.GetResult<Prisma.$DesignTransformationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DesignTransformations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignTransformationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DesignTransformations
     * const designTransformations = await prisma.designTransformation.findMany()
     * 
     * // Get first 10 DesignTransformations
     * const designTransformations = await prisma.designTransformation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const designTransformationWithIdOnly = await prisma.designTransformation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DesignTransformationFindManyArgs>(args?: SelectSubset<T, DesignTransformationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignTransformationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DesignTransformation.
     * @param {DesignTransformationCreateArgs} args - Arguments to create a DesignTransformation.
     * @example
     * // Create one DesignTransformation
     * const DesignTransformation = await prisma.designTransformation.create({
     *   data: {
     *     // ... data to create a DesignTransformation
     *   }
     * })
     * 
     */
    create<T extends DesignTransformationCreateArgs>(args: SelectSubset<T, DesignTransformationCreateArgs<ExtArgs>>): Prisma__DesignTransformationClient<$Result.GetResult<Prisma.$DesignTransformationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DesignTransformations.
     * @param {DesignTransformationCreateManyArgs} args - Arguments to create many DesignTransformations.
     * @example
     * // Create many DesignTransformations
     * const designTransformation = await prisma.designTransformation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DesignTransformationCreateManyArgs>(args?: SelectSubset<T, DesignTransformationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DesignTransformations and returns the data saved in the database.
     * @param {DesignTransformationCreateManyAndReturnArgs} args - Arguments to create many DesignTransformations.
     * @example
     * // Create many DesignTransformations
     * const designTransformation = await prisma.designTransformation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DesignTransformations and only return the `id`
     * const designTransformationWithIdOnly = await prisma.designTransformation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DesignTransformationCreateManyAndReturnArgs>(args?: SelectSubset<T, DesignTransformationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignTransformationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DesignTransformation.
     * @param {DesignTransformationDeleteArgs} args - Arguments to delete one DesignTransformation.
     * @example
     * // Delete one DesignTransformation
     * const DesignTransformation = await prisma.designTransformation.delete({
     *   where: {
     *     // ... filter to delete one DesignTransformation
     *   }
     * })
     * 
     */
    delete<T extends DesignTransformationDeleteArgs>(args: SelectSubset<T, DesignTransformationDeleteArgs<ExtArgs>>): Prisma__DesignTransformationClient<$Result.GetResult<Prisma.$DesignTransformationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DesignTransformation.
     * @param {DesignTransformationUpdateArgs} args - Arguments to update one DesignTransformation.
     * @example
     * // Update one DesignTransformation
     * const designTransformation = await prisma.designTransformation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DesignTransformationUpdateArgs>(args: SelectSubset<T, DesignTransformationUpdateArgs<ExtArgs>>): Prisma__DesignTransformationClient<$Result.GetResult<Prisma.$DesignTransformationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DesignTransformations.
     * @param {DesignTransformationDeleteManyArgs} args - Arguments to filter DesignTransformations to delete.
     * @example
     * // Delete a few DesignTransformations
     * const { count } = await prisma.designTransformation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DesignTransformationDeleteManyArgs>(args?: SelectSubset<T, DesignTransformationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DesignTransformations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignTransformationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DesignTransformations
     * const designTransformation = await prisma.designTransformation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DesignTransformationUpdateManyArgs>(args: SelectSubset<T, DesignTransformationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DesignTransformations and returns the data updated in the database.
     * @param {DesignTransformationUpdateManyAndReturnArgs} args - Arguments to update many DesignTransformations.
     * @example
     * // Update many DesignTransformations
     * const designTransformation = await prisma.designTransformation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DesignTransformations and only return the `id`
     * const designTransformationWithIdOnly = await prisma.designTransformation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DesignTransformationUpdateManyAndReturnArgs>(args: SelectSubset<T, DesignTransformationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignTransformationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DesignTransformation.
     * @param {DesignTransformationUpsertArgs} args - Arguments to update or create a DesignTransformation.
     * @example
     * // Update or create a DesignTransformation
     * const designTransformation = await prisma.designTransformation.upsert({
     *   create: {
     *     // ... data to create a DesignTransformation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DesignTransformation we want to update
     *   }
     * })
     */
    upsert<T extends DesignTransformationUpsertArgs>(args: SelectSubset<T, DesignTransformationUpsertArgs<ExtArgs>>): Prisma__DesignTransformationClient<$Result.GetResult<Prisma.$DesignTransformationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DesignTransformations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignTransformationCountArgs} args - Arguments to filter DesignTransformations to count.
     * @example
     * // Count the number of DesignTransformations
     * const count = await prisma.designTransformation.count({
     *   where: {
     *     // ... the filter for the DesignTransformations we want to count
     *   }
     * })
    **/
    count<T extends DesignTransformationCountArgs>(
      args?: Subset<T, DesignTransformationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DesignTransformationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DesignTransformation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignTransformationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DesignTransformationAggregateArgs>(args: Subset<T, DesignTransformationAggregateArgs>): Prisma.PrismaPromise<GetDesignTransformationAggregateType<T>>

    /**
     * Group by DesignTransformation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignTransformationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DesignTransformationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DesignTransformationGroupByArgs['orderBy'] }
        : { orderBy?: DesignTransformationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DesignTransformationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDesignTransformationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DesignTransformation model
   */
  readonly fields: DesignTransformationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DesignTransformation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DesignTransformationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendorProduct<T extends VendorProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorProductDefaultArgs<ExtArgs>>): Prisma__VendorProductClient<$Result.GetResult<Prisma.$VendorProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DesignTransformation model
   */
  interface DesignTransformationFieldRefs {
    readonly id: FieldRef<"DesignTransformation", 'Int'>
    readonly vendorProductId: FieldRef<"DesignTransformation", 'Int'>
    readonly delimitationIndex: FieldRef<"DesignTransformation", 'Int'>
    readonly xOffset: FieldRef<"DesignTransformation", 'Float'>
    readonly yOffset: FieldRef<"DesignTransformation", 'Float'>
    readonly scaleFactor: FieldRef<"DesignTransformation", 'Float'>
    readonly positioning: FieldRef<"DesignTransformation", 'DesignPositioning'>
    readonly createdAt: FieldRef<"DesignTransformation", 'DateTime'>
    readonly updatedAt: FieldRef<"DesignTransformation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DesignTransformation findUnique
   */
  export type DesignTransformationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignTransformation
     */
    select?: DesignTransformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignTransformation
     */
    omit?: DesignTransformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignTransformationInclude<ExtArgs> | null
    /**
     * Filter, which DesignTransformation to fetch.
     */
    where: DesignTransformationWhereUniqueInput
  }

  /**
   * DesignTransformation findUniqueOrThrow
   */
  export type DesignTransformationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignTransformation
     */
    select?: DesignTransformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignTransformation
     */
    omit?: DesignTransformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignTransformationInclude<ExtArgs> | null
    /**
     * Filter, which DesignTransformation to fetch.
     */
    where: DesignTransformationWhereUniqueInput
  }

  /**
   * DesignTransformation findFirst
   */
  export type DesignTransformationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignTransformation
     */
    select?: DesignTransformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignTransformation
     */
    omit?: DesignTransformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignTransformationInclude<ExtArgs> | null
    /**
     * Filter, which DesignTransformation to fetch.
     */
    where?: DesignTransformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignTransformations to fetch.
     */
    orderBy?: DesignTransformationOrderByWithRelationInput | DesignTransformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DesignTransformations.
     */
    cursor?: DesignTransformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignTransformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignTransformations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DesignTransformations.
     */
    distinct?: DesignTransformationScalarFieldEnum | DesignTransformationScalarFieldEnum[]
  }

  /**
   * DesignTransformation findFirstOrThrow
   */
  export type DesignTransformationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignTransformation
     */
    select?: DesignTransformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignTransformation
     */
    omit?: DesignTransformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignTransformationInclude<ExtArgs> | null
    /**
     * Filter, which DesignTransformation to fetch.
     */
    where?: DesignTransformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignTransformations to fetch.
     */
    orderBy?: DesignTransformationOrderByWithRelationInput | DesignTransformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DesignTransformations.
     */
    cursor?: DesignTransformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignTransformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignTransformations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DesignTransformations.
     */
    distinct?: DesignTransformationScalarFieldEnum | DesignTransformationScalarFieldEnum[]
  }

  /**
   * DesignTransformation findMany
   */
  export type DesignTransformationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignTransformation
     */
    select?: DesignTransformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignTransformation
     */
    omit?: DesignTransformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignTransformationInclude<ExtArgs> | null
    /**
     * Filter, which DesignTransformations to fetch.
     */
    where?: DesignTransformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignTransformations to fetch.
     */
    orderBy?: DesignTransformationOrderByWithRelationInput | DesignTransformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DesignTransformations.
     */
    cursor?: DesignTransformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignTransformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignTransformations.
     */
    skip?: number
    distinct?: DesignTransformationScalarFieldEnum | DesignTransformationScalarFieldEnum[]
  }

  /**
   * DesignTransformation create
   */
  export type DesignTransformationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignTransformation
     */
    select?: DesignTransformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignTransformation
     */
    omit?: DesignTransformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignTransformationInclude<ExtArgs> | null
    /**
     * The data needed to create a DesignTransformation.
     */
    data: XOR<DesignTransformationCreateInput, DesignTransformationUncheckedCreateInput>
  }

  /**
   * DesignTransformation createMany
   */
  export type DesignTransformationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DesignTransformations.
     */
    data: DesignTransformationCreateManyInput | DesignTransformationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DesignTransformation createManyAndReturn
   */
  export type DesignTransformationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignTransformation
     */
    select?: DesignTransformationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DesignTransformation
     */
    omit?: DesignTransformationOmit<ExtArgs> | null
    /**
     * The data used to create many DesignTransformations.
     */
    data: DesignTransformationCreateManyInput | DesignTransformationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignTransformationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DesignTransformation update
   */
  export type DesignTransformationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignTransformation
     */
    select?: DesignTransformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignTransformation
     */
    omit?: DesignTransformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignTransformationInclude<ExtArgs> | null
    /**
     * The data needed to update a DesignTransformation.
     */
    data: XOR<DesignTransformationUpdateInput, DesignTransformationUncheckedUpdateInput>
    /**
     * Choose, which DesignTransformation to update.
     */
    where: DesignTransformationWhereUniqueInput
  }

  /**
   * DesignTransformation updateMany
   */
  export type DesignTransformationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DesignTransformations.
     */
    data: XOR<DesignTransformationUpdateManyMutationInput, DesignTransformationUncheckedUpdateManyInput>
    /**
     * Filter which DesignTransformations to update
     */
    where?: DesignTransformationWhereInput
    /**
     * Limit how many DesignTransformations to update.
     */
    limit?: number
  }

  /**
   * DesignTransformation updateManyAndReturn
   */
  export type DesignTransformationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignTransformation
     */
    select?: DesignTransformationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DesignTransformation
     */
    omit?: DesignTransformationOmit<ExtArgs> | null
    /**
     * The data used to update DesignTransformations.
     */
    data: XOR<DesignTransformationUpdateManyMutationInput, DesignTransformationUncheckedUpdateManyInput>
    /**
     * Filter which DesignTransformations to update
     */
    where?: DesignTransformationWhereInput
    /**
     * Limit how many DesignTransformations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignTransformationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DesignTransformation upsert
   */
  export type DesignTransformationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignTransformation
     */
    select?: DesignTransformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignTransformation
     */
    omit?: DesignTransformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignTransformationInclude<ExtArgs> | null
    /**
     * The filter to search for the DesignTransformation to update in case it exists.
     */
    where: DesignTransformationWhereUniqueInput
    /**
     * In case the DesignTransformation found by the `where` argument doesn't exist, create a new DesignTransformation with this data.
     */
    create: XOR<DesignTransformationCreateInput, DesignTransformationUncheckedCreateInput>
    /**
     * In case the DesignTransformation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DesignTransformationUpdateInput, DesignTransformationUncheckedUpdateInput>
  }

  /**
   * DesignTransformation delete
   */
  export type DesignTransformationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignTransformation
     */
    select?: DesignTransformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignTransformation
     */
    omit?: DesignTransformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignTransformationInclude<ExtArgs> | null
    /**
     * Filter which DesignTransformation to delete.
     */
    where: DesignTransformationWhereUniqueInput
  }

  /**
   * DesignTransformation deleteMany
   */
  export type DesignTransformationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DesignTransformations to delete
     */
    where?: DesignTransformationWhereInput
    /**
     * Limit how many DesignTransformations to delete.
     */
    limit?: number
  }

  /**
   * DesignTransformation without action
   */
  export type DesignTransformationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignTransformation
     */
    select?: DesignTransformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignTransformation
     */
    omit?: DesignTransformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignTransformationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    password: 'password',
    role: 'role',
    status: 'status',
    photo_profil: 'photo_profil',
    login_attempts: 'login_attempts',
    locked_until: 'locked_until',
    last_login_at: 'last_login_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    must_change_password: 'must_change_password',
    vendeur_type: 'vendeur_type',
    phone: 'phone',
    country: 'country',
    address: 'address',
    shop_name: 'shop_name',
    profile_photo_url: 'profile_photo_url'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PasswordResetScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    expiresAt: 'expiresAt',
    used: 'used',
    createdAt: 'createdAt',
    usedAt: 'usedAt'
  };

  export type PasswordResetScalarFieldEnum = (typeof PasswordResetScalarFieldEnum)[keyof typeof PasswordResetScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    stock: 'stock',
    status: 'status',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isValidated: 'isValidated',
    validatedAt: 'validatedAt',
    validatedBy: 'validatedBy',
    rejectionReason: 'rejectionReason',
    submittedForValidationAt: 'submittedForValidationAt',
    hasCustomDesigns: 'hasCustomDesigns',
    designsMetadata: 'designsMetadata'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductSizeScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    sizeName: 'sizeName'
  };

  export type ProductSizeScalarFieldEnum = (typeof ProductSizeScalarFieldEnum)[keyof typeof ProductSizeScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ColorVariationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    colorCode: 'colorCode',
    productId: 'productId'
  };

  export type ColorVariationScalarFieldEnum = (typeof ColorVariationScalarFieldEnum)[keyof typeof ColorVariationScalarFieldEnum]


  export const ProductImageScalarFieldEnum: {
    id: 'id',
    view: 'view',
    url: 'url',
    publicId: 'publicId',
    naturalWidth: 'naturalWidth',
    naturalHeight: 'naturalHeight',
    designUrl: 'designUrl',
    designPublicId: 'designPublicId',
    designFileName: 'designFileName',
    designUploadDate: 'designUploadDate',
    designSize: 'designSize',
    designOriginalName: 'designOriginalName',
    designDescription: 'designDescription',
    isDesignActive: 'isDesignActive',
    colorVariationId: 'colorVariationId'
  };

  export type ProductImageScalarFieldEnum = (typeof ProductImageScalarFieldEnum)[keyof typeof ProductImageScalarFieldEnum]


  export const DelimitationScalarFieldEnum: {
    id: 'id',
    x: 'x',
    y: 'y',
    width: 'width',
    height: 'height',
    rotation: 'rotation',
    name: 'name',
    coordinateType: 'coordinateType',
    absoluteX: 'absoluteX',
    absoluteY: 'absoluteY',
    absoluteWidth: 'absoluteWidth',
    absoluteHeight: 'absoluteHeight',
    originalImageWidth: 'originalImageWidth',
    originalImageHeight: 'originalImageHeight',
    productImageId: 'productImageId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    referenceWidth: 'referenceWidth',
    referenceHeight: 'referenceHeight'
  };

  export type DelimitationScalarFieldEnum = (typeof DelimitationScalarFieldEnum)[keyof typeof DelimitationScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    userId: 'userId',
    status: 'status',
    totalAmount: 'totalAmount',
    phoneNumber: 'phoneNumber',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    validatedAt: 'validatedAt',
    validatedBy: 'validatedBy',
    shippingName: 'shippingName',
    shippingStreet: 'shippingStreet',
    shippingCity: 'shippingCity',
    shippingRegion: 'shippingRegion',
    shippingPostalCode: 'shippingPostalCode',
    shippingCountry: 'shippingCountry',
    shippingAddressFull: 'shippingAddressFull'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    size: 'size',
    color: 'color',
    colorId: 'colorId'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    expiresAt: 'expiresAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const DesignScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    name: 'name',
    description: 'description',
    price: 'price',
    category: 'category',
    imageUrl: 'imageUrl',
    thumbnailUrl: 'thumbnailUrl',
    cloudinaryPublicId: 'cloudinaryPublicId',
    thumbnailPublicId: 'thumbnailPublicId',
    fileSize: 'fileSize',
    originalFileName: 'originalFileName',
    dimensions: 'dimensions',
    format: 'format',
    tags: 'tags',
    isDraft: 'isDraft',
    isPublished: 'isPublished',
    isPending: 'isPending',
    isValidated: 'isValidated',
    validatedAt: 'validatedAt',
    validatedBy: 'validatedBy',
    rejectionReason: 'rejectionReason',
    submittedForValidationAt: 'submittedForValidationAt',
    views: 'views',
    likes: 'likes',
    earnings: 'earnings',
    usageCount: 'usageCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    publishedAt: 'publishedAt'
  };

  export type DesignScalarFieldEnum = (typeof DesignScalarFieldEnum)[keyof typeof DesignScalarFieldEnum]


  export const VendorProductScalarFieldEnum: {
    id: 'id',
    baseProductId: 'baseProductId',
    vendorId: 'vendorId',
    name: 'name',
    description: 'description',
    price: 'price',
    stock: 'stock',
    status: 'status',
    adminProductName: 'adminProductName',
    adminProductDescription: 'adminProductDescription',
    adminProductPrice: 'adminProductPrice',
    designBase64: 'designBase64',
    designCloudinaryUrl: 'designCloudinaryUrl',
    designCloudinaryPublicId: 'designCloudinaryPublicId',
    designPositioning: 'designPositioning',
    designScale: 'designScale',
    designApplicationMode: 'designApplicationMode',
    sizes: 'sizes',
    colors: 'colors',
    vendorName: 'vendorName',
    vendorDescription: 'vendorDescription',
    vendorStock: 'vendorStock',
    basePriceAdmin: 'basePriceAdmin',
    isValidated: 'isValidated',
    validatedAt: 'validatedAt',
    validatedBy: 'validatedBy',
    rejectionReason: 'rejectionReason',
    submittedForValidationAt: 'submittedForValidationAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorProductScalarFieldEnum = (typeof VendorProductScalarFieldEnum)[keyof typeof VendorProductScalarFieldEnum]


  export const VendorProductImageScalarFieldEnum: {
    id: 'id',
    vendorProductId: 'vendorProductId',
    colorId: 'colorId',
    colorName: 'colorName',
    colorCode: 'colorCode',
    imageType: 'imageType',
    cloudinaryUrl: 'cloudinaryUrl',
    cloudinaryPublicId: 'cloudinaryPublicId',
    originalImageKey: 'originalImageKey',
    width: 'width',
    height: 'height',
    fileSize: 'fileSize',
    format: 'format',
    createdAt: 'createdAt',
    uploadedAt: 'uploadedAt'
  };

  export type VendorProductImageScalarFieldEnum = (typeof VendorProductImageScalarFieldEnum)[keyof typeof VendorProductImageScalarFieldEnum]


  export const DesignTransformationScalarFieldEnum: {
    id: 'id',
    vendorProductId: 'vendorProductId',
    delimitationIndex: 'delimitationIndex',
    xOffset: 'xOffset',
    yOffset: 'yOffset',
    scaleFactor: 'scaleFactor',
    positioning: 'positioning',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DesignTransformationScalarFieldEnum = (typeof DesignTransformationScalarFieldEnum)[keyof typeof DesignTransformationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'VendeurType'
   */
  export type EnumVendeurTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VendeurType'>
    


  /**
   * Reference to a field of type 'VendeurType[]'
   */
  export type ListEnumVendeurTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VendeurType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'PublicationStatus'
   */
  export type EnumPublicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublicationStatus'>
    


  /**
   * Reference to a field of type 'PublicationStatus[]'
   */
  export type ListEnumPublicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublicationStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'CoordinateType'
   */
  export type EnumCoordinateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CoordinateType'>
    


  /**
   * Reference to a field of type 'CoordinateType[]'
   */
  export type ListEnumCoordinateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CoordinateType[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'DesignCategory'
   */
  export type EnumDesignCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DesignCategory'>
    


  /**
   * Reference to a field of type 'DesignCategory[]'
   */
  export type ListEnumDesignCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DesignCategory[]'>
    


  /**
   * Reference to a field of type 'VendorProductStatus'
   */
  export type EnumVendorProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VendorProductStatus'>
    


  /**
   * Reference to a field of type 'VendorProductStatus[]'
   */
  export type ListEnumVendorProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VendorProductStatus[]'>
    


  /**
   * Reference to a field of type 'DesignPositioning'
   */
  export type EnumDesignPositioningFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DesignPositioning'>
    


  /**
   * Reference to a field of type 'DesignPositioning[]'
   */
  export type ListEnumDesignPositioningFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DesignPositioning[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    status?: BoolFilter<"User"> | boolean
    photo_profil?: StringNullableFilter<"User"> | string | null
    login_attempts?: IntFilter<"User"> | number
    locked_until?: DateTimeNullableFilter<"User"> | Date | string | null
    last_login_at?: DateTimeNullableFilter<"User"> | Date | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    must_change_password?: BoolFilter<"User"> | boolean
    vendeur_type?: EnumVendeurTypeNullableFilter<"User"> | $Enums.VendeurType | null
    phone?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    shop_name?: StringNullableFilter<"User"> | string | null
    profile_photo_url?: StringNullableFilter<"User"> | string | null
    passwordResets?: PasswordResetListRelationFilter
    orders?: OrderListRelationFilter
    validatedOrders?: OrderListRelationFilter
    notifications?: NotificationListRelationFilter
    designs?: DesignListRelationFilter
    validatedDesigns?: DesignListRelationFilter
    validatedProducts?: ProductListRelationFilter
    validatedVendorProducts?: VendorProductListRelationFilter
    vendorProducts?: VendorProductListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    photo_profil?: SortOrderInput | SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrderInput | SortOrder
    last_login_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    must_change_password?: SortOrder
    vendeur_type?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    shop_name?: SortOrderInput | SortOrder
    profile_photo_url?: SortOrderInput | SortOrder
    passwordResets?: PasswordResetOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    validatedOrders?: OrderOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    designs?: DesignOrderByRelationAggregateInput
    validatedDesigns?: DesignOrderByRelationAggregateInput
    validatedProducts?: ProductOrderByRelationAggregateInput
    validatedVendorProducts?: VendorProductOrderByRelationAggregateInput
    vendorProducts?: VendorProductOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    status?: BoolFilter<"User"> | boolean
    photo_profil?: StringNullableFilter<"User"> | string | null
    login_attempts?: IntFilter<"User"> | number
    locked_until?: DateTimeNullableFilter<"User"> | Date | string | null
    last_login_at?: DateTimeNullableFilter<"User"> | Date | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    must_change_password?: BoolFilter<"User"> | boolean
    vendeur_type?: EnumVendeurTypeNullableFilter<"User"> | $Enums.VendeurType | null
    phone?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    shop_name?: StringNullableFilter<"User"> | string | null
    profile_photo_url?: StringNullableFilter<"User"> | string | null
    passwordResets?: PasswordResetListRelationFilter
    orders?: OrderListRelationFilter
    validatedOrders?: OrderListRelationFilter
    notifications?: NotificationListRelationFilter
    designs?: DesignListRelationFilter
    validatedDesigns?: DesignListRelationFilter
    validatedProducts?: ProductListRelationFilter
    validatedVendorProducts?: VendorProductListRelationFilter
    vendorProducts?: VendorProductListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    photo_profil?: SortOrderInput | SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrderInput | SortOrder
    last_login_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    must_change_password?: SortOrder
    vendeur_type?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    shop_name?: SortOrderInput | SortOrder
    profile_photo_url?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    status?: BoolWithAggregatesFilter<"User"> | boolean
    photo_profil?: StringNullableWithAggregatesFilter<"User"> | string | null
    login_attempts?: IntWithAggregatesFilter<"User"> | number
    locked_until?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    last_login_at?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    must_change_password?: BoolWithAggregatesFilter<"User"> | boolean
    vendeur_type?: EnumVendeurTypeNullableWithAggregatesFilter<"User"> | $Enums.VendeurType | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    shop_name?: StringNullableWithAggregatesFilter<"User"> | string | null
    profile_photo_url?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type PasswordResetWhereInput = {
    AND?: PasswordResetWhereInput | PasswordResetWhereInput[]
    OR?: PasswordResetWhereInput[]
    NOT?: PasswordResetWhereInput | PasswordResetWhereInput[]
    id?: IntFilter<"PasswordReset"> | number
    token?: StringFilter<"PasswordReset"> | string
    userId?: IntFilter<"PasswordReset"> | number
    expiresAt?: DateTimeFilter<"PasswordReset"> | Date | string
    used?: BoolFilter<"PasswordReset"> | boolean
    createdAt?: DateTimeFilter<"PasswordReset"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordReset"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: PasswordResetWhereInput | PasswordResetWhereInput[]
    OR?: PasswordResetWhereInput[]
    NOT?: PasswordResetWhereInput | PasswordResetWhereInput[]
    userId?: IntFilter<"PasswordReset"> | number
    expiresAt?: DateTimeFilter<"PasswordReset"> | Date | string
    used?: BoolFilter<"PasswordReset"> | boolean
    createdAt?: DateTimeFilter<"PasswordReset"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordReset"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type PasswordResetOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    _count?: PasswordResetCountOrderByAggregateInput
    _avg?: PasswordResetAvgOrderByAggregateInput
    _max?: PasswordResetMaxOrderByAggregateInput
    _min?: PasswordResetMinOrderByAggregateInput
    _sum?: PasswordResetSumOrderByAggregateInput
  }

  export type PasswordResetScalarWhereWithAggregatesInput = {
    AND?: PasswordResetScalarWhereWithAggregatesInput | PasswordResetScalarWhereWithAggregatesInput[]
    OR?: PasswordResetScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetScalarWhereWithAggregatesInput | PasswordResetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PasswordReset"> | number
    token?: StringWithAggregatesFilter<"PasswordReset"> | string
    userId?: IntWithAggregatesFilter<"PasswordReset"> | number
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordReset"> | Date | string
    used?: BoolWithAggregatesFilter<"PasswordReset"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PasswordReset"> | Date | string
    usedAt?: DateTimeNullableWithAggregatesFilter<"PasswordReset"> | Date | string | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    stock?: IntFilter<"Product"> | number
    status?: EnumPublicationStatusFilter<"Product"> | $Enums.PublicationStatus
    description?: StringFilter<"Product"> | string
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    isValidated?: BoolFilter<"Product"> | boolean
    validatedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    validatedBy?: IntNullableFilter<"Product"> | number | null
    rejectionReason?: StringNullableFilter<"Product"> | string | null
    submittedForValidationAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    hasCustomDesigns?: BoolFilter<"Product"> | boolean
    designsMetadata?: JsonNullableFilter<"Product">
    validator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    categories?: CategoryListRelationFilter
    sizes?: ProductSizeListRelationFilter
    colorVariations?: ColorVariationListRelationFilter
    orderItems?: OrderItemListRelationFilter
    vendorProducts?: VendorProductListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isValidated?: SortOrder
    validatedAt?: SortOrderInput | SortOrder
    validatedBy?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    submittedForValidationAt?: SortOrderInput | SortOrder
    hasCustomDesigns?: SortOrder
    designsMetadata?: SortOrderInput | SortOrder
    validator?: UserOrderByWithRelationInput
    categories?: CategoryOrderByRelationAggregateInput
    sizes?: ProductSizeOrderByRelationAggregateInput
    colorVariations?: ColorVariationOrderByRelationAggregateInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    vendorProducts?: VendorProductOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    stock?: IntFilter<"Product"> | number
    status?: EnumPublicationStatusFilter<"Product"> | $Enums.PublicationStatus
    description?: StringFilter<"Product"> | string
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    isValidated?: BoolFilter<"Product"> | boolean
    validatedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    validatedBy?: IntNullableFilter<"Product"> | number | null
    rejectionReason?: StringNullableFilter<"Product"> | string | null
    submittedForValidationAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    hasCustomDesigns?: BoolFilter<"Product"> | boolean
    designsMetadata?: JsonNullableFilter<"Product">
    validator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    categories?: CategoryListRelationFilter
    sizes?: ProductSizeListRelationFilter
    colorVariations?: ColorVariationListRelationFilter
    orderItems?: OrderItemListRelationFilter
    vendorProducts?: VendorProductListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isValidated?: SortOrder
    validatedAt?: SortOrderInput | SortOrder
    validatedBy?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    submittedForValidationAt?: SortOrderInput | SortOrder
    hasCustomDesigns?: SortOrder
    designsMetadata?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    name?: StringWithAggregatesFilter<"Product"> | string
    price?: FloatWithAggregatesFilter<"Product"> | number
    stock?: IntWithAggregatesFilter<"Product"> | number
    status?: EnumPublicationStatusWithAggregatesFilter<"Product"> | $Enums.PublicationStatus
    description?: StringWithAggregatesFilter<"Product"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    isValidated?: BoolWithAggregatesFilter<"Product"> | boolean
    validatedAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    validatedBy?: IntNullableWithAggregatesFilter<"Product"> | number | null
    rejectionReason?: StringNullableWithAggregatesFilter<"Product"> | string | null
    submittedForValidationAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    hasCustomDesigns?: BoolWithAggregatesFilter<"Product"> | boolean
    designsMetadata?: JsonNullableWithAggregatesFilter<"Product">
  }

  export type ProductSizeWhereInput = {
    AND?: ProductSizeWhereInput | ProductSizeWhereInput[]
    OR?: ProductSizeWhereInput[]
    NOT?: ProductSizeWhereInput | ProductSizeWhereInput[]
    id?: IntFilter<"ProductSize"> | number
    productId?: IntFilter<"ProductSize"> | number
    sizeName?: StringFilter<"ProductSize"> | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductSizeOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    sizeName?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductSizeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductSizeWhereInput | ProductSizeWhereInput[]
    OR?: ProductSizeWhereInput[]
    NOT?: ProductSizeWhereInput | ProductSizeWhereInput[]
    productId?: IntFilter<"ProductSize"> | number
    sizeName?: StringFilter<"ProductSize"> | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ProductSizeOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    sizeName?: SortOrder
    _count?: ProductSizeCountOrderByAggregateInput
    _avg?: ProductSizeAvgOrderByAggregateInput
    _max?: ProductSizeMaxOrderByAggregateInput
    _min?: ProductSizeMinOrderByAggregateInput
    _sum?: ProductSizeSumOrderByAggregateInput
  }

  export type ProductSizeScalarWhereWithAggregatesInput = {
    AND?: ProductSizeScalarWhereWithAggregatesInput | ProductSizeScalarWhereWithAggregatesInput[]
    OR?: ProductSizeScalarWhereWithAggregatesInput[]
    NOT?: ProductSizeScalarWhereWithAggregatesInput | ProductSizeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductSize"> | number
    productId?: IntWithAggregatesFilter<"ProductSize"> | number
    sizeName?: StringWithAggregatesFilter<"ProductSize"> | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    products?: ProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    description?: StringNullableFilter<"Category"> | string | null
    products?: ProductListRelationFilter
  }, "id" | "name">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    name?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
  }

  export type ColorVariationWhereInput = {
    AND?: ColorVariationWhereInput | ColorVariationWhereInput[]
    OR?: ColorVariationWhereInput[]
    NOT?: ColorVariationWhereInput | ColorVariationWhereInput[]
    id?: IntFilter<"ColorVariation"> | number
    name?: StringFilter<"ColorVariation"> | string
    colorCode?: StringFilter<"ColorVariation"> | string
    productId?: IntFilter<"ColorVariation"> | number
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    images?: ProductImageListRelationFilter
    orderItems?: OrderItemListRelationFilter
    vendorProductImages?: VendorProductImageListRelationFilter
  }

  export type ColorVariationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    colorCode?: SortOrder
    productId?: SortOrder
    product?: ProductOrderByWithRelationInput
    images?: ProductImageOrderByRelationAggregateInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    vendorProductImages?: VendorProductImageOrderByRelationAggregateInput
  }

  export type ColorVariationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ColorVariationWhereInput | ColorVariationWhereInput[]
    OR?: ColorVariationWhereInput[]
    NOT?: ColorVariationWhereInput | ColorVariationWhereInput[]
    name?: StringFilter<"ColorVariation"> | string
    colorCode?: StringFilter<"ColorVariation"> | string
    productId?: IntFilter<"ColorVariation"> | number
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    images?: ProductImageListRelationFilter
    orderItems?: OrderItemListRelationFilter
    vendorProductImages?: VendorProductImageListRelationFilter
  }, "id">

  export type ColorVariationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    colorCode?: SortOrder
    productId?: SortOrder
    _count?: ColorVariationCountOrderByAggregateInput
    _avg?: ColorVariationAvgOrderByAggregateInput
    _max?: ColorVariationMaxOrderByAggregateInput
    _min?: ColorVariationMinOrderByAggregateInput
    _sum?: ColorVariationSumOrderByAggregateInput
  }

  export type ColorVariationScalarWhereWithAggregatesInput = {
    AND?: ColorVariationScalarWhereWithAggregatesInput | ColorVariationScalarWhereWithAggregatesInput[]
    OR?: ColorVariationScalarWhereWithAggregatesInput[]
    NOT?: ColorVariationScalarWhereWithAggregatesInput | ColorVariationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ColorVariation"> | number
    name?: StringWithAggregatesFilter<"ColorVariation"> | string
    colorCode?: StringWithAggregatesFilter<"ColorVariation"> | string
    productId?: IntWithAggregatesFilter<"ColorVariation"> | number
  }

  export type ProductImageWhereInput = {
    AND?: ProductImageWhereInput | ProductImageWhereInput[]
    OR?: ProductImageWhereInput[]
    NOT?: ProductImageWhereInput | ProductImageWhereInput[]
    id?: IntFilter<"ProductImage"> | number
    view?: StringFilter<"ProductImage"> | string
    url?: StringFilter<"ProductImage"> | string
    publicId?: StringFilter<"ProductImage"> | string
    naturalWidth?: IntNullableFilter<"ProductImage"> | number | null
    naturalHeight?: IntNullableFilter<"ProductImage"> | number | null
    designUrl?: StringNullableFilter<"ProductImage"> | string | null
    designPublicId?: StringNullableFilter<"ProductImage"> | string | null
    designFileName?: StringNullableFilter<"ProductImage"> | string | null
    designUploadDate?: DateTimeNullableFilter<"ProductImage"> | Date | string | null
    designSize?: IntNullableFilter<"ProductImage"> | number | null
    designOriginalName?: StringNullableFilter<"ProductImage"> | string | null
    designDescription?: StringNullableFilter<"ProductImage"> | string | null
    isDesignActive?: BoolFilter<"ProductImage"> | boolean
    colorVariationId?: IntFilter<"ProductImage"> | number
    colorVariation?: XOR<ColorVariationScalarRelationFilter, ColorVariationWhereInput>
    delimitations?: DelimitationListRelationFilter
  }

  export type ProductImageOrderByWithRelationInput = {
    id?: SortOrder
    view?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    naturalWidth?: SortOrderInput | SortOrder
    naturalHeight?: SortOrderInput | SortOrder
    designUrl?: SortOrderInput | SortOrder
    designPublicId?: SortOrderInput | SortOrder
    designFileName?: SortOrderInput | SortOrder
    designUploadDate?: SortOrderInput | SortOrder
    designSize?: SortOrderInput | SortOrder
    designOriginalName?: SortOrderInput | SortOrder
    designDescription?: SortOrderInput | SortOrder
    isDesignActive?: SortOrder
    colorVariationId?: SortOrder
    colorVariation?: ColorVariationOrderByWithRelationInput
    delimitations?: DelimitationOrderByRelationAggregateInput
  }

  export type ProductImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductImageWhereInput | ProductImageWhereInput[]
    OR?: ProductImageWhereInput[]
    NOT?: ProductImageWhereInput | ProductImageWhereInput[]
    view?: StringFilter<"ProductImage"> | string
    url?: StringFilter<"ProductImage"> | string
    publicId?: StringFilter<"ProductImage"> | string
    naturalWidth?: IntNullableFilter<"ProductImage"> | number | null
    naturalHeight?: IntNullableFilter<"ProductImage"> | number | null
    designUrl?: StringNullableFilter<"ProductImage"> | string | null
    designPublicId?: StringNullableFilter<"ProductImage"> | string | null
    designFileName?: StringNullableFilter<"ProductImage"> | string | null
    designUploadDate?: DateTimeNullableFilter<"ProductImage"> | Date | string | null
    designSize?: IntNullableFilter<"ProductImage"> | number | null
    designOriginalName?: StringNullableFilter<"ProductImage"> | string | null
    designDescription?: StringNullableFilter<"ProductImage"> | string | null
    isDesignActive?: BoolFilter<"ProductImage"> | boolean
    colorVariationId?: IntFilter<"ProductImage"> | number
    colorVariation?: XOR<ColorVariationScalarRelationFilter, ColorVariationWhereInput>
    delimitations?: DelimitationListRelationFilter
  }, "id">

  export type ProductImageOrderByWithAggregationInput = {
    id?: SortOrder
    view?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    naturalWidth?: SortOrderInput | SortOrder
    naturalHeight?: SortOrderInput | SortOrder
    designUrl?: SortOrderInput | SortOrder
    designPublicId?: SortOrderInput | SortOrder
    designFileName?: SortOrderInput | SortOrder
    designUploadDate?: SortOrderInput | SortOrder
    designSize?: SortOrderInput | SortOrder
    designOriginalName?: SortOrderInput | SortOrder
    designDescription?: SortOrderInput | SortOrder
    isDesignActive?: SortOrder
    colorVariationId?: SortOrder
    _count?: ProductImageCountOrderByAggregateInput
    _avg?: ProductImageAvgOrderByAggregateInput
    _max?: ProductImageMaxOrderByAggregateInput
    _min?: ProductImageMinOrderByAggregateInput
    _sum?: ProductImageSumOrderByAggregateInput
  }

  export type ProductImageScalarWhereWithAggregatesInput = {
    AND?: ProductImageScalarWhereWithAggregatesInput | ProductImageScalarWhereWithAggregatesInput[]
    OR?: ProductImageScalarWhereWithAggregatesInput[]
    NOT?: ProductImageScalarWhereWithAggregatesInput | ProductImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductImage"> | number
    view?: StringWithAggregatesFilter<"ProductImage"> | string
    url?: StringWithAggregatesFilter<"ProductImage"> | string
    publicId?: StringWithAggregatesFilter<"ProductImage"> | string
    naturalWidth?: IntNullableWithAggregatesFilter<"ProductImage"> | number | null
    naturalHeight?: IntNullableWithAggregatesFilter<"ProductImage"> | number | null
    designUrl?: StringNullableWithAggregatesFilter<"ProductImage"> | string | null
    designPublicId?: StringNullableWithAggregatesFilter<"ProductImage"> | string | null
    designFileName?: StringNullableWithAggregatesFilter<"ProductImage"> | string | null
    designUploadDate?: DateTimeNullableWithAggregatesFilter<"ProductImage"> | Date | string | null
    designSize?: IntNullableWithAggregatesFilter<"ProductImage"> | number | null
    designOriginalName?: StringNullableWithAggregatesFilter<"ProductImage"> | string | null
    designDescription?: StringNullableWithAggregatesFilter<"ProductImage"> | string | null
    isDesignActive?: BoolWithAggregatesFilter<"ProductImage"> | boolean
    colorVariationId?: IntWithAggregatesFilter<"ProductImage"> | number
  }

  export type DelimitationWhereInput = {
    AND?: DelimitationWhereInput | DelimitationWhereInput[]
    OR?: DelimitationWhereInput[]
    NOT?: DelimitationWhereInput | DelimitationWhereInput[]
    id?: IntFilter<"Delimitation"> | number
    x?: FloatFilter<"Delimitation"> | number
    y?: FloatFilter<"Delimitation"> | number
    width?: FloatFilter<"Delimitation"> | number
    height?: FloatFilter<"Delimitation"> | number
    rotation?: FloatFilter<"Delimitation"> | number
    name?: StringNullableFilter<"Delimitation"> | string | null
    coordinateType?: EnumCoordinateTypeFilter<"Delimitation"> | $Enums.CoordinateType
    absoluteX?: FloatNullableFilter<"Delimitation"> | number | null
    absoluteY?: FloatNullableFilter<"Delimitation"> | number | null
    absoluteWidth?: FloatNullableFilter<"Delimitation"> | number | null
    absoluteHeight?: FloatNullableFilter<"Delimitation"> | number | null
    originalImageWidth?: IntNullableFilter<"Delimitation"> | number | null
    originalImageHeight?: IntNullableFilter<"Delimitation"> | number | null
    productImageId?: IntFilter<"Delimitation"> | number
    createdAt?: DateTimeFilter<"Delimitation"> | Date | string
    updatedAt?: DateTimeFilter<"Delimitation"> | Date | string
    referenceWidth?: IntFilter<"Delimitation"> | number
    referenceHeight?: IntFilter<"Delimitation"> | number
    productImage?: XOR<ProductImageScalarRelationFilter, ProductImageWhereInput>
  }

  export type DelimitationOrderByWithRelationInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    rotation?: SortOrder
    name?: SortOrderInput | SortOrder
    coordinateType?: SortOrder
    absoluteX?: SortOrderInput | SortOrder
    absoluteY?: SortOrderInput | SortOrder
    absoluteWidth?: SortOrderInput | SortOrder
    absoluteHeight?: SortOrderInput | SortOrder
    originalImageWidth?: SortOrderInput | SortOrder
    originalImageHeight?: SortOrderInput | SortOrder
    productImageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceWidth?: SortOrder
    referenceHeight?: SortOrder
    productImage?: ProductImageOrderByWithRelationInput
  }

  export type DelimitationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DelimitationWhereInput | DelimitationWhereInput[]
    OR?: DelimitationWhereInput[]
    NOT?: DelimitationWhereInput | DelimitationWhereInput[]
    x?: FloatFilter<"Delimitation"> | number
    y?: FloatFilter<"Delimitation"> | number
    width?: FloatFilter<"Delimitation"> | number
    height?: FloatFilter<"Delimitation"> | number
    rotation?: FloatFilter<"Delimitation"> | number
    name?: StringNullableFilter<"Delimitation"> | string | null
    coordinateType?: EnumCoordinateTypeFilter<"Delimitation"> | $Enums.CoordinateType
    absoluteX?: FloatNullableFilter<"Delimitation"> | number | null
    absoluteY?: FloatNullableFilter<"Delimitation"> | number | null
    absoluteWidth?: FloatNullableFilter<"Delimitation"> | number | null
    absoluteHeight?: FloatNullableFilter<"Delimitation"> | number | null
    originalImageWidth?: IntNullableFilter<"Delimitation"> | number | null
    originalImageHeight?: IntNullableFilter<"Delimitation"> | number | null
    productImageId?: IntFilter<"Delimitation"> | number
    createdAt?: DateTimeFilter<"Delimitation"> | Date | string
    updatedAt?: DateTimeFilter<"Delimitation"> | Date | string
    referenceWidth?: IntFilter<"Delimitation"> | number
    referenceHeight?: IntFilter<"Delimitation"> | number
    productImage?: XOR<ProductImageScalarRelationFilter, ProductImageWhereInput>
  }, "id">

  export type DelimitationOrderByWithAggregationInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    rotation?: SortOrder
    name?: SortOrderInput | SortOrder
    coordinateType?: SortOrder
    absoluteX?: SortOrderInput | SortOrder
    absoluteY?: SortOrderInput | SortOrder
    absoluteWidth?: SortOrderInput | SortOrder
    absoluteHeight?: SortOrderInput | SortOrder
    originalImageWidth?: SortOrderInput | SortOrder
    originalImageHeight?: SortOrderInput | SortOrder
    productImageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceWidth?: SortOrder
    referenceHeight?: SortOrder
    _count?: DelimitationCountOrderByAggregateInput
    _avg?: DelimitationAvgOrderByAggregateInput
    _max?: DelimitationMaxOrderByAggregateInput
    _min?: DelimitationMinOrderByAggregateInput
    _sum?: DelimitationSumOrderByAggregateInput
  }

  export type DelimitationScalarWhereWithAggregatesInput = {
    AND?: DelimitationScalarWhereWithAggregatesInput | DelimitationScalarWhereWithAggregatesInput[]
    OR?: DelimitationScalarWhereWithAggregatesInput[]
    NOT?: DelimitationScalarWhereWithAggregatesInput | DelimitationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Delimitation"> | number
    x?: FloatWithAggregatesFilter<"Delimitation"> | number
    y?: FloatWithAggregatesFilter<"Delimitation"> | number
    width?: FloatWithAggregatesFilter<"Delimitation"> | number
    height?: FloatWithAggregatesFilter<"Delimitation"> | number
    rotation?: FloatWithAggregatesFilter<"Delimitation"> | number
    name?: StringNullableWithAggregatesFilter<"Delimitation"> | string | null
    coordinateType?: EnumCoordinateTypeWithAggregatesFilter<"Delimitation"> | $Enums.CoordinateType
    absoluteX?: FloatNullableWithAggregatesFilter<"Delimitation"> | number | null
    absoluteY?: FloatNullableWithAggregatesFilter<"Delimitation"> | number | null
    absoluteWidth?: FloatNullableWithAggregatesFilter<"Delimitation"> | number | null
    absoluteHeight?: FloatNullableWithAggregatesFilter<"Delimitation"> | number | null
    originalImageWidth?: IntNullableWithAggregatesFilter<"Delimitation"> | number | null
    originalImageHeight?: IntNullableWithAggregatesFilter<"Delimitation"> | number | null
    productImageId?: IntWithAggregatesFilter<"Delimitation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Delimitation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Delimitation"> | Date | string
    referenceWidth?: IntWithAggregatesFilter<"Delimitation"> | number
    referenceHeight?: IntWithAggregatesFilter<"Delimitation"> | number
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: IntFilter<"Order"> | number
    orderNumber?: StringFilter<"Order"> | string
    userId?: IntFilter<"Order"> | number
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    totalAmount?: FloatFilter<"Order"> | number
    phoneNumber?: StringFilter<"Order"> | string
    notes?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    validatedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    validatedBy?: IntNullableFilter<"Order"> | number | null
    shippingName?: StringNullableFilter<"Order"> | string | null
    shippingStreet?: StringNullableFilter<"Order"> | string | null
    shippingCity?: StringNullableFilter<"Order"> | string | null
    shippingRegion?: StringNullableFilter<"Order"> | string | null
    shippingPostalCode?: StringNullableFilter<"Order"> | string | null
    shippingCountry?: StringNullableFilter<"Order"> | string | null
    shippingAddressFull?: StringNullableFilter<"Order"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    validator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    orderItems?: OrderItemListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    phoneNumber?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    validatedAt?: SortOrderInput | SortOrder
    validatedBy?: SortOrderInput | SortOrder
    shippingName?: SortOrderInput | SortOrder
    shippingStreet?: SortOrderInput | SortOrder
    shippingCity?: SortOrderInput | SortOrder
    shippingRegion?: SortOrderInput | SortOrder
    shippingPostalCode?: SortOrderInput | SortOrder
    shippingCountry?: SortOrderInput | SortOrder
    shippingAddressFull?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    validator?: UserOrderByWithRelationInput
    orderItems?: OrderItemOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderNumber?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    userId?: IntFilter<"Order"> | number
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    totalAmount?: FloatFilter<"Order"> | number
    phoneNumber?: StringFilter<"Order"> | string
    notes?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    validatedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    validatedBy?: IntNullableFilter<"Order"> | number | null
    shippingName?: StringNullableFilter<"Order"> | string | null
    shippingStreet?: StringNullableFilter<"Order"> | string | null
    shippingCity?: StringNullableFilter<"Order"> | string | null
    shippingRegion?: StringNullableFilter<"Order"> | string | null
    shippingPostalCode?: StringNullableFilter<"Order"> | string | null
    shippingCountry?: StringNullableFilter<"Order"> | string | null
    shippingAddressFull?: StringNullableFilter<"Order"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    validator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    orderItems?: OrderItemListRelationFilter
  }, "id" | "orderNumber">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    phoneNumber?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    validatedAt?: SortOrderInput | SortOrder
    validatedBy?: SortOrderInput | SortOrder
    shippingName?: SortOrderInput | SortOrder
    shippingStreet?: SortOrderInput | SortOrder
    shippingCity?: SortOrderInput | SortOrder
    shippingRegion?: SortOrderInput | SortOrder
    shippingPostalCode?: SortOrderInput | SortOrder
    shippingCountry?: SortOrderInput | SortOrder
    shippingAddressFull?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Order"> | number
    orderNumber?: StringWithAggregatesFilter<"Order"> | string
    userId?: IntWithAggregatesFilter<"Order"> | number
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    totalAmount?: FloatWithAggregatesFilter<"Order"> | number
    phoneNumber?: StringWithAggregatesFilter<"Order"> | string
    notes?: StringNullableWithAggregatesFilter<"Order"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    validatedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    validatedBy?: IntNullableWithAggregatesFilter<"Order"> | number | null
    shippingName?: StringNullableWithAggregatesFilter<"Order"> | string | null
    shippingStreet?: StringNullableWithAggregatesFilter<"Order"> | string | null
    shippingCity?: StringNullableWithAggregatesFilter<"Order"> | string | null
    shippingRegion?: StringNullableWithAggregatesFilter<"Order"> | string | null
    shippingPostalCode?: StringNullableWithAggregatesFilter<"Order"> | string | null
    shippingCountry?: StringNullableWithAggregatesFilter<"Order"> | string | null
    shippingAddressFull?: StringNullableWithAggregatesFilter<"Order"> | string | null
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    productId?: IntFilter<"OrderItem"> | number
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: FloatFilter<"OrderItem"> | number
    size?: StringNullableFilter<"OrderItem"> | string | null
    color?: StringNullableFilter<"OrderItem"> | string | null
    colorId?: IntNullableFilter<"OrderItem"> | number | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    colorVariation?: XOR<ColorVariationNullableScalarRelationFilter, ColorVariationWhereInput> | null
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    size?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    colorId?: SortOrderInput | SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    colorVariation?: ColorVariationOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: IntFilter<"OrderItem"> | number
    productId?: IntFilter<"OrderItem"> | number
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: FloatFilter<"OrderItem"> | number
    size?: StringNullableFilter<"OrderItem"> | string | null
    color?: StringNullableFilter<"OrderItem"> | string | null
    colorId?: IntNullableFilter<"OrderItem"> | number | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    colorVariation?: XOR<ColorVariationNullableScalarRelationFilter, ColorVariationWhereInput> | null
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    size?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    colorId?: SortOrderInput | SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderItem"> | number
    orderId?: IntWithAggregatesFilter<"OrderItem"> | number
    productId?: IntWithAggregatesFilter<"OrderItem"> | number
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"OrderItem"> | number
    size?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    color?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    colorId?: IntNullableWithAggregatesFilter<"OrderItem"> | number | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: IntFilter<"Notification"> | number
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    userId?: IntWithAggregatesFilter<"Notification"> | number
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
  }

  export type DesignWhereInput = {
    AND?: DesignWhereInput | DesignWhereInput[]
    OR?: DesignWhereInput[]
    NOT?: DesignWhereInput | DesignWhereInput[]
    id?: IntFilter<"Design"> | number
    vendorId?: IntFilter<"Design"> | number
    name?: StringFilter<"Design"> | string
    description?: StringNullableFilter<"Design"> | string | null
    price?: FloatFilter<"Design"> | number
    category?: EnumDesignCategoryFilter<"Design"> | $Enums.DesignCategory
    imageUrl?: StringFilter<"Design"> | string
    thumbnailUrl?: StringNullableFilter<"Design"> | string | null
    cloudinaryPublicId?: StringFilter<"Design"> | string
    thumbnailPublicId?: StringNullableFilter<"Design"> | string | null
    fileSize?: IntFilter<"Design"> | number
    originalFileName?: StringFilter<"Design"> | string
    dimensions?: JsonFilter<"Design">
    format?: StringFilter<"Design"> | string
    tags?: StringNullableListFilter<"Design">
    isDraft?: BoolFilter<"Design"> | boolean
    isPublished?: BoolFilter<"Design"> | boolean
    isPending?: BoolFilter<"Design"> | boolean
    isValidated?: BoolFilter<"Design"> | boolean
    validatedAt?: DateTimeNullableFilter<"Design"> | Date | string | null
    validatedBy?: IntNullableFilter<"Design"> | number | null
    rejectionReason?: StringNullableFilter<"Design"> | string | null
    submittedForValidationAt?: DateTimeNullableFilter<"Design"> | Date | string | null
    views?: IntFilter<"Design"> | number
    likes?: IntFilter<"Design"> | number
    earnings?: FloatFilter<"Design"> | number
    usageCount?: IntFilter<"Design"> | number
    createdAt?: DateTimeFilter<"Design"> | Date | string
    updatedAt?: DateTimeFilter<"Design"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Design"> | Date | string | null
    vendor?: XOR<UserScalarRelationFilter, UserWhereInput>
    validator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type DesignOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    cloudinaryPublicId?: SortOrder
    thumbnailPublicId?: SortOrderInput | SortOrder
    fileSize?: SortOrder
    originalFileName?: SortOrder
    dimensions?: SortOrder
    format?: SortOrder
    tags?: SortOrder
    isDraft?: SortOrder
    isPublished?: SortOrder
    isPending?: SortOrder
    isValidated?: SortOrder
    validatedAt?: SortOrderInput | SortOrder
    validatedBy?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    submittedForValidationAt?: SortOrderInput | SortOrder
    views?: SortOrder
    likes?: SortOrder
    earnings?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    vendor?: UserOrderByWithRelationInput
    validator?: UserOrderByWithRelationInput
  }

  export type DesignWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DesignWhereInput | DesignWhereInput[]
    OR?: DesignWhereInput[]
    NOT?: DesignWhereInput | DesignWhereInput[]
    vendorId?: IntFilter<"Design"> | number
    name?: StringFilter<"Design"> | string
    description?: StringNullableFilter<"Design"> | string | null
    price?: FloatFilter<"Design"> | number
    category?: EnumDesignCategoryFilter<"Design"> | $Enums.DesignCategory
    imageUrl?: StringFilter<"Design"> | string
    thumbnailUrl?: StringNullableFilter<"Design"> | string | null
    cloudinaryPublicId?: StringFilter<"Design"> | string
    thumbnailPublicId?: StringNullableFilter<"Design"> | string | null
    fileSize?: IntFilter<"Design"> | number
    originalFileName?: StringFilter<"Design"> | string
    dimensions?: JsonFilter<"Design">
    format?: StringFilter<"Design"> | string
    tags?: StringNullableListFilter<"Design">
    isDraft?: BoolFilter<"Design"> | boolean
    isPublished?: BoolFilter<"Design"> | boolean
    isPending?: BoolFilter<"Design"> | boolean
    isValidated?: BoolFilter<"Design"> | boolean
    validatedAt?: DateTimeNullableFilter<"Design"> | Date | string | null
    validatedBy?: IntNullableFilter<"Design"> | number | null
    rejectionReason?: StringNullableFilter<"Design"> | string | null
    submittedForValidationAt?: DateTimeNullableFilter<"Design"> | Date | string | null
    views?: IntFilter<"Design"> | number
    likes?: IntFilter<"Design"> | number
    earnings?: FloatFilter<"Design"> | number
    usageCount?: IntFilter<"Design"> | number
    createdAt?: DateTimeFilter<"Design"> | Date | string
    updatedAt?: DateTimeFilter<"Design"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Design"> | Date | string | null
    vendor?: XOR<UserScalarRelationFilter, UserWhereInput>
    validator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type DesignOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    cloudinaryPublicId?: SortOrder
    thumbnailPublicId?: SortOrderInput | SortOrder
    fileSize?: SortOrder
    originalFileName?: SortOrder
    dimensions?: SortOrder
    format?: SortOrder
    tags?: SortOrder
    isDraft?: SortOrder
    isPublished?: SortOrder
    isPending?: SortOrder
    isValidated?: SortOrder
    validatedAt?: SortOrderInput | SortOrder
    validatedBy?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    submittedForValidationAt?: SortOrderInput | SortOrder
    views?: SortOrder
    likes?: SortOrder
    earnings?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    _count?: DesignCountOrderByAggregateInput
    _avg?: DesignAvgOrderByAggregateInput
    _max?: DesignMaxOrderByAggregateInput
    _min?: DesignMinOrderByAggregateInput
    _sum?: DesignSumOrderByAggregateInput
  }

  export type DesignScalarWhereWithAggregatesInput = {
    AND?: DesignScalarWhereWithAggregatesInput | DesignScalarWhereWithAggregatesInput[]
    OR?: DesignScalarWhereWithAggregatesInput[]
    NOT?: DesignScalarWhereWithAggregatesInput | DesignScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Design"> | number
    vendorId?: IntWithAggregatesFilter<"Design"> | number
    name?: StringWithAggregatesFilter<"Design"> | string
    description?: StringNullableWithAggregatesFilter<"Design"> | string | null
    price?: FloatWithAggregatesFilter<"Design"> | number
    category?: EnumDesignCategoryWithAggregatesFilter<"Design"> | $Enums.DesignCategory
    imageUrl?: StringWithAggregatesFilter<"Design"> | string
    thumbnailUrl?: StringNullableWithAggregatesFilter<"Design"> | string | null
    cloudinaryPublicId?: StringWithAggregatesFilter<"Design"> | string
    thumbnailPublicId?: StringNullableWithAggregatesFilter<"Design"> | string | null
    fileSize?: IntWithAggregatesFilter<"Design"> | number
    originalFileName?: StringWithAggregatesFilter<"Design"> | string
    dimensions?: JsonWithAggregatesFilter<"Design">
    format?: StringWithAggregatesFilter<"Design"> | string
    tags?: StringNullableListFilter<"Design">
    isDraft?: BoolWithAggregatesFilter<"Design"> | boolean
    isPublished?: BoolWithAggregatesFilter<"Design"> | boolean
    isPending?: BoolWithAggregatesFilter<"Design"> | boolean
    isValidated?: BoolWithAggregatesFilter<"Design"> | boolean
    validatedAt?: DateTimeNullableWithAggregatesFilter<"Design"> | Date | string | null
    validatedBy?: IntNullableWithAggregatesFilter<"Design"> | number | null
    rejectionReason?: StringNullableWithAggregatesFilter<"Design"> | string | null
    submittedForValidationAt?: DateTimeNullableWithAggregatesFilter<"Design"> | Date | string | null
    views?: IntWithAggregatesFilter<"Design"> | number
    likes?: IntWithAggregatesFilter<"Design"> | number
    earnings?: FloatWithAggregatesFilter<"Design"> | number
    usageCount?: IntWithAggregatesFilter<"Design"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Design"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Design"> | Date | string
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Design"> | Date | string | null
  }

  export type VendorProductWhereInput = {
    AND?: VendorProductWhereInput | VendorProductWhereInput[]
    OR?: VendorProductWhereInput[]
    NOT?: VendorProductWhereInput | VendorProductWhereInput[]
    id?: IntFilter<"VendorProduct"> | number
    baseProductId?: IntFilter<"VendorProduct"> | number
    vendorId?: IntFilter<"VendorProduct"> | number
    name?: StringFilter<"VendorProduct"> | string
    description?: StringNullableFilter<"VendorProduct"> | string | null
    price?: IntFilter<"VendorProduct"> | number
    stock?: IntFilter<"VendorProduct"> | number
    status?: EnumVendorProductStatusFilter<"VendorProduct"> | $Enums.VendorProductStatus
    adminProductName?: StringNullableFilter<"VendorProduct"> | string | null
    adminProductDescription?: StringNullableFilter<"VendorProduct"> | string | null
    adminProductPrice?: IntNullableFilter<"VendorProduct"> | number | null
    designBase64?: StringNullableFilter<"VendorProduct"> | string | null
    designCloudinaryUrl?: StringNullableFilter<"VendorProduct"> | string | null
    designCloudinaryPublicId?: StringNullableFilter<"VendorProduct"> | string | null
    designPositioning?: StringNullableFilter<"VendorProduct"> | string | null
    designScale?: FloatNullableFilter<"VendorProduct"> | number | null
    designApplicationMode?: StringNullableFilter<"VendorProduct"> | string | null
    sizes?: JsonFilter<"VendorProduct">
    colors?: JsonFilter<"VendorProduct">
    vendorName?: StringNullableFilter<"VendorProduct"> | string | null
    vendorDescription?: StringNullableFilter<"VendorProduct"> | string | null
    vendorStock?: IntFilter<"VendorProduct"> | number
    basePriceAdmin?: FloatFilter<"VendorProduct"> | number
    isValidated?: BoolFilter<"VendorProduct"> | boolean
    validatedAt?: DateTimeNullableFilter<"VendorProduct"> | Date | string | null
    validatedBy?: IntNullableFilter<"VendorProduct"> | number | null
    rejectionReason?: StringNullableFilter<"VendorProduct"> | string | null
    submittedForValidationAt?: DateTimeNullableFilter<"VendorProduct"> | Date | string | null
    createdAt?: DateTimeFilter<"VendorProduct"> | Date | string
    updatedAt?: DateTimeFilter<"VendorProduct"> | Date | string
    validator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    vendor?: XOR<UserScalarRelationFilter, UserWhereInput>
    baseProduct?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    images?: VendorProductImageListRelationFilter
    transformations?: DesignTransformationListRelationFilter
  }

  export type VendorProductOrderByWithRelationInput = {
    id?: SortOrder
    baseProductId?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    stock?: SortOrder
    status?: SortOrder
    adminProductName?: SortOrderInput | SortOrder
    adminProductDescription?: SortOrderInput | SortOrder
    adminProductPrice?: SortOrderInput | SortOrder
    designBase64?: SortOrderInput | SortOrder
    designCloudinaryUrl?: SortOrderInput | SortOrder
    designCloudinaryPublicId?: SortOrderInput | SortOrder
    designPositioning?: SortOrderInput | SortOrder
    designScale?: SortOrderInput | SortOrder
    designApplicationMode?: SortOrderInput | SortOrder
    sizes?: SortOrder
    colors?: SortOrder
    vendorName?: SortOrderInput | SortOrder
    vendorDescription?: SortOrderInput | SortOrder
    vendorStock?: SortOrder
    basePriceAdmin?: SortOrder
    isValidated?: SortOrder
    validatedAt?: SortOrderInput | SortOrder
    validatedBy?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    submittedForValidationAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    validator?: UserOrderByWithRelationInput
    vendor?: UserOrderByWithRelationInput
    baseProduct?: ProductOrderByWithRelationInput
    images?: VendorProductImageOrderByRelationAggregateInput
    transformations?: DesignTransformationOrderByRelationAggregateInput
  }

  export type VendorProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VendorProductWhereInput | VendorProductWhereInput[]
    OR?: VendorProductWhereInput[]
    NOT?: VendorProductWhereInput | VendorProductWhereInput[]
    baseProductId?: IntFilter<"VendorProduct"> | number
    vendorId?: IntFilter<"VendorProduct"> | number
    name?: StringFilter<"VendorProduct"> | string
    description?: StringNullableFilter<"VendorProduct"> | string | null
    price?: IntFilter<"VendorProduct"> | number
    stock?: IntFilter<"VendorProduct"> | number
    status?: EnumVendorProductStatusFilter<"VendorProduct"> | $Enums.VendorProductStatus
    adminProductName?: StringNullableFilter<"VendorProduct"> | string | null
    adminProductDescription?: StringNullableFilter<"VendorProduct"> | string | null
    adminProductPrice?: IntNullableFilter<"VendorProduct"> | number | null
    designBase64?: StringNullableFilter<"VendorProduct"> | string | null
    designCloudinaryUrl?: StringNullableFilter<"VendorProduct"> | string | null
    designCloudinaryPublicId?: StringNullableFilter<"VendorProduct"> | string | null
    designPositioning?: StringNullableFilter<"VendorProduct"> | string | null
    designScale?: FloatNullableFilter<"VendorProduct"> | number | null
    designApplicationMode?: StringNullableFilter<"VendorProduct"> | string | null
    sizes?: JsonFilter<"VendorProduct">
    colors?: JsonFilter<"VendorProduct">
    vendorName?: StringNullableFilter<"VendorProduct"> | string | null
    vendorDescription?: StringNullableFilter<"VendorProduct"> | string | null
    vendorStock?: IntFilter<"VendorProduct"> | number
    basePriceAdmin?: FloatFilter<"VendorProduct"> | number
    isValidated?: BoolFilter<"VendorProduct"> | boolean
    validatedAt?: DateTimeNullableFilter<"VendorProduct"> | Date | string | null
    validatedBy?: IntNullableFilter<"VendorProduct"> | number | null
    rejectionReason?: StringNullableFilter<"VendorProduct"> | string | null
    submittedForValidationAt?: DateTimeNullableFilter<"VendorProduct"> | Date | string | null
    createdAt?: DateTimeFilter<"VendorProduct"> | Date | string
    updatedAt?: DateTimeFilter<"VendorProduct"> | Date | string
    validator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    vendor?: XOR<UserScalarRelationFilter, UserWhereInput>
    baseProduct?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    images?: VendorProductImageListRelationFilter
    transformations?: DesignTransformationListRelationFilter
  }, "id">

  export type VendorProductOrderByWithAggregationInput = {
    id?: SortOrder
    baseProductId?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    stock?: SortOrder
    status?: SortOrder
    adminProductName?: SortOrderInput | SortOrder
    adminProductDescription?: SortOrderInput | SortOrder
    adminProductPrice?: SortOrderInput | SortOrder
    designBase64?: SortOrderInput | SortOrder
    designCloudinaryUrl?: SortOrderInput | SortOrder
    designCloudinaryPublicId?: SortOrderInput | SortOrder
    designPositioning?: SortOrderInput | SortOrder
    designScale?: SortOrderInput | SortOrder
    designApplicationMode?: SortOrderInput | SortOrder
    sizes?: SortOrder
    colors?: SortOrder
    vendorName?: SortOrderInput | SortOrder
    vendorDescription?: SortOrderInput | SortOrder
    vendorStock?: SortOrder
    basePriceAdmin?: SortOrder
    isValidated?: SortOrder
    validatedAt?: SortOrderInput | SortOrder
    validatedBy?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    submittedForValidationAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorProductCountOrderByAggregateInput
    _avg?: VendorProductAvgOrderByAggregateInput
    _max?: VendorProductMaxOrderByAggregateInput
    _min?: VendorProductMinOrderByAggregateInput
    _sum?: VendorProductSumOrderByAggregateInput
  }

  export type VendorProductScalarWhereWithAggregatesInput = {
    AND?: VendorProductScalarWhereWithAggregatesInput | VendorProductScalarWhereWithAggregatesInput[]
    OR?: VendorProductScalarWhereWithAggregatesInput[]
    NOT?: VendorProductScalarWhereWithAggregatesInput | VendorProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VendorProduct"> | number
    baseProductId?: IntWithAggregatesFilter<"VendorProduct"> | number
    vendorId?: IntWithAggregatesFilter<"VendorProduct"> | number
    name?: StringWithAggregatesFilter<"VendorProduct"> | string
    description?: StringNullableWithAggregatesFilter<"VendorProduct"> | string | null
    price?: IntWithAggregatesFilter<"VendorProduct"> | number
    stock?: IntWithAggregatesFilter<"VendorProduct"> | number
    status?: EnumVendorProductStatusWithAggregatesFilter<"VendorProduct"> | $Enums.VendorProductStatus
    adminProductName?: StringNullableWithAggregatesFilter<"VendorProduct"> | string | null
    adminProductDescription?: StringNullableWithAggregatesFilter<"VendorProduct"> | string | null
    adminProductPrice?: IntNullableWithAggregatesFilter<"VendorProduct"> | number | null
    designBase64?: StringNullableWithAggregatesFilter<"VendorProduct"> | string | null
    designCloudinaryUrl?: StringNullableWithAggregatesFilter<"VendorProduct"> | string | null
    designCloudinaryPublicId?: StringNullableWithAggregatesFilter<"VendorProduct"> | string | null
    designPositioning?: StringNullableWithAggregatesFilter<"VendorProduct"> | string | null
    designScale?: FloatNullableWithAggregatesFilter<"VendorProduct"> | number | null
    designApplicationMode?: StringNullableWithAggregatesFilter<"VendorProduct"> | string | null
    sizes?: JsonWithAggregatesFilter<"VendorProduct">
    colors?: JsonWithAggregatesFilter<"VendorProduct">
    vendorName?: StringNullableWithAggregatesFilter<"VendorProduct"> | string | null
    vendorDescription?: StringNullableWithAggregatesFilter<"VendorProduct"> | string | null
    vendorStock?: IntWithAggregatesFilter<"VendorProduct"> | number
    basePriceAdmin?: FloatWithAggregatesFilter<"VendorProduct"> | number
    isValidated?: BoolWithAggregatesFilter<"VendorProduct"> | boolean
    validatedAt?: DateTimeNullableWithAggregatesFilter<"VendorProduct"> | Date | string | null
    validatedBy?: IntNullableWithAggregatesFilter<"VendorProduct"> | number | null
    rejectionReason?: StringNullableWithAggregatesFilter<"VendorProduct"> | string | null
    submittedForValidationAt?: DateTimeNullableWithAggregatesFilter<"VendorProduct"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VendorProduct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VendorProduct"> | Date | string
  }

  export type VendorProductImageWhereInput = {
    AND?: VendorProductImageWhereInput | VendorProductImageWhereInput[]
    OR?: VendorProductImageWhereInput[]
    NOT?: VendorProductImageWhereInput | VendorProductImageWhereInput[]
    id?: IntFilter<"VendorProductImage"> | number
    vendorProductId?: IntFilter<"VendorProductImage"> | number
    colorId?: IntNullableFilter<"VendorProductImage"> | number | null
    colorName?: StringNullableFilter<"VendorProductImage"> | string | null
    colorCode?: StringNullableFilter<"VendorProductImage"> | string | null
    imageType?: StringFilter<"VendorProductImage"> | string
    cloudinaryUrl?: StringFilter<"VendorProductImage"> | string
    cloudinaryPublicId?: StringFilter<"VendorProductImage"> | string
    originalImageKey?: StringNullableFilter<"VendorProductImage"> | string | null
    width?: IntNullableFilter<"VendorProductImage"> | number | null
    height?: IntNullableFilter<"VendorProductImage"> | number | null
    fileSize?: IntNullableFilter<"VendorProductImage"> | number | null
    format?: StringNullableFilter<"VendorProductImage"> | string | null
    createdAt?: DateTimeFilter<"VendorProductImage"> | Date | string
    uploadedAt?: DateTimeFilter<"VendorProductImage"> | Date | string
    vendorProduct?: XOR<VendorProductScalarRelationFilter, VendorProductWhereInput>
    colorVariation?: XOR<ColorVariationNullableScalarRelationFilter, ColorVariationWhereInput> | null
  }

  export type VendorProductImageOrderByWithRelationInput = {
    id?: SortOrder
    vendorProductId?: SortOrder
    colorId?: SortOrderInput | SortOrder
    colorName?: SortOrderInput | SortOrder
    colorCode?: SortOrderInput | SortOrder
    imageType?: SortOrder
    cloudinaryUrl?: SortOrder
    cloudinaryPublicId?: SortOrder
    originalImageKey?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    format?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    uploadedAt?: SortOrder
    vendorProduct?: VendorProductOrderByWithRelationInput
    colorVariation?: ColorVariationOrderByWithRelationInput
  }

  export type VendorProductImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VendorProductImageWhereInput | VendorProductImageWhereInput[]
    OR?: VendorProductImageWhereInput[]
    NOT?: VendorProductImageWhereInput | VendorProductImageWhereInput[]
    vendorProductId?: IntFilter<"VendorProductImage"> | number
    colorId?: IntNullableFilter<"VendorProductImage"> | number | null
    colorName?: StringNullableFilter<"VendorProductImage"> | string | null
    colorCode?: StringNullableFilter<"VendorProductImage"> | string | null
    imageType?: StringFilter<"VendorProductImage"> | string
    cloudinaryUrl?: StringFilter<"VendorProductImage"> | string
    cloudinaryPublicId?: StringFilter<"VendorProductImage"> | string
    originalImageKey?: StringNullableFilter<"VendorProductImage"> | string | null
    width?: IntNullableFilter<"VendorProductImage"> | number | null
    height?: IntNullableFilter<"VendorProductImage"> | number | null
    fileSize?: IntNullableFilter<"VendorProductImage"> | number | null
    format?: StringNullableFilter<"VendorProductImage"> | string | null
    createdAt?: DateTimeFilter<"VendorProductImage"> | Date | string
    uploadedAt?: DateTimeFilter<"VendorProductImage"> | Date | string
    vendorProduct?: XOR<VendorProductScalarRelationFilter, VendorProductWhereInput>
    colorVariation?: XOR<ColorVariationNullableScalarRelationFilter, ColorVariationWhereInput> | null
  }, "id">

  export type VendorProductImageOrderByWithAggregationInput = {
    id?: SortOrder
    vendorProductId?: SortOrder
    colorId?: SortOrderInput | SortOrder
    colorName?: SortOrderInput | SortOrder
    colorCode?: SortOrderInput | SortOrder
    imageType?: SortOrder
    cloudinaryUrl?: SortOrder
    cloudinaryPublicId?: SortOrder
    originalImageKey?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    format?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    uploadedAt?: SortOrder
    _count?: VendorProductImageCountOrderByAggregateInput
    _avg?: VendorProductImageAvgOrderByAggregateInput
    _max?: VendorProductImageMaxOrderByAggregateInput
    _min?: VendorProductImageMinOrderByAggregateInput
    _sum?: VendorProductImageSumOrderByAggregateInput
  }

  export type VendorProductImageScalarWhereWithAggregatesInput = {
    AND?: VendorProductImageScalarWhereWithAggregatesInput | VendorProductImageScalarWhereWithAggregatesInput[]
    OR?: VendorProductImageScalarWhereWithAggregatesInput[]
    NOT?: VendorProductImageScalarWhereWithAggregatesInput | VendorProductImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VendorProductImage"> | number
    vendorProductId?: IntWithAggregatesFilter<"VendorProductImage"> | number
    colorId?: IntNullableWithAggregatesFilter<"VendorProductImage"> | number | null
    colorName?: StringNullableWithAggregatesFilter<"VendorProductImage"> | string | null
    colorCode?: StringNullableWithAggregatesFilter<"VendorProductImage"> | string | null
    imageType?: StringWithAggregatesFilter<"VendorProductImage"> | string
    cloudinaryUrl?: StringWithAggregatesFilter<"VendorProductImage"> | string
    cloudinaryPublicId?: StringWithAggregatesFilter<"VendorProductImage"> | string
    originalImageKey?: StringNullableWithAggregatesFilter<"VendorProductImage"> | string | null
    width?: IntNullableWithAggregatesFilter<"VendorProductImage"> | number | null
    height?: IntNullableWithAggregatesFilter<"VendorProductImage"> | number | null
    fileSize?: IntNullableWithAggregatesFilter<"VendorProductImage"> | number | null
    format?: StringNullableWithAggregatesFilter<"VendorProductImage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VendorProductImage"> | Date | string
    uploadedAt?: DateTimeWithAggregatesFilter<"VendorProductImage"> | Date | string
  }

  export type DesignTransformationWhereInput = {
    AND?: DesignTransformationWhereInput | DesignTransformationWhereInput[]
    OR?: DesignTransformationWhereInput[]
    NOT?: DesignTransformationWhereInput | DesignTransformationWhereInput[]
    id?: IntFilter<"DesignTransformation"> | number
    vendorProductId?: IntFilter<"DesignTransformation"> | number
    delimitationIndex?: IntFilter<"DesignTransformation"> | number
    xOffset?: FloatFilter<"DesignTransformation"> | number
    yOffset?: FloatFilter<"DesignTransformation"> | number
    scaleFactor?: FloatFilter<"DesignTransformation"> | number
    positioning?: EnumDesignPositioningFilter<"DesignTransformation"> | $Enums.DesignPositioning
    createdAt?: DateTimeFilter<"DesignTransformation"> | Date | string
    updatedAt?: DateTimeFilter<"DesignTransformation"> | Date | string
    vendorProduct?: XOR<VendorProductScalarRelationFilter, VendorProductWhereInput>
  }

  export type DesignTransformationOrderByWithRelationInput = {
    id?: SortOrder
    vendorProductId?: SortOrder
    delimitationIndex?: SortOrder
    xOffset?: SortOrder
    yOffset?: SortOrder
    scaleFactor?: SortOrder
    positioning?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendorProduct?: VendorProductOrderByWithRelationInput
  }

  export type DesignTransformationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    vendorProductId_delimitationIndex?: DesignTransformationVendorProductIdDelimitationIndexCompoundUniqueInput
    AND?: DesignTransformationWhereInput | DesignTransformationWhereInput[]
    OR?: DesignTransformationWhereInput[]
    NOT?: DesignTransformationWhereInput | DesignTransformationWhereInput[]
    vendorProductId?: IntFilter<"DesignTransformation"> | number
    delimitationIndex?: IntFilter<"DesignTransformation"> | number
    xOffset?: FloatFilter<"DesignTransformation"> | number
    yOffset?: FloatFilter<"DesignTransformation"> | number
    scaleFactor?: FloatFilter<"DesignTransformation"> | number
    positioning?: EnumDesignPositioningFilter<"DesignTransformation"> | $Enums.DesignPositioning
    createdAt?: DateTimeFilter<"DesignTransformation"> | Date | string
    updatedAt?: DateTimeFilter<"DesignTransformation"> | Date | string
    vendorProduct?: XOR<VendorProductScalarRelationFilter, VendorProductWhereInput>
  }, "id" | "vendorProductId_delimitationIndex">

  export type DesignTransformationOrderByWithAggregationInput = {
    id?: SortOrder
    vendorProductId?: SortOrder
    delimitationIndex?: SortOrder
    xOffset?: SortOrder
    yOffset?: SortOrder
    scaleFactor?: SortOrder
    positioning?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DesignTransformationCountOrderByAggregateInput
    _avg?: DesignTransformationAvgOrderByAggregateInput
    _max?: DesignTransformationMaxOrderByAggregateInput
    _min?: DesignTransformationMinOrderByAggregateInput
    _sum?: DesignTransformationSumOrderByAggregateInput
  }

  export type DesignTransformationScalarWhereWithAggregatesInput = {
    AND?: DesignTransformationScalarWhereWithAggregatesInput | DesignTransformationScalarWhereWithAggregatesInput[]
    OR?: DesignTransformationScalarWhereWithAggregatesInput[]
    NOT?: DesignTransformationScalarWhereWithAggregatesInput | DesignTransformationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DesignTransformation"> | number
    vendorProductId?: IntWithAggregatesFilter<"DesignTransformation"> | number
    delimitationIndex?: IntWithAggregatesFilter<"DesignTransformation"> | number
    xOffset?: FloatWithAggregatesFilter<"DesignTransformation"> | number
    yOffset?: FloatWithAggregatesFilter<"DesignTransformation"> | number
    scaleFactor?: FloatWithAggregatesFilter<"DesignTransformation"> | number
    positioning?: EnumDesignPositioningWithAggregatesFilter<"DesignTransformation"> | $Enums.DesignPositioning
    createdAt?: DateTimeWithAggregatesFilter<"DesignTransformation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DesignTransformation"> | Date | string
  }

  export type UserCreateInput = {
    firstName: string
    lastName: string
    email: string
    password: string
    role?: $Enums.Role
    status?: boolean
    photo_profil?: string | null
    login_attempts?: number
    locked_until?: Date | string | null
    last_login_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    must_change_password?: boolean
    vendeur_type?: $Enums.VendeurType | null
    phone?: string | null
    country?: string | null
    address?: string | null
    shop_name?: string | null
    profile_photo_url?: string | null
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    validatedOrders?: OrderCreateNestedManyWithoutValidatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    designs?: DesignCreateNestedManyWithoutVendorInput
    validatedDesigns?: DesignCreateNestedManyWithoutValidatorInput
    validatedProducts?: ProductCreateNestedManyWithoutValidatorInput
    validatedVendorProducts?: VendorProductCreateNestedManyWithoutValidatorInput
    vendorProducts?: VendorProductCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    password: string
    role?: $Enums.Role
    status?: boolean
    photo_profil?: string | null
    login_attempts?: number
    locked_until?: Date | string | null
    last_login_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    must_change_password?: boolean
    vendeur_type?: $Enums.VendeurType | null
    phone?: string | null
    country?: string | null
    address?: string | null
    shop_name?: string | null
    profile_photo_url?: string | null
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    validatedOrders?: OrderUncheckedCreateNestedManyWithoutValidatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    designs?: DesignUncheckedCreateNestedManyWithoutVendorInput
    validatedDesigns?: DesignUncheckedCreateNestedManyWithoutValidatorInput
    validatedProducts?: ProductUncheckedCreateNestedManyWithoutValidatorInput
    validatedVendorProducts?: VendorProductUncheckedCreateNestedManyWithoutValidatorInput
    vendorProducts?: VendorProductUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    validatedOrders?: OrderUpdateManyWithoutValidatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    designs?: DesignUpdateManyWithoutVendorNestedInput
    validatedDesigns?: DesignUpdateManyWithoutValidatorNestedInput
    validatedProducts?: ProductUpdateManyWithoutValidatorNestedInput
    validatedVendorProducts?: VendorProductUpdateManyWithoutValidatorNestedInput
    vendorProducts?: VendorProductUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    validatedOrders?: OrderUncheckedUpdateManyWithoutValidatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    designs?: DesignUncheckedUpdateManyWithoutVendorNestedInput
    validatedDesigns?: DesignUncheckedUpdateManyWithoutValidatorNestedInput
    validatedProducts?: ProductUncheckedUpdateManyWithoutValidatorNestedInput
    validatedVendorProducts?: VendorProductUncheckedUpdateManyWithoutValidatorNestedInput
    vendorProducts?: VendorProductUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    password: string
    role?: $Enums.Role
    status?: boolean
    photo_profil?: string | null
    login_attempts?: number
    locked_until?: Date | string | null
    last_login_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    must_change_password?: boolean
    vendeur_type?: $Enums.VendeurType | null
    phone?: string | null
    country?: string | null
    address?: string | null
    shop_name?: string | null
    profile_photo_url?: string | null
  }

  export type UserUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordResetCreateInput = {
    token: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    usedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPasswordResetsInput
  }

  export type PasswordResetUncheckedCreateInput = {
    id?: number
    token: string
    userId: number
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    usedAt?: Date | string | null
  }

  export type PasswordResetUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPasswordResetsNestedInput
  }

  export type PasswordResetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordResetCreateManyInput = {
    id?: number
    token: string
    userId: number
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    usedAt?: Date | string | null
  }

  export type PasswordResetUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordResetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCreateInput = {
    name: string
    price: number
    stock: number
    status?: $Enums.PublicationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    hasCustomDesigns?: boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    validator?: UserCreateNestedOneWithoutValidatedProductsInput
    categories?: CategoryCreateNestedManyWithoutProductsInput
    sizes?: ProductSizeCreateNestedManyWithoutProductInput
    colorVariations?: ColorVariationCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    vendorProducts?: VendorProductCreateNestedManyWithoutBaseProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    name: string
    price: number
    stock: number
    status?: $Enums.PublicationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isValidated?: boolean
    validatedAt?: Date | string | null
    validatedBy?: number | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    hasCustomDesigns?: boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    sizes?: ProductSizeUncheckedCreateNestedManyWithoutProductInput
    colorVariations?: ColorVariationUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    vendorProducts?: VendorProductUncheckedCreateNestedManyWithoutBaseProductInput
  }

  export type ProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasCustomDesigns?: BoolFieldUpdateOperationsInput | boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    validator?: UserUpdateOneWithoutValidatedProductsNestedInput
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    sizes?: ProductSizeUpdateManyWithoutProductNestedInput
    colorVariations?: ColorVariationUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    vendorProducts?: VendorProductUpdateManyWithoutBaseProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasCustomDesigns?: BoolFieldUpdateOperationsInput | boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    sizes?: ProductSizeUncheckedUpdateManyWithoutProductNestedInput
    colorVariations?: ColorVariationUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    vendorProducts?: VendorProductUncheckedUpdateManyWithoutBaseProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    name: string
    price: number
    stock: number
    status?: $Enums.PublicationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isValidated?: boolean
    validatedAt?: Date | string | null
    validatedBy?: number | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    hasCustomDesigns?: boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasCustomDesigns?: BoolFieldUpdateOperationsInput | boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasCustomDesigns?: BoolFieldUpdateOperationsInput | boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductSizeCreateInput = {
    sizeName: string
    product: ProductCreateNestedOneWithoutSizesInput
  }

  export type ProductSizeUncheckedCreateInput = {
    id?: number
    productId: number
    sizeName: string
  }

  export type ProductSizeUpdateInput = {
    sizeName?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutSizesNestedInput
  }

  export type ProductSizeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    sizeName?: StringFieldUpdateOperationsInput | string
  }

  export type ProductSizeCreateManyInput = {
    id?: number
    productId: number
    sizeName: string
  }

  export type ProductSizeUpdateManyMutationInput = {
    sizeName?: StringFieldUpdateOperationsInput | string
  }

  export type ProductSizeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    sizeName?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryCreateInput = {
    name: string
    description?: string | null
    products?: ProductCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ColorVariationCreateInput = {
    name: string
    colorCode: string
    product: ProductCreateNestedOneWithoutColorVariationsInput
    images?: ProductImageCreateNestedManyWithoutColorVariationInput
    orderItems?: OrderItemCreateNestedManyWithoutColorVariationInput
    vendorProductImages?: VendorProductImageCreateNestedManyWithoutColorVariationInput
  }

  export type ColorVariationUncheckedCreateInput = {
    id?: number
    name: string
    colorCode: string
    productId: number
    images?: ProductImageUncheckedCreateNestedManyWithoutColorVariationInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutColorVariationInput
    vendorProductImages?: VendorProductImageUncheckedCreateNestedManyWithoutColorVariationInput
  }

  export type ColorVariationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    colorCode?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutColorVariationsNestedInput
    images?: ProductImageUpdateManyWithoutColorVariationNestedInput
    orderItems?: OrderItemUpdateManyWithoutColorVariationNestedInput
    vendorProductImages?: VendorProductImageUpdateManyWithoutColorVariationNestedInput
  }

  export type ColorVariationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    colorCode?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    images?: ProductImageUncheckedUpdateManyWithoutColorVariationNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutColorVariationNestedInput
    vendorProductImages?: VendorProductImageUncheckedUpdateManyWithoutColorVariationNestedInput
  }

  export type ColorVariationCreateManyInput = {
    id?: number
    name: string
    colorCode: string
    productId: number
  }

  export type ColorVariationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    colorCode?: StringFieldUpdateOperationsInput | string
  }

  export type ColorVariationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    colorCode?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductImageCreateInput = {
    view: string
    url: string
    publicId: string
    naturalWidth?: number | null
    naturalHeight?: number | null
    designUrl?: string | null
    designPublicId?: string | null
    designFileName?: string | null
    designUploadDate?: Date | string | null
    designSize?: number | null
    designOriginalName?: string | null
    designDescription?: string | null
    isDesignActive?: boolean
    colorVariation: ColorVariationCreateNestedOneWithoutImagesInput
    delimitations?: DelimitationCreateNestedManyWithoutProductImageInput
  }

  export type ProductImageUncheckedCreateInput = {
    id?: number
    view: string
    url: string
    publicId: string
    naturalWidth?: number | null
    naturalHeight?: number | null
    designUrl?: string | null
    designPublicId?: string | null
    designFileName?: string | null
    designUploadDate?: Date | string | null
    designSize?: number | null
    designOriginalName?: string | null
    designDescription?: string | null
    isDesignActive?: boolean
    colorVariationId: number
    delimitations?: DelimitationUncheckedCreateNestedManyWithoutProductImageInput
  }

  export type ProductImageUpdateInput = {
    view?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    naturalWidth?: NullableIntFieldUpdateOperationsInput | number | null
    naturalHeight?: NullableIntFieldUpdateOperationsInput | number | null
    designUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designFileName?: NullableStringFieldUpdateOperationsInput | string | null
    designUploadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designSize?: NullableIntFieldUpdateOperationsInput | number | null
    designOriginalName?: NullableStringFieldUpdateOperationsInput | string | null
    designDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isDesignActive?: BoolFieldUpdateOperationsInput | boolean
    colorVariation?: ColorVariationUpdateOneRequiredWithoutImagesNestedInput
    delimitations?: DelimitationUpdateManyWithoutProductImageNestedInput
  }

  export type ProductImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    view?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    naturalWidth?: NullableIntFieldUpdateOperationsInput | number | null
    naturalHeight?: NullableIntFieldUpdateOperationsInput | number | null
    designUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designFileName?: NullableStringFieldUpdateOperationsInput | string | null
    designUploadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designSize?: NullableIntFieldUpdateOperationsInput | number | null
    designOriginalName?: NullableStringFieldUpdateOperationsInput | string | null
    designDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isDesignActive?: BoolFieldUpdateOperationsInput | boolean
    colorVariationId?: IntFieldUpdateOperationsInput | number
    delimitations?: DelimitationUncheckedUpdateManyWithoutProductImageNestedInput
  }

  export type ProductImageCreateManyInput = {
    id?: number
    view: string
    url: string
    publicId: string
    naturalWidth?: number | null
    naturalHeight?: number | null
    designUrl?: string | null
    designPublicId?: string | null
    designFileName?: string | null
    designUploadDate?: Date | string | null
    designSize?: number | null
    designOriginalName?: string | null
    designDescription?: string | null
    isDesignActive?: boolean
    colorVariationId: number
  }

  export type ProductImageUpdateManyMutationInput = {
    view?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    naturalWidth?: NullableIntFieldUpdateOperationsInput | number | null
    naturalHeight?: NullableIntFieldUpdateOperationsInput | number | null
    designUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designFileName?: NullableStringFieldUpdateOperationsInput | string | null
    designUploadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designSize?: NullableIntFieldUpdateOperationsInput | number | null
    designOriginalName?: NullableStringFieldUpdateOperationsInput | string | null
    designDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isDesignActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    view?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    naturalWidth?: NullableIntFieldUpdateOperationsInput | number | null
    naturalHeight?: NullableIntFieldUpdateOperationsInput | number | null
    designUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designFileName?: NullableStringFieldUpdateOperationsInput | string | null
    designUploadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designSize?: NullableIntFieldUpdateOperationsInput | number | null
    designOriginalName?: NullableStringFieldUpdateOperationsInput | string | null
    designDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isDesignActive?: BoolFieldUpdateOperationsInput | boolean
    colorVariationId?: IntFieldUpdateOperationsInput | number
  }

  export type DelimitationCreateInput = {
    x: number
    y: number
    width: number
    height: number
    rotation?: number
    name?: string | null
    coordinateType?: $Enums.CoordinateType
    absoluteX?: number | null
    absoluteY?: number | null
    absoluteWidth?: number | null
    absoluteHeight?: number | null
    originalImageWidth?: number | null
    originalImageHeight?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceWidth?: number
    referenceHeight?: number
    productImage: ProductImageCreateNestedOneWithoutDelimitationsInput
  }

  export type DelimitationUncheckedCreateInput = {
    id?: number
    x: number
    y: number
    width: number
    height: number
    rotation?: number
    name?: string | null
    coordinateType?: $Enums.CoordinateType
    absoluteX?: number | null
    absoluteY?: number | null
    absoluteWidth?: number | null
    absoluteHeight?: number | null
    originalImageWidth?: number | null
    originalImageHeight?: number | null
    productImageId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceWidth?: number
    referenceHeight?: number
  }

  export type DelimitationUpdateInput = {
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    coordinateType?: EnumCoordinateTypeFieldUpdateOperationsInput | $Enums.CoordinateType
    absoluteX?: NullableFloatFieldUpdateOperationsInput | number | null
    absoluteY?: NullableFloatFieldUpdateOperationsInput | number | null
    absoluteWidth?: NullableFloatFieldUpdateOperationsInput | number | null
    absoluteHeight?: NullableFloatFieldUpdateOperationsInput | number | null
    originalImageWidth?: NullableIntFieldUpdateOperationsInput | number | null
    originalImageHeight?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceWidth?: IntFieldUpdateOperationsInput | number
    referenceHeight?: IntFieldUpdateOperationsInput | number
    productImage?: ProductImageUpdateOneRequiredWithoutDelimitationsNestedInput
  }

  export type DelimitationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    coordinateType?: EnumCoordinateTypeFieldUpdateOperationsInput | $Enums.CoordinateType
    absoluteX?: NullableFloatFieldUpdateOperationsInput | number | null
    absoluteY?: NullableFloatFieldUpdateOperationsInput | number | null
    absoluteWidth?: NullableFloatFieldUpdateOperationsInput | number | null
    absoluteHeight?: NullableFloatFieldUpdateOperationsInput | number | null
    originalImageWidth?: NullableIntFieldUpdateOperationsInput | number | null
    originalImageHeight?: NullableIntFieldUpdateOperationsInput | number | null
    productImageId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceWidth?: IntFieldUpdateOperationsInput | number
    referenceHeight?: IntFieldUpdateOperationsInput | number
  }

  export type DelimitationCreateManyInput = {
    id?: number
    x: number
    y: number
    width: number
    height: number
    rotation?: number
    name?: string | null
    coordinateType?: $Enums.CoordinateType
    absoluteX?: number | null
    absoluteY?: number | null
    absoluteWidth?: number | null
    absoluteHeight?: number | null
    originalImageWidth?: number | null
    originalImageHeight?: number | null
    productImageId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceWidth?: number
    referenceHeight?: number
  }

  export type DelimitationUpdateManyMutationInput = {
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    coordinateType?: EnumCoordinateTypeFieldUpdateOperationsInput | $Enums.CoordinateType
    absoluteX?: NullableFloatFieldUpdateOperationsInput | number | null
    absoluteY?: NullableFloatFieldUpdateOperationsInput | number | null
    absoluteWidth?: NullableFloatFieldUpdateOperationsInput | number | null
    absoluteHeight?: NullableFloatFieldUpdateOperationsInput | number | null
    originalImageWidth?: NullableIntFieldUpdateOperationsInput | number | null
    originalImageHeight?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceWidth?: IntFieldUpdateOperationsInput | number
    referenceHeight?: IntFieldUpdateOperationsInput | number
  }

  export type DelimitationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    coordinateType?: EnumCoordinateTypeFieldUpdateOperationsInput | $Enums.CoordinateType
    absoluteX?: NullableFloatFieldUpdateOperationsInput | number | null
    absoluteY?: NullableFloatFieldUpdateOperationsInput | number | null
    absoluteWidth?: NullableFloatFieldUpdateOperationsInput | number | null
    absoluteHeight?: NullableFloatFieldUpdateOperationsInput | number | null
    originalImageWidth?: NullableIntFieldUpdateOperationsInput | number | null
    originalImageHeight?: NullableIntFieldUpdateOperationsInput | number | null
    productImageId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceWidth?: IntFieldUpdateOperationsInput | number
    referenceHeight?: IntFieldUpdateOperationsInput | number
  }

  export type OrderCreateInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    totalAmount: number
    phoneNumber: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    shippingName?: string | null
    shippingStreet?: string | null
    shippingCity?: string | null
    shippingRegion?: string | null
    shippingPostalCode?: string | null
    shippingCountry?: string | null
    shippingAddressFull?: string | null
    user: UserCreateNestedOneWithoutOrdersInput
    validator?: UserCreateNestedOneWithoutValidatedOrdersInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    orderNumber: string
    userId: number
    status?: $Enums.OrderStatus
    totalAmount: number
    phoneNumber: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    validatedBy?: number | null
    shippingName?: string | null
    shippingStreet?: string | null
    shippingCity?: string | null
    shippingRegion?: string | null
    shippingPostalCode?: string | null
    shippingCountry?: string | null
    shippingAddressFull?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStreet?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCity?: NullableStringFieldUpdateOperationsInput | string | null
    shippingRegion?: NullableStringFieldUpdateOperationsInput | string | null
    shippingPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddressFull?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    validator?: UserUpdateOneWithoutValidatedOrdersNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    shippingName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStreet?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCity?: NullableStringFieldUpdateOperationsInput | string | null
    shippingRegion?: NullableStringFieldUpdateOperationsInput | string | null
    shippingPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddressFull?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: number
    orderNumber: string
    userId: number
    status?: $Enums.OrderStatus
    totalAmount: number
    phoneNumber: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    validatedBy?: number | null
    shippingName?: string | null
    shippingStreet?: string | null
    shippingCity?: string | null
    shippingRegion?: string | null
    shippingPostalCode?: string | null
    shippingCountry?: string | null
    shippingAddressFull?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStreet?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCity?: NullableStringFieldUpdateOperationsInput | string | null
    shippingRegion?: NullableStringFieldUpdateOperationsInput | string | null
    shippingPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddressFull?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    shippingName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStreet?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCity?: NullableStringFieldUpdateOperationsInput | string | null
    shippingRegion?: NullableStringFieldUpdateOperationsInput | string | null
    shippingPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddressFull?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateInput = {
    quantity: number
    unitPrice: number
    size?: string | null
    color?: string | null
    order: OrderCreateNestedOneWithoutOrderItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
    colorVariation?: ColorVariationCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: number
    orderId: number
    productId: number
    quantity: number
    unitPrice: number
    size?: string | null
    color?: string | null
    colorId?: number | null
  }

  export type OrderItemUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
    colorVariation?: ColorVariationUpdateOneWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrderItemCreateManyInput = {
    id?: number
    orderId: number
    productId: number
    quantity: number
    unitPrice: number
    size?: string | null
    color?: string | null
    colorId?: number | null
  }

  export type OrderItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NotificationCreateInput = {
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    userId: number
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NotificationUpdateInput = {
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateManyInput = {
    id?: number
    userId: number
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NotificationUpdateManyMutationInput = {
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DesignCreateInput = {
    name: string
    description?: string | null
    price: number
    category: $Enums.DesignCategory
    imageUrl: string
    thumbnailUrl?: string | null
    cloudinaryPublicId: string
    thumbnailPublicId?: string | null
    fileSize: number
    originalFileName: string
    dimensions: JsonNullValueInput | InputJsonValue
    format: string
    tags?: DesignCreatetagsInput | string[]
    isDraft?: boolean
    isPublished?: boolean
    isPending?: boolean
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    views?: number
    likes?: number
    earnings?: number
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    vendor: UserCreateNestedOneWithoutDesignsInput
    validator?: UserCreateNestedOneWithoutValidatedDesignsInput
  }

  export type DesignUncheckedCreateInput = {
    id?: number
    vendorId: number
    name: string
    description?: string | null
    price: number
    category: $Enums.DesignCategory
    imageUrl: string
    thumbnailUrl?: string | null
    cloudinaryPublicId: string
    thumbnailPublicId?: string | null
    fileSize: number
    originalFileName: string
    dimensions: JsonNullValueInput | InputJsonValue
    format: string
    tags?: DesignCreatetagsInput | string[]
    isDraft?: boolean
    isPublished?: boolean
    isPending?: boolean
    isValidated?: boolean
    validatedAt?: Date | string | null
    validatedBy?: number | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    views?: number
    likes?: number
    earnings?: number
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type DesignUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    category?: EnumDesignCategoryFieldUpdateOperationsInput | $Enums.DesignCategory
    imageUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cloudinaryPublicId?: StringFieldUpdateOperationsInput | string
    thumbnailPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: IntFieldUpdateOperationsInput | number
    originalFileName?: StringFieldUpdateOperationsInput | string
    dimensions?: JsonNullValueInput | InputJsonValue
    format?: StringFieldUpdateOperationsInput | string
    tags?: DesignUpdatetagsInput | string[]
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPending?: BoolFieldUpdateOperationsInput | boolean
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendor?: UserUpdateOneRequiredWithoutDesignsNestedInput
    validator?: UserUpdateOneWithoutValidatedDesignsNestedInput
  }

  export type DesignUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    category?: EnumDesignCategoryFieldUpdateOperationsInput | $Enums.DesignCategory
    imageUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cloudinaryPublicId?: StringFieldUpdateOperationsInput | string
    thumbnailPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: IntFieldUpdateOperationsInput | number
    originalFileName?: StringFieldUpdateOperationsInput | string
    dimensions?: JsonNullValueInput | InputJsonValue
    format?: StringFieldUpdateOperationsInput | string
    tags?: DesignUpdatetagsInput | string[]
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPending?: BoolFieldUpdateOperationsInput | boolean
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DesignCreateManyInput = {
    id?: number
    vendorId: number
    name: string
    description?: string | null
    price: number
    category: $Enums.DesignCategory
    imageUrl: string
    thumbnailUrl?: string | null
    cloudinaryPublicId: string
    thumbnailPublicId?: string | null
    fileSize: number
    originalFileName: string
    dimensions: JsonNullValueInput | InputJsonValue
    format: string
    tags?: DesignCreatetagsInput | string[]
    isDraft?: boolean
    isPublished?: boolean
    isPending?: boolean
    isValidated?: boolean
    validatedAt?: Date | string | null
    validatedBy?: number | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    views?: number
    likes?: number
    earnings?: number
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type DesignUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    category?: EnumDesignCategoryFieldUpdateOperationsInput | $Enums.DesignCategory
    imageUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cloudinaryPublicId?: StringFieldUpdateOperationsInput | string
    thumbnailPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: IntFieldUpdateOperationsInput | number
    originalFileName?: StringFieldUpdateOperationsInput | string
    dimensions?: JsonNullValueInput | InputJsonValue
    format?: StringFieldUpdateOperationsInput | string
    tags?: DesignUpdatetagsInput | string[]
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPending?: BoolFieldUpdateOperationsInput | boolean
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DesignUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    category?: EnumDesignCategoryFieldUpdateOperationsInput | $Enums.DesignCategory
    imageUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cloudinaryPublicId?: StringFieldUpdateOperationsInput | string
    thumbnailPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: IntFieldUpdateOperationsInput | number
    originalFileName?: StringFieldUpdateOperationsInput | string
    dimensions?: JsonNullValueInput | InputJsonValue
    format?: StringFieldUpdateOperationsInput | string
    tags?: DesignUpdatetagsInput | string[]
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPending?: BoolFieldUpdateOperationsInput | boolean
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VendorProductCreateInput = {
    name: string
    description?: string | null
    price: number
    stock?: number
    status?: $Enums.VendorProductStatus
    adminProductName?: string | null
    adminProductDescription?: string | null
    adminProductPrice?: number | null
    designBase64?: string | null
    designCloudinaryUrl?: string | null
    designCloudinaryPublicId?: string | null
    designPositioning?: string | null
    designScale?: number | null
    designApplicationMode?: string | null
    sizes: JsonNullValueInput | InputJsonValue
    colors: JsonNullValueInput | InputJsonValue
    vendorName?: string | null
    vendorDescription?: string | null
    vendorStock?: number
    basePriceAdmin?: number
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    validator?: UserCreateNestedOneWithoutValidatedVendorProductsInput
    vendor: UserCreateNestedOneWithoutVendorProductsInput
    baseProduct: ProductCreateNestedOneWithoutVendorProductsInput
    images?: VendorProductImageCreateNestedManyWithoutVendorProductInput
    transformations?: DesignTransformationCreateNestedManyWithoutVendorProductInput
  }

  export type VendorProductUncheckedCreateInput = {
    id?: number
    baseProductId: number
    vendorId: number
    name: string
    description?: string | null
    price: number
    stock?: number
    status?: $Enums.VendorProductStatus
    adminProductName?: string | null
    adminProductDescription?: string | null
    adminProductPrice?: number | null
    designBase64?: string | null
    designCloudinaryUrl?: string | null
    designCloudinaryPublicId?: string | null
    designPositioning?: string | null
    designScale?: number | null
    designApplicationMode?: string | null
    sizes: JsonNullValueInput | InputJsonValue
    colors: JsonNullValueInput | InputJsonValue
    vendorName?: string | null
    vendorDescription?: string | null
    vendorStock?: number
    basePriceAdmin?: number
    isValidated?: boolean
    validatedAt?: Date | string | null
    validatedBy?: number | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VendorProductImageUncheckedCreateNestedManyWithoutVendorProductInput
    transformations?: DesignTransformationUncheckedCreateNestedManyWithoutVendorProductInput
  }

  export type VendorProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumVendorProductStatusFieldUpdateOperationsInput | $Enums.VendorProductStatus
    adminProductName?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductPrice?: NullableIntFieldUpdateOperationsInput | number | null
    designBase64?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designPositioning?: NullableStringFieldUpdateOperationsInput | string | null
    designScale?: NullableFloatFieldUpdateOperationsInput | number | null
    designApplicationMode?: NullableStringFieldUpdateOperationsInput | string | null
    sizes?: JsonNullValueInput | InputJsonValue
    colors?: JsonNullValueInput | InputJsonValue
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    vendorStock?: IntFieldUpdateOperationsInput | number
    basePriceAdmin?: FloatFieldUpdateOperationsInput | number
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validator?: UserUpdateOneWithoutValidatedVendorProductsNestedInput
    vendor?: UserUpdateOneRequiredWithoutVendorProductsNestedInput
    baseProduct?: ProductUpdateOneRequiredWithoutVendorProductsNestedInput
    images?: VendorProductImageUpdateManyWithoutVendorProductNestedInput
    transformations?: DesignTransformationUpdateManyWithoutVendorProductNestedInput
  }

  export type VendorProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    baseProductId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumVendorProductStatusFieldUpdateOperationsInput | $Enums.VendorProductStatus
    adminProductName?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductPrice?: NullableIntFieldUpdateOperationsInput | number | null
    designBase64?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designPositioning?: NullableStringFieldUpdateOperationsInput | string | null
    designScale?: NullableFloatFieldUpdateOperationsInput | number | null
    designApplicationMode?: NullableStringFieldUpdateOperationsInput | string | null
    sizes?: JsonNullValueInput | InputJsonValue
    colors?: JsonNullValueInput | InputJsonValue
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    vendorStock?: IntFieldUpdateOperationsInput | number
    basePriceAdmin?: FloatFieldUpdateOperationsInput | number
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VendorProductImageUncheckedUpdateManyWithoutVendorProductNestedInput
    transformations?: DesignTransformationUncheckedUpdateManyWithoutVendorProductNestedInput
  }

  export type VendorProductCreateManyInput = {
    id?: number
    baseProductId: number
    vendorId: number
    name: string
    description?: string | null
    price: number
    stock?: number
    status?: $Enums.VendorProductStatus
    adminProductName?: string | null
    adminProductDescription?: string | null
    adminProductPrice?: number | null
    designBase64?: string | null
    designCloudinaryUrl?: string | null
    designCloudinaryPublicId?: string | null
    designPositioning?: string | null
    designScale?: number | null
    designApplicationMode?: string | null
    sizes: JsonNullValueInput | InputJsonValue
    colors: JsonNullValueInput | InputJsonValue
    vendorName?: string | null
    vendorDescription?: string | null
    vendorStock?: number
    basePriceAdmin?: number
    isValidated?: boolean
    validatedAt?: Date | string | null
    validatedBy?: number | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumVendorProductStatusFieldUpdateOperationsInput | $Enums.VendorProductStatus
    adminProductName?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductPrice?: NullableIntFieldUpdateOperationsInput | number | null
    designBase64?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designPositioning?: NullableStringFieldUpdateOperationsInput | string | null
    designScale?: NullableFloatFieldUpdateOperationsInput | number | null
    designApplicationMode?: NullableStringFieldUpdateOperationsInput | string | null
    sizes?: JsonNullValueInput | InputJsonValue
    colors?: JsonNullValueInput | InputJsonValue
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    vendorStock?: IntFieldUpdateOperationsInput | number
    basePriceAdmin?: FloatFieldUpdateOperationsInput | number
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    baseProductId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumVendorProductStatusFieldUpdateOperationsInput | $Enums.VendorProductStatus
    adminProductName?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductPrice?: NullableIntFieldUpdateOperationsInput | number | null
    designBase64?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designPositioning?: NullableStringFieldUpdateOperationsInput | string | null
    designScale?: NullableFloatFieldUpdateOperationsInput | number | null
    designApplicationMode?: NullableStringFieldUpdateOperationsInput | string | null
    sizes?: JsonNullValueInput | InputJsonValue
    colors?: JsonNullValueInput | InputJsonValue
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    vendorStock?: IntFieldUpdateOperationsInput | number
    basePriceAdmin?: FloatFieldUpdateOperationsInput | number
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorProductImageCreateInput = {
    colorName?: string | null
    colorCode?: string | null
    imageType?: string
    cloudinaryUrl: string
    cloudinaryPublicId: string
    originalImageKey?: string | null
    width?: number | null
    height?: number | null
    fileSize?: number | null
    format?: string | null
    createdAt?: Date | string
    uploadedAt?: Date | string
    vendorProduct: VendorProductCreateNestedOneWithoutImagesInput
    colorVariation?: ColorVariationCreateNestedOneWithoutVendorProductImagesInput
  }

  export type VendorProductImageUncheckedCreateInput = {
    id?: number
    vendorProductId: number
    colorId?: number | null
    colorName?: string | null
    colorCode?: string | null
    imageType?: string
    cloudinaryUrl: string
    cloudinaryPublicId: string
    originalImageKey?: string | null
    width?: number | null
    height?: number | null
    fileSize?: number | null
    format?: string | null
    createdAt?: Date | string
    uploadedAt?: Date | string
  }

  export type VendorProductImageUpdateInput = {
    colorName?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: StringFieldUpdateOperationsInput | string
    cloudinaryUrl?: StringFieldUpdateOperationsInput | string
    cloudinaryPublicId?: StringFieldUpdateOperationsInput | string
    originalImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorProduct?: VendorProductUpdateOneRequiredWithoutImagesNestedInput
    colorVariation?: ColorVariationUpdateOneWithoutVendorProductImagesNestedInput
  }

  export type VendorProductImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorProductId?: IntFieldUpdateOperationsInput | number
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    colorName?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: StringFieldUpdateOperationsInput | string
    cloudinaryUrl?: StringFieldUpdateOperationsInput | string
    cloudinaryPublicId?: StringFieldUpdateOperationsInput | string
    originalImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorProductImageCreateManyInput = {
    id?: number
    vendorProductId: number
    colorId?: number | null
    colorName?: string | null
    colorCode?: string | null
    imageType?: string
    cloudinaryUrl: string
    cloudinaryPublicId: string
    originalImageKey?: string | null
    width?: number | null
    height?: number | null
    fileSize?: number | null
    format?: string | null
    createdAt?: Date | string
    uploadedAt?: Date | string
  }

  export type VendorProductImageUpdateManyMutationInput = {
    colorName?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: StringFieldUpdateOperationsInput | string
    cloudinaryUrl?: StringFieldUpdateOperationsInput | string
    cloudinaryPublicId?: StringFieldUpdateOperationsInput | string
    originalImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorProductImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorProductId?: IntFieldUpdateOperationsInput | number
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    colorName?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: StringFieldUpdateOperationsInput | string
    cloudinaryUrl?: StringFieldUpdateOperationsInput | string
    cloudinaryPublicId?: StringFieldUpdateOperationsInput | string
    originalImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignTransformationCreateInput = {
    delimitationIndex: number
    xOffset?: number
    yOffset?: number
    scaleFactor?: number
    positioning?: $Enums.DesignPositioning
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorProduct: VendorProductCreateNestedOneWithoutTransformationsInput
  }

  export type DesignTransformationUncheckedCreateInput = {
    id?: number
    vendorProductId: number
    delimitationIndex: number
    xOffset?: number
    yOffset?: number
    scaleFactor?: number
    positioning?: $Enums.DesignPositioning
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignTransformationUpdateInput = {
    delimitationIndex?: IntFieldUpdateOperationsInput | number
    xOffset?: FloatFieldUpdateOperationsInput | number
    yOffset?: FloatFieldUpdateOperationsInput | number
    scaleFactor?: FloatFieldUpdateOperationsInput | number
    positioning?: EnumDesignPositioningFieldUpdateOperationsInput | $Enums.DesignPositioning
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorProduct?: VendorProductUpdateOneRequiredWithoutTransformationsNestedInput
  }

  export type DesignTransformationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorProductId?: IntFieldUpdateOperationsInput | number
    delimitationIndex?: IntFieldUpdateOperationsInput | number
    xOffset?: FloatFieldUpdateOperationsInput | number
    yOffset?: FloatFieldUpdateOperationsInput | number
    scaleFactor?: FloatFieldUpdateOperationsInput | number
    positioning?: EnumDesignPositioningFieldUpdateOperationsInput | $Enums.DesignPositioning
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignTransformationCreateManyInput = {
    id?: number
    vendorProductId: number
    delimitationIndex: number
    xOffset?: number
    yOffset?: number
    scaleFactor?: number
    positioning?: $Enums.DesignPositioning
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignTransformationUpdateManyMutationInput = {
    delimitationIndex?: IntFieldUpdateOperationsInput | number
    xOffset?: FloatFieldUpdateOperationsInput | number
    yOffset?: FloatFieldUpdateOperationsInput | number
    scaleFactor?: FloatFieldUpdateOperationsInput | number
    positioning?: EnumDesignPositioningFieldUpdateOperationsInput | $Enums.DesignPositioning
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignTransformationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorProductId?: IntFieldUpdateOperationsInput | number
    delimitationIndex?: IntFieldUpdateOperationsInput | number
    xOffset?: FloatFieldUpdateOperationsInput | number
    yOffset?: FloatFieldUpdateOperationsInput | number
    scaleFactor?: FloatFieldUpdateOperationsInput | number
    positioning?: EnumDesignPositioningFieldUpdateOperationsInput | $Enums.DesignPositioning
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumVendeurTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VendeurType | EnumVendeurTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VendeurType[] | ListEnumVendeurTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VendeurType[] | ListEnumVendeurTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVendeurTypeNullableFilter<$PrismaModel> | $Enums.VendeurType | null
  }

  export type PasswordResetListRelationFilter = {
    every?: PasswordResetWhereInput
    some?: PasswordResetWhereInput
    none?: PasswordResetWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type DesignListRelationFilter = {
    every?: DesignWhereInput
    some?: DesignWhereInput
    none?: DesignWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type VendorProductListRelationFilter = {
    every?: VendorProductWhereInput
    some?: VendorProductWhereInput
    none?: VendorProductWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PasswordResetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DesignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    photo_profil?: SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrder
    last_login_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    must_change_password?: SortOrder
    vendeur_type?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    address?: SortOrder
    shop_name?: SortOrder
    profile_photo_url?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    login_attempts?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    photo_profil?: SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrder
    last_login_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    must_change_password?: SortOrder
    vendeur_type?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    address?: SortOrder
    shop_name?: SortOrder
    profile_photo_url?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    photo_profil?: SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrder
    last_login_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    must_change_password?: SortOrder
    vendeur_type?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    address?: SortOrder
    shop_name?: SortOrder
    profile_photo_url?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    login_attempts?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumVendeurTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VendeurType | EnumVendeurTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VendeurType[] | ListEnumVendeurTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VendeurType[] | ListEnumVendeurTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVendeurTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.VendeurType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVendeurTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumVendeurTypeNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PasswordResetCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    usedAt?: SortOrder
  }

  export type PasswordResetAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PasswordResetMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    usedAt?: SortOrder
  }

  export type PasswordResetMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    usedAt?: SortOrder
  }

  export type PasswordResetSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumPublicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PublicationStatus | EnumPublicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublicationStatusFilter<$PrismaModel> | $Enums.PublicationStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type ProductSizeListRelationFilter = {
    every?: ProductSizeWhereInput
    some?: ProductSizeWhereInput
    none?: ProductSizeWhereInput
  }

  export type ColorVariationListRelationFilter = {
    every?: ColorVariationWhereInput
    some?: ColorVariationWhereInput
    none?: ColorVariationWhereInput
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductSizeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ColorVariationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isValidated?: SortOrder
    validatedAt?: SortOrder
    validatedBy?: SortOrder
    rejectionReason?: SortOrder
    submittedForValidationAt?: SortOrder
    hasCustomDesigns?: SortOrder
    designsMetadata?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    validatedBy?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isValidated?: SortOrder
    validatedAt?: SortOrder
    validatedBy?: SortOrder
    rejectionReason?: SortOrder
    submittedForValidationAt?: SortOrder
    hasCustomDesigns?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isValidated?: SortOrder
    validatedAt?: SortOrder
    validatedBy?: SortOrder
    rejectionReason?: SortOrder
    submittedForValidationAt?: SortOrder
    hasCustomDesigns?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    validatedBy?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumPublicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PublicationStatus | EnumPublicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.PublicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPublicationStatusFilter<$PrismaModel>
    _max?: NestedEnumPublicationStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ProductSizeCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sizeName?: SortOrder
  }

  export type ProductSizeAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ProductSizeMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sizeName?: SortOrder
  }

  export type ProductSizeMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sizeName?: SortOrder
  }

  export type ProductSizeSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductImageListRelationFilter = {
    every?: ProductImageWhereInput
    some?: ProductImageWhereInput
    none?: ProductImageWhereInput
  }

  export type VendorProductImageListRelationFilter = {
    every?: VendorProductImageWhereInput
    some?: VendorProductImageWhereInput
    none?: VendorProductImageWhereInput
  }

  export type ProductImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorProductImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ColorVariationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    colorCode?: SortOrder
    productId?: SortOrder
  }

  export type ColorVariationAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ColorVariationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    colorCode?: SortOrder
    productId?: SortOrder
  }

  export type ColorVariationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    colorCode?: SortOrder
    productId?: SortOrder
  }

  export type ColorVariationSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ColorVariationScalarRelationFilter = {
    is?: ColorVariationWhereInput
    isNot?: ColorVariationWhereInput
  }

  export type DelimitationListRelationFilter = {
    every?: DelimitationWhereInput
    some?: DelimitationWhereInput
    none?: DelimitationWhereInput
  }

  export type DelimitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductImageCountOrderByAggregateInput = {
    id?: SortOrder
    view?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    naturalWidth?: SortOrder
    naturalHeight?: SortOrder
    designUrl?: SortOrder
    designPublicId?: SortOrder
    designFileName?: SortOrder
    designUploadDate?: SortOrder
    designSize?: SortOrder
    designOriginalName?: SortOrder
    designDescription?: SortOrder
    isDesignActive?: SortOrder
    colorVariationId?: SortOrder
  }

  export type ProductImageAvgOrderByAggregateInput = {
    id?: SortOrder
    naturalWidth?: SortOrder
    naturalHeight?: SortOrder
    designSize?: SortOrder
    colorVariationId?: SortOrder
  }

  export type ProductImageMaxOrderByAggregateInput = {
    id?: SortOrder
    view?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    naturalWidth?: SortOrder
    naturalHeight?: SortOrder
    designUrl?: SortOrder
    designPublicId?: SortOrder
    designFileName?: SortOrder
    designUploadDate?: SortOrder
    designSize?: SortOrder
    designOriginalName?: SortOrder
    designDescription?: SortOrder
    isDesignActive?: SortOrder
    colorVariationId?: SortOrder
  }

  export type ProductImageMinOrderByAggregateInput = {
    id?: SortOrder
    view?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    naturalWidth?: SortOrder
    naturalHeight?: SortOrder
    designUrl?: SortOrder
    designPublicId?: SortOrder
    designFileName?: SortOrder
    designUploadDate?: SortOrder
    designSize?: SortOrder
    designOriginalName?: SortOrder
    designDescription?: SortOrder
    isDesignActive?: SortOrder
    colorVariationId?: SortOrder
  }

  export type ProductImageSumOrderByAggregateInput = {
    id?: SortOrder
    naturalWidth?: SortOrder
    naturalHeight?: SortOrder
    designSize?: SortOrder
    colorVariationId?: SortOrder
  }

  export type EnumCoordinateTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CoordinateType | EnumCoordinateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CoordinateType[] | ListEnumCoordinateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoordinateType[] | ListEnumCoordinateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCoordinateTypeFilter<$PrismaModel> | $Enums.CoordinateType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ProductImageScalarRelationFilter = {
    is?: ProductImageWhereInput
    isNot?: ProductImageWhereInput
  }

  export type DelimitationCountOrderByAggregateInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    rotation?: SortOrder
    name?: SortOrder
    coordinateType?: SortOrder
    absoluteX?: SortOrder
    absoluteY?: SortOrder
    absoluteWidth?: SortOrder
    absoluteHeight?: SortOrder
    originalImageWidth?: SortOrder
    originalImageHeight?: SortOrder
    productImageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceWidth?: SortOrder
    referenceHeight?: SortOrder
  }

  export type DelimitationAvgOrderByAggregateInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    rotation?: SortOrder
    absoluteX?: SortOrder
    absoluteY?: SortOrder
    absoluteWidth?: SortOrder
    absoluteHeight?: SortOrder
    originalImageWidth?: SortOrder
    originalImageHeight?: SortOrder
    productImageId?: SortOrder
    referenceWidth?: SortOrder
    referenceHeight?: SortOrder
  }

  export type DelimitationMaxOrderByAggregateInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    rotation?: SortOrder
    name?: SortOrder
    coordinateType?: SortOrder
    absoluteX?: SortOrder
    absoluteY?: SortOrder
    absoluteWidth?: SortOrder
    absoluteHeight?: SortOrder
    originalImageWidth?: SortOrder
    originalImageHeight?: SortOrder
    productImageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceWidth?: SortOrder
    referenceHeight?: SortOrder
  }

  export type DelimitationMinOrderByAggregateInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    rotation?: SortOrder
    name?: SortOrder
    coordinateType?: SortOrder
    absoluteX?: SortOrder
    absoluteY?: SortOrder
    absoluteWidth?: SortOrder
    absoluteHeight?: SortOrder
    originalImageWidth?: SortOrder
    originalImageHeight?: SortOrder
    productImageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceWidth?: SortOrder
    referenceHeight?: SortOrder
  }

  export type DelimitationSumOrderByAggregateInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    rotation?: SortOrder
    absoluteX?: SortOrder
    absoluteY?: SortOrder
    absoluteWidth?: SortOrder
    absoluteHeight?: SortOrder
    originalImageWidth?: SortOrder
    originalImageHeight?: SortOrder
    productImageId?: SortOrder
    referenceWidth?: SortOrder
    referenceHeight?: SortOrder
  }

  export type EnumCoordinateTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CoordinateType | EnumCoordinateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CoordinateType[] | ListEnumCoordinateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoordinateType[] | ListEnumCoordinateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCoordinateTypeWithAggregatesFilter<$PrismaModel> | $Enums.CoordinateType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCoordinateTypeFilter<$PrismaModel>
    _max?: NestedEnumCoordinateTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    phoneNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    validatedAt?: SortOrder
    validatedBy?: SortOrder
    shippingName?: SortOrder
    shippingStreet?: SortOrder
    shippingCity?: SortOrder
    shippingRegion?: SortOrder
    shippingPostalCode?: SortOrder
    shippingCountry?: SortOrder
    shippingAddressFull?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalAmount?: SortOrder
    validatedBy?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    phoneNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    validatedAt?: SortOrder
    validatedBy?: SortOrder
    shippingName?: SortOrder
    shippingStreet?: SortOrder
    shippingCity?: SortOrder
    shippingRegion?: SortOrder
    shippingPostalCode?: SortOrder
    shippingCountry?: SortOrder
    shippingAddressFull?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    phoneNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    validatedAt?: SortOrder
    validatedBy?: SortOrder
    shippingName?: SortOrder
    shippingStreet?: SortOrder
    shippingCity?: SortOrder
    shippingRegion?: SortOrder
    shippingPostalCode?: SortOrder
    shippingCountry?: SortOrder
    shippingAddressFull?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalAmount?: SortOrder
    validatedBy?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type ColorVariationNullableScalarRelationFilter = {
    is?: ColorVariationWhereInput | null
    isNot?: ColorVariationWhereInput | null
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    size?: SortOrder
    color?: SortOrder
    colorId?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    colorId?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    size?: SortOrder
    color?: SortOrder
    colorId?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    size?: SortOrder
    color?: SortOrder
    colorId?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    colorId?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumDesignCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.DesignCategory | EnumDesignCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DesignCategory[] | ListEnumDesignCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.DesignCategory[] | ListEnumDesignCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumDesignCategoryFilter<$PrismaModel> | $Enums.DesignCategory
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DesignCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    thumbnailUrl?: SortOrder
    cloudinaryPublicId?: SortOrder
    thumbnailPublicId?: SortOrder
    fileSize?: SortOrder
    originalFileName?: SortOrder
    dimensions?: SortOrder
    format?: SortOrder
    tags?: SortOrder
    isDraft?: SortOrder
    isPublished?: SortOrder
    isPending?: SortOrder
    isValidated?: SortOrder
    validatedAt?: SortOrder
    validatedBy?: SortOrder
    rejectionReason?: SortOrder
    submittedForValidationAt?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    earnings?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
  }

  export type DesignAvgOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    price?: SortOrder
    fileSize?: SortOrder
    validatedBy?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    earnings?: SortOrder
    usageCount?: SortOrder
  }

  export type DesignMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    thumbnailUrl?: SortOrder
    cloudinaryPublicId?: SortOrder
    thumbnailPublicId?: SortOrder
    fileSize?: SortOrder
    originalFileName?: SortOrder
    format?: SortOrder
    isDraft?: SortOrder
    isPublished?: SortOrder
    isPending?: SortOrder
    isValidated?: SortOrder
    validatedAt?: SortOrder
    validatedBy?: SortOrder
    rejectionReason?: SortOrder
    submittedForValidationAt?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    earnings?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
  }

  export type DesignMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    thumbnailUrl?: SortOrder
    cloudinaryPublicId?: SortOrder
    thumbnailPublicId?: SortOrder
    fileSize?: SortOrder
    originalFileName?: SortOrder
    format?: SortOrder
    isDraft?: SortOrder
    isPublished?: SortOrder
    isPending?: SortOrder
    isValidated?: SortOrder
    validatedAt?: SortOrder
    validatedBy?: SortOrder
    rejectionReason?: SortOrder
    submittedForValidationAt?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    earnings?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
  }

  export type DesignSumOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    price?: SortOrder
    fileSize?: SortOrder
    validatedBy?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    earnings?: SortOrder
    usageCount?: SortOrder
  }

  export type EnumDesignCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DesignCategory | EnumDesignCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DesignCategory[] | ListEnumDesignCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.DesignCategory[] | ListEnumDesignCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumDesignCategoryWithAggregatesFilter<$PrismaModel> | $Enums.DesignCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDesignCategoryFilter<$PrismaModel>
    _max?: NestedEnumDesignCategoryFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumVendorProductStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorProductStatus | EnumVendorProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VendorProductStatus[] | ListEnumVendorProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorProductStatus[] | ListEnumVendorProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorProductStatusFilter<$PrismaModel> | $Enums.VendorProductStatus
  }

  export type DesignTransformationListRelationFilter = {
    every?: DesignTransformationWhereInput
    some?: DesignTransformationWhereInput
    none?: DesignTransformationWhereInput
  }

  export type DesignTransformationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorProductCountOrderByAggregateInput = {
    id?: SortOrder
    baseProductId?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    status?: SortOrder
    adminProductName?: SortOrder
    adminProductDescription?: SortOrder
    adminProductPrice?: SortOrder
    designBase64?: SortOrder
    designCloudinaryUrl?: SortOrder
    designCloudinaryPublicId?: SortOrder
    designPositioning?: SortOrder
    designScale?: SortOrder
    designApplicationMode?: SortOrder
    sizes?: SortOrder
    colors?: SortOrder
    vendorName?: SortOrder
    vendorDescription?: SortOrder
    vendorStock?: SortOrder
    basePriceAdmin?: SortOrder
    isValidated?: SortOrder
    validatedAt?: SortOrder
    validatedBy?: SortOrder
    rejectionReason?: SortOrder
    submittedForValidationAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorProductAvgOrderByAggregateInput = {
    id?: SortOrder
    baseProductId?: SortOrder
    vendorId?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    adminProductPrice?: SortOrder
    designScale?: SortOrder
    vendorStock?: SortOrder
    basePriceAdmin?: SortOrder
    validatedBy?: SortOrder
  }

  export type VendorProductMaxOrderByAggregateInput = {
    id?: SortOrder
    baseProductId?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    status?: SortOrder
    adminProductName?: SortOrder
    adminProductDescription?: SortOrder
    adminProductPrice?: SortOrder
    designBase64?: SortOrder
    designCloudinaryUrl?: SortOrder
    designCloudinaryPublicId?: SortOrder
    designPositioning?: SortOrder
    designScale?: SortOrder
    designApplicationMode?: SortOrder
    vendorName?: SortOrder
    vendorDescription?: SortOrder
    vendorStock?: SortOrder
    basePriceAdmin?: SortOrder
    isValidated?: SortOrder
    validatedAt?: SortOrder
    validatedBy?: SortOrder
    rejectionReason?: SortOrder
    submittedForValidationAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorProductMinOrderByAggregateInput = {
    id?: SortOrder
    baseProductId?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    status?: SortOrder
    adminProductName?: SortOrder
    adminProductDescription?: SortOrder
    adminProductPrice?: SortOrder
    designBase64?: SortOrder
    designCloudinaryUrl?: SortOrder
    designCloudinaryPublicId?: SortOrder
    designPositioning?: SortOrder
    designScale?: SortOrder
    designApplicationMode?: SortOrder
    vendorName?: SortOrder
    vendorDescription?: SortOrder
    vendorStock?: SortOrder
    basePriceAdmin?: SortOrder
    isValidated?: SortOrder
    validatedAt?: SortOrder
    validatedBy?: SortOrder
    rejectionReason?: SortOrder
    submittedForValidationAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorProductSumOrderByAggregateInput = {
    id?: SortOrder
    baseProductId?: SortOrder
    vendorId?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    adminProductPrice?: SortOrder
    designScale?: SortOrder
    vendorStock?: SortOrder
    basePriceAdmin?: SortOrder
    validatedBy?: SortOrder
  }

  export type EnumVendorProductStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorProductStatus | EnumVendorProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VendorProductStatus[] | ListEnumVendorProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorProductStatus[] | ListEnumVendorProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorProductStatusWithAggregatesFilter<$PrismaModel> | $Enums.VendorProductStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVendorProductStatusFilter<$PrismaModel>
    _max?: NestedEnumVendorProductStatusFilter<$PrismaModel>
  }

  export type VendorProductScalarRelationFilter = {
    is?: VendorProductWhereInput
    isNot?: VendorProductWhereInput
  }

  export type VendorProductImageCountOrderByAggregateInput = {
    id?: SortOrder
    vendorProductId?: SortOrder
    colorId?: SortOrder
    colorName?: SortOrder
    colorCode?: SortOrder
    imageType?: SortOrder
    cloudinaryUrl?: SortOrder
    cloudinaryPublicId?: SortOrder
    originalImageKey?: SortOrder
    width?: SortOrder
    height?: SortOrder
    fileSize?: SortOrder
    format?: SortOrder
    createdAt?: SortOrder
    uploadedAt?: SortOrder
  }

  export type VendorProductImageAvgOrderByAggregateInput = {
    id?: SortOrder
    vendorProductId?: SortOrder
    colorId?: SortOrder
    width?: SortOrder
    height?: SortOrder
    fileSize?: SortOrder
  }

  export type VendorProductImageMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorProductId?: SortOrder
    colorId?: SortOrder
    colorName?: SortOrder
    colorCode?: SortOrder
    imageType?: SortOrder
    cloudinaryUrl?: SortOrder
    cloudinaryPublicId?: SortOrder
    originalImageKey?: SortOrder
    width?: SortOrder
    height?: SortOrder
    fileSize?: SortOrder
    format?: SortOrder
    createdAt?: SortOrder
    uploadedAt?: SortOrder
  }

  export type VendorProductImageMinOrderByAggregateInput = {
    id?: SortOrder
    vendorProductId?: SortOrder
    colorId?: SortOrder
    colorName?: SortOrder
    colorCode?: SortOrder
    imageType?: SortOrder
    cloudinaryUrl?: SortOrder
    cloudinaryPublicId?: SortOrder
    originalImageKey?: SortOrder
    width?: SortOrder
    height?: SortOrder
    fileSize?: SortOrder
    format?: SortOrder
    createdAt?: SortOrder
    uploadedAt?: SortOrder
  }

  export type VendorProductImageSumOrderByAggregateInput = {
    id?: SortOrder
    vendorProductId?: SortOrder
    colorId?: SortOrder
    width?: SortOrder
    height?: SortOrder
    fileSize?: SortOrder
  }

  export type EnumDesignPositioningFilter<$PrismaModel = never> = {
    equals?: $Enums.DesignPositioning | EnumDesignPositioningFieldRefInput<$PrismaModel>
    in?: $Enums.DesignPositioning[] | ListEnumDesignPositioningFieldRefInput<$PrismaModel>
    notIn?: $Enums.DesignPositioning[] | ListEnumDesignPositioningFieldRefInput<$PrismaModel>
    not?: NestedEnumDesignPositioningFilter<$PrismaModel> | $Enums.DesignPositioning
  }

  export type DesignTransformationVendorProductIdDelimitationIndexCompoundUniqueInput = {
    vendorProductId: number
    delimitationIndex: number
  }

  export type DesignTransformationCountOrderByAggregateInput = {
    id?: SortOrder
    vendorProductId?: SortOrder
    delimitationIndex?: SortOrder
    xOffset?: SortOrder
    yOffset?: SortOrder
    scaleFactor?: SortOrder
    positioning?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignTransformationAvgOrderByAggregateInput = {
    id?: SortOrder
    vendorProductId?: SortOrder
    delimitationIndex?: SortOrder
    xOffset?: SortOrder
    yOffset?: SortOrder
    scaleFactor?: SortOrder
  }

  export type DesignTransformationMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorProductId?: SortOrder
    delimitationIndex?: SortOrder
    xOffset?: SortOrder
    yOffset?: SortOrder
    scaleFactor?: SortOrder
    positioning?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignTransformationMinOrderByAggregateInput = {
    id?: SortOrder
    vendorProductId?: SortOrder
    delimitationIndex?: SortOrder
    xOffset?: SortOrder
    yOffset?: SortOrder
    scaleFactor?: SortOrder
    positioning?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignTransformationSumOrderByAggregateInput = {
    id?: SortOrder
    vendorProductId?: SortOrder
    delimitationIndex?: SortOrder
    xOffset?: SortOrder
    yOffset?: SortOrder
    scaleFactor?: SortOrder
  }

  export type EnumDesignPositioningWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DesignPositioning | EnumDesignPositioningFieldRefInput<$PrismaModel>
    in?: $Enums.DesignPositioning[] | ListEnumDesignPositioningFieldRefInput<$PrismaModel>
    notIn?: $Enums.DesignPositioning[] | ListEnumDesignPositioningFieldRefInput<$PrismaModel>
    not?: NestedEnumDesignPositioningWithAggregatesFilter<$PrismaModel> | $Enums.DesignPositioning
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDesignPositioningFilter<$PrismaModel>
    _max?: NestedEnumDesignPositioningFilter<$PrismaModel>
  }

  export type PasswordResetCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutValidatorInput = {
    create?: XOR<OrderCreateWithoutValidatorInput, OrderUncheckedCreateWithoutValidatorInput> | OrderCreateWithoutValidatorInput[] | OrderUncheckedCreateWithoutValidatorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutValidatorInput | OrderCreateOrConnectWithoutValidatorInput[]
    createMany?: OrderCreateManyValidatorInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type DesignCreateNestedManyWithoutVendorInput = {
    create?: XOR<DesignCreateWithoutVendorInput, DesignUncheckedCreateWithoutVendorInput> | DesignCreateWithoutVendorInput[] | DesignUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: DesignCreateOrConnectWithoutVendorInput | DesignCreateOrConnectWithoutVendorInput[]
    createMany?: DesignCreateManyVendorInputEnvelope
    connect?: DesignWhereUniqueInput | DesignWhereUniqueInput[]
  }

  export type DesignCreateNestedManyWithoutValidatorInput = {
    create?: XOR<DesignCreateWithoutValidatorInput, DesignUncheckedCreateWithoutValidatorInput> | DesignCreateWithoutValidatorInput[] | DesignUncheckedCreateWithoutValidatorInput[]
    connectOrCreate?: DesignCreateOrConnectWithoutValidatorInput | DesignCreateOrConnectWithoutValidatorInput[]
    createMany?: DesignCreateManyValidatorInputEnvelope
    connect?: DesignWhereUniqueInput | DesignWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutValidatorInput = {
    create?: XOR<ProductCreateWithoutValidatorInput, ProductUncheckedCreateWithoutValidatorInput> | ProductCreateWithoutValidatorInput[] | ProductUncheckedCreateWithoutValidatorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutValidatorInput | ProductCreateOrConnectWithoutValidatorInput[]
    createMany?: ProductCreateManyValidatorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type VendorProductCreateNestedManyWithoutValidatorInput = {
    create?: XOR<VendorProductCreateWithoutValidatorInput, VendorProductUncheckedCreateWithoutValidatorInput> | VendorProductCreateWithoutValidatorInput[] | VendorProductUncheckedCreateWithoutValidatorInput[]
    connectOrCreate?: VendorProductCreateOrConnectWithoutValidatorInput | VendorProductCreateOrConnectWithoutValidatorInput[]
    createMany?: VendorProductCreateManyValidatorInputEnvelope
    connect?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
  }

  export type VendorProductCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorProductCreateWithoutVendorInput, VendorProductUncheckedCreateWithoutVendorInput> | VendorProductCreateWithoutVendorInput[] | VendorProductUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorProductCreateOrConnectWithoutVendorInput | VendorProductCreateOrConnectWithoutVendorInput[]
    createMany?: VendorProductCreateManyVendorInputEnvelope
    connect?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
  }

  export type PasswordResetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutValidatorInput = {
    create?: XOR<OrderCreateWithoutValidatorInput, OrderUncheckedCreateWithoutValidatorInput> | OrderCreateWithoutValidatorInput[] | OrderUncheckedCreateWithoutValidatorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutValidatorInput | OrderCreateOrConnectWithoutValidatorInput[]
    createMany?: OrderCreateManyValidatorInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type DesignUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<DesignCreateWithoutVendorInput, DesignUncheckedCreateWithoutVendorInput> | DesignCreateWithoutVendorInput[] | DesignUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: DesignCreateOrConnectWithoutVendorInput | DesignCreateOrConnectWithoutVendorInput[]
    createMany?: DesignCreateManyVendorInputEnvelope
    connect?: DesignWhereUniqueInput | DesignWhereUniqueInput[]
  }

  export type DesignUncheckedCreateNestedManyWithoutValidatorInput = {
    create?: XOR<DesignCreateWithoutValidatorInput, DesignUncheckedCreateWithoutValidatorInput> | DesignCreateWithoutValidatorInput[] | DesignUncheckedCreateWithoutValidatorInput[]
    connectOrCreate?: DesignCreateOrConnectWithoutValidatorInput | DesignCreateOrConnectWithoutValidatorInput[]
    createMany?: DesignCreateManyValidatorInputEnvelope
    connect?: DesignWhereUniqueInput | DesignWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutValidatorInput = {
    create?: XOR<ProductCreateWithoutValidatorInput, ProductUncheckedCreateWithoutValidatorInput> | ProductCreateWithoutValidatorInput[] | ProductUncheckedCreateWithoutValidatorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutValidatorInput | ProductCreateOrConnectWithoutValidatorInput[]
    createMany?: ProductCreateManyValidatorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type VendorProductUncheckedCreateNestedManyWithoutValidatorInput = {
    create?: XOR<VendorProductCreateWithoutValidatorInput, VendorProductUncheckedCreateWithoutValidatorInput> | VendorProductCreateWithoutValidatorInput[] | VendorProductUncheckedCreateWithoutValidatorInput[]
    connectOrCreate?: VendorProductCreateOrConnectWithoutValidatorInput | VendorProductCreateOrConnectWithoutValidatorInput[]
    createMany?: VendorProductCreateManyValidatorInputEnvelope
    connect?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
  }

  export type VendorProductUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorProductCreateWithoutVendorInput, VendorProductUncheckedCreateWithoutVendorInput> | VendorProductCreateWithoutVendorInput[] | VendorProductUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorProductCreateOrConnectWithoutVendorInput | VendorProductCreateOrConnectWithoutVendorInput[]
    createMany?: VendorProductCreateManyVendorInputEnvelope
    connect?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableEnumVendeurTypeFieldUpdateOperationsInput = {
    set?: $Enums.VendeurType | null
  }

  export type PasswordResetUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetUpsertWithWhereUniqueWithoutUserInput | PasswordResetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    set?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    disconnect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    delete?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    update?: PasswordResetUpdateWithWhereUniqueWithoutUserInput | PasswordResetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetUpdateManyWithWhereWithoutUserInput | PasswordResetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutValidatorNestedInput = {
    create?: XOR<OrderCreateWithoutValidatorInput, OrderUncheckedCreateWithoutValidatorInput> | OrderCreateWithoutValidatorInput[] | OrderUncheckedCreateWithoutValidatorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutValidatorInput | OrderCreateOrConnectWithoutValidatorInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutValidatorInput | OrderUpsertWithWhereUniqueWithoutValidatorInput[]
    createMany?: OrderCreateManyValidatorInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutValidatorInput | OrderUpdateWithWhereUniqueWithoutValidatorInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutValidatorInput | OrderUpdateManyWithWhereWithoutValidatorInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type DesignUpdateManyWithoutVendorNestedInput = {
    create?: XOR<DesignCreateWithoutVendorInput, DesignUncheckedCreateWithoutVendorInput> | DesignCreateWithoutVendorInput[] | DesignUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: DesignCreateOrConnectWithoutVendorInput | DesignCreateOrConnectWithoutVendorInput[]
    upsert?: DesignUpsertWithWhereUniqueWithoutVendorInput | DesignUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: DesignCreateManyVendorInputEnvelope
    set?: DesignWhereUniqueInput | DesignWhereUniqueInput[]
    disconnect?: DesignWhereUniqueInput | DesignWhereUniqueInput[]
    delete?: DesignWhereUniqueInput | DesignWhereUniqueInput[]
    connect?: DesignWhereUniqueInput | DesignWhereUniqueInput[]
    update?: DesignUpdateWithWhereUniqueWithoutVendorInput | DesignUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: DesignUpdateManyWithWhereWithoutVendorInput | DesignUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: DesignScalarWhereInput | DesignScalarWhereInput[]
  }

  export type DesignUpdateManyWithoutValidatorNestedInput = {
    create?: XOR<DesignCreateWithoutValidatorInput, DesignUncheckedCreateWithoutValidatorInput> | DesignCreateWithoutValidatorInput[] | DesignUncheckedCreateWithoutValidatorInput[]
    connectOrCreate?: DesignCreateOrConnectWithoutValidatorInput | DesignCreateOrConnectWithoutValidatorInput[]
    upsert?: DesignUpsertWithWhereUniqueWithoutValidatorInput | DesignUpsertWithWhereUniqueWithoutValidatorInput[]
    createMany?: DesignCreateManyValidatorInputEnvelope
    set?: DesignWhereUniqueInput | DesignWhereUniqueInput[]
    disconnect?: DesignWhereUniqueInput | DesignWhereUniqueInput[]
    delete?: DesignWhereUniqueInput | DesignWhereUniqueInput[]
    connect?: DesignWhereUniqueInput | DesignWhereUniqueInput[]
    update?: DesignUpdateWithWhereUniqueWithoutValidatorInput | DesignUpdateWithWhereUniqueWithoutValidatorInput[]
    updateMany?: DesignUpdateManyWithWhereWithoutValidatorInput | DesignUpdateManyWithWhereWithoutValidatorInput[]
    deleteMany?: DesignScalarWhereInput | DesignScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutValidatorNestedInput = {
    create?: XOR<ProductCreateWithoutValidatorInput, ProductUncheckedCreateWithoutValidatorInput> | ProductCreateWithoutValidatorInput[] | ProductUncheckedCreateWithoutValidatorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutValidatorInput | ProductCreateOrConnectWithoutValidatorInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutValidatorInput | ProductUpsertWithWhereUniqueWithoutValidatorInput[]
    createMany?: ProductCreateManyValidatorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutValidatorInput | ProductUpdateWithWhereUniqueWithoutValidatorInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutValidatorInput | ProductUpdateManyWithWhereWithoutValidatorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type VendorProductUpdateManyWithoutValidatorNestedInput = {
    create?: XOR<VendorProductCreateWithoutValidatorInput, VendorProductUncheckedCreateWithoutValidatorInput> | VendorProductCreateWithoutValidatorInput[] | VendorProductUncheckedCreateWithoutValidatorInput[]
    connectOrCreate?: VendorProductCreateOrConnectWithoutValidatorInput | VendorProductCreateOrConnectWithoutValidatorInput[]
    upsert?: VendorProductUpsertWithWhereUniqueWithoutValidatorInput | VendorProductUpsertWithWhereUniqueWithoutValidatorInput[]
    createMany?: VendorProductCreateManyValidatorInputEnvelope
    set?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    disconnect?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    delete?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    connect?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    update?: VendorProductUpdateWithWhereUniqueWithoutValidatorInput | VendorProductUpdateWithWhereUniqueWithoutValidatorInput[]
    updateMany?: VendorProductUpdateManyWithWhereWithoutValidatorInput | VendorProductUpdateManyWithWhereWithoutValidatorInput[]
    deleteMany?: VendorProductScalarWhereInput | VendorProductScalarWhereInput[]
  }

  export type VendorProductUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorProductCreateWithoutVendorInput, VendorProductUncheckedCreateWithoutVendorInput> | VendorProductCreateWithoutVendorInput[] | VendorProductUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorProductCreateOrConnectWithoutVendorInput | VendorProductCreateOrConnectWithoutVendorInput[]
    upsert?: VendorProductUpsertWithWhereUniqueWithoutVendorInput | VendorProductUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorProductCreateManyVendorInputEnvelope
    set?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    disconnect?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    delete?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    connect?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    update?: VendorProductUpdateWithWhereUniqueWithoutVendorInput | VendorProductUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorProductUpdateManyWithWhereWithoutVendorInput | VendorProductUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorProductScalarWhereInput | VendorProductScalarWhereInput[]
  }

  export type PasswordResetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetUpsertWithWhereUniqueWithoutUserInput | PasswordResetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    set?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    disconnect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    delete?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    update?: PasswordResetUpdateWithWhereUniqueWithoutUserInput | PasswordResetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetUpdateManyWithWhereWithoutUserInput | PasswordResetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutValidatorNestedInput = {
    create?: XOR<OrderCreateWithoutValidatorInput, OrderUncheckedCreateWithoutValidatorInput> | OrderCreateWithoutValidatorInput[] | OrderUncheckedCreateWithoutValidatorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutValidatorInput | OrderCreateOrConnectWithoutValidatorInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutValidatorInput | OrderUpsertWithWhereUniqueWithoutValidatorInput[]
    createMany?: OrderCreateManyValidatorInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutValidatorInput | OrderUpdateWithWhereUniqueWithoutValidatorInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutValidatorInput | OrderUpdateManyWithWhereWithoutValidatorInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type DesignUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<DesignCreateWithoutVendorInput, DesignUncheckedCreateWithoutVendorInput> | DesignCreateWithoutVendorInput[] | DesignUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: DesignCreateOrConnectWithoutVendorInput | DesignCreateOrConnectWithoutVendorInput[]
    upsert?: DesignUpsertWithWhereUniqueWithoutVendorInput | DesignUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: DesignCreateManyVendorInputEnvelope
    set?: DesignWhereUniqueInput | DesignWhereUniqueInput[]
    disconnect?: DesignWhereUniqueInput | DesignWhereUniqueInput[]
    delete?: DesignWhereUniqueInput | DesignWhereUniqueInput[]
    connect?: DesignWhereUniqueInput | DesignWhereUniqueInput[]
    update?: DesignUpdateWithWhereUniqueWithoutVendorInput | DesignUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: DesignUpdateManyWithWhereWithoutVendorInput | DesignUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: DesignScalarWhereInput | DesignScalarWhereInput[]
  }

  export type DesignUncheckedUpdateManyWithoutValidatorNestedInput = {
    create?: XOR<DesignCreateWithoutValidatorInput, DesignUncheckedCreateWithoutValidatorInput> | DesignCreateWithoutValidatorInput[] | DesignUncheckedCreateWithoutValidatorInput[]
    connectOrCreate?: DesignCreateOrConnectWithoutValidatorInput | DesignCreateOrConnectWithoutValidatorInput[]
    upsert?: DesignUpsertWithWhereUniqueWithoutValidatorInput | DesignUpsertWithWhereUniqueWithoutValidatorInput[]
    createMany?: DesignCreateManyValidatorInputEnvelope
    set?: DesignWhereUniqueInput | DesignWhereUniqueInput[]
    disconnect?: DesignWhereUniqueInput | DesignWhereUniqueInput[]
    delete?: DesignWhereUniqueInput | DesignWhereUniqueInput[]
    connect?: DesignWhereUniqueInput | DesignWhereUniqueInput[]
    update?: DesignUpdateWithWhereUniqueWithoutValidatorInput | DesignUpdateWithWhereUniqueWithoutValidatorInput[]
    updateMany?: DesignUpdateManyWithWhereWithoutValidatorInput | DesignUpdateManyWithWhereWithoutValidatorInput[]
    deleteMany?: DesignScalarWhereInput | DesignScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutValidatorNestedInput = {
    create?: XOR<ProductCreateWithoutValidatorInput, ProductUncheckedCreateWithoutValidatorInput> | ProductCreateWithoutValidatorInput[] | ProductUncheckedCreateWithoutValidatorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutValidatorInput | ProductCreateOrConnectWithoutValidatorInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutValidatorInput | ProductUpsertWithWhereUniqueWithoutValidatorInput[]
    createMany?: ProductCreateManyValidatorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutValidatorInput | ProductUpdateWithWhereUniqueWithoutValidatorInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutValidatorInput | ProductUpdateManyWithWhereWithoutValidatorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type VendorProductUncheckedUpdateManyWithoutValidatorNestedInput = {
    create?: XOR<VendorProductCreateWithoutValidatorInput, VendorProductUncheckedCreateWithoutValidatorInput> | VendorProductCreateWithoutValidatorInput[] | VendorProductUncheckedCreateWithoutValidatorInput[]
    connectOrCreate?: VendorProductCreateOrConnectWithoutValidatorInput | VendorProductCreateOrConnectWithoutValidatorInput[]
    upsert?: VendorProductUpsertWithWhereUniqueWithoutValidatorInput | VendorProductUpsertWithWhereUniqueWithoutValidatorInput[]
    createMany?: VendorProductCreateManyValidatorInputEnvelope
    set?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    disconnect?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    delete?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    connect?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    update?: VendorProductUpdateWithWhereUniqueWithoutValidatorInput | VendorProductUpdateWithWhereUniqueWithoutValidatorInput[]
    updateMany?: VendorProductUpdateManyWithWhereWithoutValidatorInput | VendorProductUpdateManyWithWhereWithoutValidatorInput[]
    deleteMany?: VendorProductScalarWhereInput | VendorProductScalarWhereInput[]
  }

  export type VendorProductUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorProductCreateWithoutVendorInput, VendorProductUncheckedCreateWithoutVendorInput> | VendorProductCreateWithoutVendorInput[] | VendorProductUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorProductCreateOrConnectWithoutVendorInput | VendorProductCreateOrConnectWithoutVendorInput[]
    upsert?: VendorProductUpsertWithWhereUniqueWithoutVendorInput | VendorProductUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorProductCreateManyVendorInputEnvelope
    set?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    disconnect?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    delete?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    connect?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    update?: VendorProductUpdateWithWhereUniqueWithoutVendorInput | VendorProductUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorProductUpdateManyWithWhereWithoutVendorInput | VendorProductUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorProductScalarWhereInput | VendorProductScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPasswordResetsInput = {
    create?: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetsNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetsInput
    upsert?: UserUpsertWithoutPasswordResetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetsInput, UserUpdateWithoutPasswordResetsInput>, UserUncheckedUpdateWithoutPasswordResetsInput>
  }

  export type UserCreateNestedOneWithoutValidatedProductsInput = {
    create?: XOR<UserCreateWithoutValidatedProductsInput, UserUncheckedCreateWithoutValidatedProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutValidatedProductsInput
    connect?: UserWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput> | CategoryCreateWithoutProductsInput[] | CategoryUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput | CategoryCreateOrConnectWithoutProductsInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductSizeCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductSizeCreateWithoutProductInput, ProductSizeUncheckedCreateWithoutProductInput> | ProductSizeCreateWithoutProductInput[] | ProductSizeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductSizeCreateOrConnectWithoutProductInput | ProductSizeCreateOrConnectWithoutProductInput[]
    createMany?: ProductSizeCreateManyProductInputEnvelope
    connect?: ProductSizeWhereUniqueInput | ProductSizeWhereUniqueInput[]
  }

  export type ColorVariationCreateNestedManyWithoutProductInput = {
    create?: XOR<ColorVariationCreateWithoutProductInput, ColorVariationUncheckedCreateWithoutProductInput> | ColorVariationCreateWithoutProductInput[] | ColorVariationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ColorVariationCreateOrConnectWithoutProductInput | ColorVariationCreateOrConnectWithoutProductInput[]
    createMany?: ColorVariationCreateManyProductInputEnvelope
    connect?: ColorVariationWhereUniqueInput | ColorVariationWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type VendorProductCreateNestedManyWithoutBaseProductInput = {
    create?: XOR<VendorProductCreateWithoutBaseProductInput, VendorProductUncheckedCreateWithoutBaseProductInput> | VendorProductCreateWithoutBaseProductInput[] | VendorProductUncheckedCreateWithoutBaseProductInput[]
    connectOrCreate?: VendorProductCreateOrConnectWithoutBaseProductInput | VendorProductCreateOrConnectWithoutBaseProductInput[]
    createMany?: VendorProductCreateManyBaseProductInputEnvelope
    connect?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput> | CategoryCreateWithoutProductsInput[] | CategoryUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput | CategoryCreateOrConnectWithoutProductsInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductSizeUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductSizeCreateWithoutProductInput, ProductSizeUncheckedCreateWithoutProductInput> | ProductSizeCreateWithoutProductInput[] | ProductSizeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductSizeCreateOrConnectWithoutProductInput | ProductSizeCreateOrConnectWithoutProductInput[]
    createMany?: ProductSizeCreateManyProductInputEnvelope
    connect?: ProductSizeWhereUniqueInput | ProductSizeWhereUniqueInput[]
  }

  export type ColorVariationUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ColorVariationCreateWithoutProductInput, ColorVariationUncheckedCreateWithoutProductInput> | ColorVariationCreateWithoutProductInput[] | ColorVariationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ColorVariationCreateOrConnectWithoutProductInput | ColorVariationCreateOrConnectWithoutProductInput[]
    createMany?: ColorVariationCreateManyProductInputEnvelope
    connect?: ColorVariationWhereUniqueInput | ColorVariationWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type VendorProductUncheckedCreateNestedManyWithoutBaseProductInput = {
    create?: XOR<VendorProductCreateWithoutBaseProductInput, VendorProductUncheckedCreateWithoutBaseProductInput> | VendorProductCreateWithoutBaseProductInput[] | VendorProductUncheckedCreateWithoutBaseProductInput[]
    connectOrCreate?: VendorProductCreateOrConnectWithoutBaseProductInput | VendorProductCreateOrConnectWithoutBaseProductInput[]
    createMany?: VendorProductCreateManyBaseProductInputEnvelope
    connect?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumPublicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.PublicationStatus
  }

  export type UserUpdateOneWithoutValidatedProductsNestedInput = {
    create?: XOR<UserCreateWithoutValidatedProductsInput, UserUncheckedCreateWithoutValidatedProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutValidatedProductsInput
    upsert?: UserUpsertWithoutValidatedProductsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutValidatedProductsInput, UserUpdateWithoutValidatedProductsInput>, UserUncheckedUpdateWithoutValidatedProductsInput>
  }

  export type CategoryUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput> | CategoryCreateWithoutProductsInput[] | CategoryUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput | CategoryCreateOrConnectWithoutProductsInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutProductsInput | CategoryUpsertWithWhereUniqueWithoutProductsInput[]
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutProductsInput | CategoryUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutProductsInput | CategoryUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductSizeUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductSizeCreateWithoutProductInput, ProductSizeUncheckedCreateWithoutProductInput> | ProductSizeCreateWithoutProductInput[] | ProductSizeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductSizeCreateOrConnectWithoutProductInput | ProductSizeCreateOrConnectWithoutProductInput[]
    upsert?: ProductSizeUpsertWithWhereUniqueWithoutProductInput | ProductSizeUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductSizeCreateManyProductInputEnvelope
    set?: ProductSizeWhereUniqueInput | ProductSizeWhereUniqueInput[]
    disconnect?: ProductSizeWhereUniqueInput | ProductSizeWhereUniqueInput[]
    delete?: ProductSizeWhereUniqueInput | ProductSizeWhereUniqueInput[]
    connect?: ProductSizeWhereUniqueInput | ProductSizeWhereUniqueInput[]
    update?: ProductSizeUpdateWithWhereUniqueWithoutProductInput | ProductSizeUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductSizeUpdateManyWithWhereWithoutProductInput | ProductSizeUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductSizeScalarWhereInput | ProductSizeScalarWhereInput[]
  }

  export type ColorVariationUpdateManyWithoutProductNestedInput = {
    create?: XOR<ColorVariationCreateWithoutProductInput, ColorVariationUncheckedCreateWithoutProductInput> | ColorVariationCreateWithoutProductInput[] | ColorVariationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ColorVariationCreateOrConnectWithoutProductInput | ColorVariationCreateOrConnectWithoutProductInput[]
    upsert?: ColorVariationUpsertWithWhereUniqueWithoutProductInput | ColorVariationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ColorVariationCreateManyProductInputEnvelope
    set?: ColorVariationWhereUniqueInput | ColorVariationWhereUniqueInput[]
    disconnect?: ColorVariationWhereUniqueInput | ColorVariationWhereUniqueInput[]
    delete?: ColorVariationWhereUniqueInput | ColorVariationWhereUniqueInput[]
    connect?: ColorVariationWhereUniqueInput | ColorVariationWhereUniqueInput[]
    update?: ColorVariationUpdateWithWhereUniqueWithoutProductInput | ColorVariationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ColorVariationUpdateManyWithWhereWithoutProductInput | ColorVariationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ColorVariationScalarWhereInput | ColorVariationScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type VendorProductUpdateManyWithoutBaseProductNestedInput = {
    create?: XOR<VendorProductCreateWithoutBaseProductInput, VendorProductUncheckedCreateWithoutBaseProductInput> | VendorProductCreateWithoutBaseProductInput[] | VendorProductUncheckedCreateWithoutBaseProductInput[]
    connectOrCreate?: VendorProductCreateOrConnectWithoutBaseProductInput | VendorProductCreateOrConnectWithoutBaseProductInput[]
    upsert?: VendorProductUpsertWithWhereUniqueWithoutBaseProductInput | VendorProductUpsertWithWhereUniqueWithoutBaseProductInput[]
    createMany?: VendorProductCreateManyBaseProductInputEnvelope
    set?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    disconnect?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    delete?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    connect?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    update?: VendorProductUpdateWithWhereUniqueWithoutBaseProductInput | VendorProductUpdateWithWhereUniqueWithoutBaseProductInput[]
    updateMany?: VendorProductUpdateManyWithWhereWithoutBaseProductInput | VendorProductUpdateManyWithWhereWithoutBaseProductInput[]
    deleteMany?: VendorProductScalarWhereInput | VendorProductScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CategoryUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput> | CategoryCreateWithoutProductsInput[] | CategoryUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput | CategoryCreateOrConnectWithoutProductsInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutProductsInput | CategoryUpsertWithWhereUniqueWithoutProductsInput[]
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutProductsInput | CategoryUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutProductsInput | CategoryUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductSizeUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductSizeCreateWithoutProductInput, ProductSizeUncheckedCreateWithoutProductInput> | ProductSizeCreateWithoutProductInput[] | ProductSizeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductSizeCreateOrConnectWithoutProductInput | ProductSizeCreateOrConnectWithoutProductInput[]
    upsert?: ProductSizeUpsertWithWhereUniqueWithoutProductInput | ProductSizeUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductSizeCreateManyProductInputEnvelope
    set?: ProductSizeWhereUniqueInput | ProductSizeWhereUniqueInput[]
    disconnect?: ProductSizeWhereUniqueInput | ProductSizeWhereUniqueInput[]
    delete?: ProductSizeWhereUniqueInput | ProductSizeWhereUniqueInput[]
    connect?: ProductSizeWhereUniqueInput | ProductSizeWhereUniqueInput[]
    update?: ProductSizeUpdateWithWhereUniqueWithoutProductInput | ProductSizeUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductSizeUpdateManyWithWhereWithoutProductInput | ProductSizeUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductSizeScalarWhereInput | ProductSizeScalarWhereInput[]
  }

  export type ColorVariationUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ColorVariationCreateWithoutProductInput, ColorVariationUncheckedCreateWithoutProductInput> | ColorVariationCreateWithoutProductInput[] | ColorVariationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ColorVariationCreateOrConnectWithoutProductInput | ColorVariationCreateOrConnectWithoutProductInput[]
    upsert?: ColorVariationUpsertWithWhereUniqueWithoutProductInput | ColorVariationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ColorVariationCreateManyProductInputEnvelope
    set?: ColorVariationWhereUniqueInput | ColorVariationWhereUniqueInput[]
    disconnect?: ColorVariationWhereUniqueInput | ColorVariationWhereUniqueInput[]
    delete?: ColorVariationWhereUniqueInput | ColorVariationWhereUniqueInput[]
    connect?: ColorVariationWhereUniqueInput | ColorVariationWhereUniqueInput[]
    update?: ColorVariationUpdateWithWhereUniqueWithoutProductInput | ColorVariationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ColorVariationUpdateManyWithWhereWithoutProductInput | ColorVariationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ColorVariationScalarWhereInput | ColorVariationScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type VendorProductUncheckedUpdateManyWithoutBaseProductNestedInput = {
    create?: XOR<VendorProductCreateWithoutBaseProductInput, VendorProductUncheckedCreateWithoutBaseProductInput> | VendorProductCreateWithoutBaseProductInput[] | VendorProductUncheckedCreateWithoutBaseProductInput[]
    connectOrCreate?: VendorProductCreateOrConnectWithoutBaseProductInput | VendorProductCreateOrConnectWithoutBaseProductInput[]
    upsert?: VendorProductUpsertWithWhereUniqueWithoutBaseProductInput | VendorProductUpsertWithWhereUniqueWithoutBaseProductInput[]
    createMany?: VendorProductCreateManyBaseProductInputEnvelope
    set?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    disconnect?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    delete?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    connect?: VendorProductWhereUniqueInput | VendorProductWhereUniqueInput[]
    update?: VendorProductUpdateWithWhereUniqueWithoutBaseProductInput | VendorProductUpdateWithWhereUniqueWithoutBaseProductInput[]
    updateMany?: VendorProductUpdateManyWithWhereWithoutBaseProductInput | VendorProductUpdateManyWithWhereWithoutBaseProductInput[]
    deleteMany?: VendorProductScalarWhereInput | VendorProductScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutSizesInput = {
    create?: XOR<ProductCreateWithoutSizesInput, ProductUncheckedCreateWithoutSizesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSizesInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutSizesNestedInput = {
    create?: XOR<ProductCreateWithoutSizesInput, ProductUncheckedCreateWithoutSizesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSizesInput
    upsert?: ProductUpsertWithoutSizesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSizesInput, ProductUpdateWithoutSizesInput>, ProductUncheckedUpdateWithoutSizesInput>
  }

  export type ProductCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput> | ProductCreateWithoutCategoriesInput[] | ProductUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput | ProductCreateOrConnectWithoutCategoriesInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput> | ProductCreateWithoutCategoriesInput[] | ProductUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput | ProductCreateOrConnectWithoutCategoriesInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput> | ProductCreateWithoutCategoriesInput[] | ProductUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput | ProductCreateOrConnectWithoutCategoriesInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoriesInput | ProductUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoriesInput | ProductUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoriesInput | ProductUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput> | ProductCreateWithoutCategoriesInput[] | ProductUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput | ProductCreateOrConnectWithoutCategoriesInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoriesInput | ProductUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoriesInput | ProductUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoriesInput | ProductUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutColorVariationsInput = {
    create?: XOR<ProductCreateWithoutColorVariationsInput, ProductUncheckedCreateWithoutColorVariationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutColorVariationsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductImageCreateNestedManyWithoutColorVariationInput = {
    create?: XOR<ProductImageCreateWithoutColorVariationInput, ProductImageUncheckedCreateWithoutColorVariationInput> | ProductImageCreateWithoutColorVariationInput[] | ProductImageUncheckedCreateWithoutColorVariationInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutColorVariationInput | ProductImageCreateOrConnectWithoutColorVariationInput[]
    createMany?: ProductImageCreateManyColorVariationInputEnvelope
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutColorVariationInput = {
    create?: XOR<OrderItemCreateWithoutColorVariationInput, OrderItemUncheckedCreateWithoutColorVariationInput> | OrderItemCreateWithoutColorVariationInput[] | OrderItemUncheckedCreateWithoutColorVariationInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutColorVariationInput | OrderItemCreateOrConnectWithoutColorVariationInput[]
    createMany?: OrderItemCreateManyColorVariationInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type VendorProductImageCreateNestedManyWithoutColorVariationInput = {
    create?: XOR<VendorProductImageCreateWithoutColorVariationInput, VendorProductImageUncheckedCreateWithoutColorVariationInput> | VendorProductImageCreateWithoutColorVariationInput[] | VendorProductImageUncheckedCreateWithoutColorVariationInput[]
    connectOrCreate?: VendorProductImageCreateOrConnectWithoutColorVariationInput | VendorProductImageCreateOrConnectWithoutColorVariationInput[]
    createMany?: VendorProductImageCreateManyColorVariationInputEnvelope
    connect?: VendorProductImageWhereUniqueInput | VendorProductImageWhereUniqueInput[]
  }

  export type ProductImageUncheckedCreateNestedManyWithoutColorVariationInput = {
    create?: XOR<ProductImageCreateWithoutColorVariationInput, ProductImageUncheckedCreateWithoutColorVariationInput> | ProductImageCreateWithoutColorVariationInput[] | ProductImageUncheckedCreateWithoutColorVariationInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutColorVariationInput | ProductImageCreateOrConnectWithoutColorVariationInput[]
    createMany?: ProductImageCreateManyColorVariationInputEnvelope
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutColorVariationInput = {
    create?: XOR<OrderItemCreateWithoutColorVariationInput, OrderItemUncheckedCreateWithoutColorVariationInput> | OrderItemCreateWithoutColorVariationInput[] | OrderItemUncheckedCreateWithoutColorVariationInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutColorVariationInput | OrderItemCreateOrConnectWithoutColorVariationInput[]
    createMany?: OrderItemCreateManyColorVariationInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type VendorProductImageUncheckedCreateNestedManyWithoutColorVariationInput = {
    create?: XOR<VendorProductImageCreateWithoutColorVariationInput, VendorProductImageUncheckedCreateWithoutColorVariationInput> | VendorProductImageCreateWithoutColorVariationInput[] | VendorProductImageUncheckedCreateWithoutColorVariationInput[]
    connectOrCreate?: VendorProductImageCreateOrConnectWithoutColorVariationInput | VendorProductImageCreateOrConnectWithoutColorVariationInput[]
    createMany?: VendorProductImageCreateManyColorVariationInputEnvelope
    connect?: VendorProductImageWhereUniqueInput | VendorProductImageWhereUniqueInput[]
  }

  export type ProductUpdateOneRequiredWithoutColorVariationsNestedInput = {
    create?: XOR<ProductCreateWithoutColorVariationsInput, ProductUncheckedCreateWithoutColorVariationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutColorVariationsInput
    upsert?: ProductUpsertWithoutColorVariationsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutColorVariationsInput, ProductUpdateWithoutColorVariationsInput>, ProductUncheckedUpdateWithoutColorVariationsInput>
  }

  export type ProductImageUpdateManyWithoutColorVariationNestedInput = {
    create?: XOR<ProductImageCreateWithoutColorVariationInput, ProductImageUncheckedCreateWithoutColorVariationInput> | ProductImageCreateWithoutColorVariationInput[] | ProductImageUncheckedCreateWithoutColorVariationInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutColorVariationInput | ProductImageCreateOrConnectWithoutColorVariationInput[]
    upsert?: ProductImageUpsertWithWhereUniqueWithoutColorVariationInput | ProductImageUpsertWithWhereUniqueWithoutColorVariationInput[]
    createMany?: ProductImageCreateManyColorVariationInputEnvelope
    set?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    disconnect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    delete?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    update?: ProductImageUpdateWithWhereUniqueWithoutColorVariationInput | ProductImageUpdateWithWhereUniqueWithoutColorVariationInput[]
    updateMany?: ProductImageUpdateManyWithWhereWithoutColorVariationInput | ProductImageUpdateManyWithWhereWithoutColorVariationInput[]
    deleteMany?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutColorVariationNestedInput = {
    create?: XOR<OrderItemCreateWithoutColorVariationInput, OrderItemUncheckedCreateWithoutColorVariationInput> | OrderItemCreateWithoutColorVariationInput[] | OrderItemUncheckedCreateWithoutColorVariationInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutColorVariationInput | OrderItemCreateOrConnectWithoutColorVariationInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutColorVariationInput | OrderItemUpsertWithWhereUniqueWithoutColorVariationInput[]
    createMany?: OrderItemCreateManyColorVariationInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutColorVariationInput | OrderItemUpdateWithWhereUniqueWithoutColorVariationInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutColorVariationInput | OrderItemUpdateManyWithWhereWithoutColorVariationInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type VendorProductImageUpdateManyWithoutColorVariationNestedInput = {
    create?: XOR<VendorProductImageCreateWithoutColorVariationInput, VendorProductImageUncheckedCreateWithoutColorVariationInput> | VendorProductImageCreateWithoutColorVariationInput[] | VendorProductImageUncheckedCreateWithoutColorVariationInput[]
    connectOrCreate?: VendorProductImageCreateOrConnectWithoutColorVariationInput | VendorProductImageCreateOrConnectWithoutColorVariationInput[]
    upsert?: VendorProductImageUpsertWithWhereUniqueWithoutColorVariationInput | VendorProductImageUpsertWithWhereUniqueWithoutColorVariationInput[]
    createMany?: VendorProductImageCreateManyColorVariationInputEnvelope
    set?: VendorProductImageWhereUniqueInput | VendorProductImageWhereUniqueInput[]
    disconnect?: VendorProductImageWhereUniqueInput | VendorProductImageWhereUniqueInput[]
    delete?: VendorProductImageWhereUniqueInput | VendorProductImageWhereUniqueInput[]
    connect?: VendorProductImageWhereUniqueInput | VendorProductImageWhereUniqueInput[]
    update?: VendorProductImageUpdateWithWhereUniqueWithoutColorVariationInput | VendorProductImageUpdateWithWhereUniqueWithoutColorVariationInput[]
    updateMany?: VendorProductImageUpdateManyWithWhereWithoutColorVariationInput | VendorProductImageUpdateManyWithWhereWithoutColorVariationInput[]
    deleteMany?: VendorProductImageScalarWhereInput | VendorProductImageScalarWhereInput[]
  }

  export type ProductImageUncheckedUpdateManyWithoutColorVariationNestedInput = {
    create?: XOR<ProductImageCreateWithoutColorVariationInput, ProductImageUncheckedCreateWithoutColorVariationInput> | ProductImageCreateWithoutColorVariationInput[] | ProductImageUncheckedCreateWithoutColorVariationInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutColorVariationInput | ProductImageCreateOrConnectWithoutColorVariationInput[]
    upsert?: ProductImageUpsertWithWhereUniqueWithoutColorVariationInput | ProductImageUpsertWithWhereUniqueWithoutColorVariationInput[]
    createMany?: ProductImageCreateManyColorVariationInputEnvelope
    set?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    disconnect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    delete?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    update?: ProductImageUpdateWithWhereUniqueWithoutColorVariationInput | ProductImageUpdateWithWhereUniqueWithoutColorVariationInput[]
    updateMany?: ProductImageUpdateManyWithWhereWithoutColorVariationInput | ProductImageUpdateManyWithWhereWithoutColorVariationInput[]
    deleteMany?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutColorVariationNestedInput = {
    create?: XOR<OrderItemCreateWithoutColorVariationInput, OrderItemUncheckedCreateWithoutColorVariationInput> | OrderItemCreateWithoutColorVariationInput[] | OrderItemUncheckedCreateWithoutColorVariationInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutColorVariationInput | OrderItemCreateOrConnectWithoutColorVariationInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutColorVariationInput | OrderItemUpsertWithWhereUniqueWithoutColorVariationInput[]
    createMany?: OrderItemCreateManyColorVariationInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutColorVariationInput | OrderItemUpdateWithWhereUniqueWithoutColorVariationInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutColorVariationInput | OrderItemUpdateManyWithWhereWithoutColorVariationInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type VendorProductImageUncheckedUpdateManyWithoutColorVariationNestedInput = {
    create?: XOR<VendorProductImageCreateWithoutColorVariationInput, VendorProductImageUncheckedCreateWithoutColorVariationInput> | VendorProductImageCreateWithoutColorVariationInput[] | VendorProductImageUncheckedCreateWithoutColorVariationInput[]
    connectOrCreate?: VendorProductImageCreateOrConnectWithoutColorVariationInput | VendorProductImageCreateOrConnectWithoutColorVariationInput[]
    upsert?: VendorProductImageUpsertWithWhereUniqueWithoutColorVariationInput | VendorProductImageUpsertWithWhereUniqueWithoutColorVariationInput[]
    createMany?: VendorProductImageCreateManyColorVariationInputEnvelope
    set?: VendorProductImageWhereUniqueInput | VendorProductImageWhereUniqueInput[]
    disconnect?: VendorProductImageWhereUniqueInput | VendorProductImageWhereUniqueInput[]
    delete?: VendorProductImageWhereUniqueInput | VendorProductImageWhereUniqueInput[]
    connect?: VendorProductImageWhereUniqueInput | VendorProductImageWhereUniqueInput[]
    update?: VendorProductImageUpdateWithWhereUniqueWithoutColorVariationInput | VendorProductImageUpdateWithWhereUniqueWithoutColorVariationInput[]
    updateMany?: VendorProductImageUpdateManyWithWhereWithoutColorVariationInput | VendorProductImageUpdateManyWithWhereWithoutColorVariationInput[]
    deleteMany?: VendorProductImageScalarWhereInput | VendorProductImageScalarWhereInput[]
  }

  export type ColorVariationCreateNestedOneWithoutImagesInput = {
    create?: XOR<ColorVariationCreateWithoutImagesInput, ColorVariationUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ColorVariationCreateOrConnectWithoutImagesInput
    connect?: ColorVariationWhereUniqueInput
  }

  export type DelimitationCreateNestedManyWithoutProductImageInput = {
    create?: XOR<DelimitationCreateWithoutProductImageInput, DelimitationUncheckedCreateWithoutProductImageInput> | DelimitationCreateWithoutProductImageInput[] | DelimitationUncheckedCreateWithoutProductImageInput[]
    connectOrCreate?: DelimitationCreateOrConnectWithoutProductImageInput | DelimitationCreateOrConnectWithoutProductImageInput[]
    createMany?: DelimitationCreateManyProductImageInputEnvelope
    connect?: DelimitationWhereUniqueInput | DelimitationWhereUniqueInput[]
  }

  export type DelimitationUncheckedCreateNestedManyWithoutProductImageInput = {
    create?: XOR<DelimitationCreateWithoutProductImageInput, DelimitationUncheckedCreateWithoutProductImageInput> | DelimitationCreateWithoutProductImageInput[] | DelimitationUncheckedCreateWithoutProductImageInput[]
    connectOrCreate?: DelimitationCreateOrConnectWithoutProductImageInput | DelimitationCreateOrConnectWithoutProductImageInput[]
    createMany?: DelimitationCreateManyProductImageInputEnvelope
    connect?: DelimitationWhereUniqueInput | DelimitationWhereUniqueInput[]
  }

  export type ColorVariationUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<ColorVariationCreateWithoutImagesInput, ColorVariationUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ColorVariationCreateOrConnectWithoutImagesInput
    upsert?: ColorVariationUpsertWithoutImagesInput
    connect?: ColorVariationWhereUniqueInput
    update?: XOR<XOR<ColorVariationUpdateToOneWithWhereWithoutImagesInput, ColorVariationUpdateWithoutImagesInput>, ColorVariationUncheckedUpdateWithoutImagesInput>
  }

  export type DelimitationUpdateManyWithoutProductImageNestedInput = {
    create?: XOR<DelimitationCreateWithoutProductImageInput, DelimitationUncheckedCreateWithoutProductImageInput> | DelimitationCreateWithoutProductImageInput[] | DelimitationUncheckedCreateWithoutProductImageInput[]
    connectOrCreate?: DelimitationCreateOrConnectWithoutProductImageInput | DelimitationCreateOrConnectWithoutProductImageInput[]
    upsert?: DelimitationUpsertWithWhereUniqueWithoutProductImageInput | DelimitationUpsertWithWhereUniqueWithoutProductImageInput[]
    createMany?: DelimitationCreateManyProductImageInputEnvelope
    set?: DelimitationWhereUniqueInput | DelimitationWhereUniqueInput[]
    disconnect?: DelimitationWhereUniqueInput | DelimitationWhereUniqueInput[]
    delete?: DelimitationWhereUniqueInput | DelimitationWhereUniqueInput[]
    connect?: DelimitationWhereUniqueInput | DelimitationWhereUniqueInput[]
    update?: DelimitationUpdateWithWhereUniqueWithoutProductImageInput | DelimitationUpdateWithWhereUniqueWithoutProductImageInput[]
    updateMany?: DelimitationUpdateManyWithWhereWithoutProductImageInput | DelimitationUpdateManyWithWhereWithoutProductImageInput[]
    deleteMany?: DelimitationScalarWhereInput | DelimitationScalarWhereInput[]
  }

  export type DelimitationUncheckedUpdateManyWithoutProductImageNestedInput = {
    create?: XOR<DelimitationCreateWithoutProductImageInput, DelimitationUncheckedCreateWithoutProductImageInput> | DelimitationCreateWithoutProductImageInput[] | DelimitationUncheckedCreateWithoutProductImageInput[]
    connectOrCreate?: DelimitationCreateOrConnectWithoutProductImageInput | DelimitationCreateOrConnectWithoutProductImageInput[]
    upsert?: DelimitationUpsertWithWhereUniqueWithoutProductImageInput | DelimitationUpsertWithWhereUniqueWithoutProductImageInput[]
    createMany?: DelimitationCreateManyProductImageInputEnvelope
    set?: DelimitationWhereUniqueInput | DelimitationWhereUniqueInput[]
    disconnect?: DelimitationWhereUniqueInput | DelimitationWhereUniqueInput[]
    delete?: DelimitationWhereUniqueInput | DelimitationWhereUniqueInput[]
    connect?: DelimitationWhereUniqueInput | DelimitationWhereUniqueInput[]
    update?: DelimitationUpdateWithWhereUniqueWithoutProductImageInput | DelimitationUpdateWithWhereUniqueWithoutProductImageInput[]
    updateMany?: DelimitationUpdateManyWithWhereWithoutProductImageInput | DelimitationUpdateManyWithWhereWithoutProductImageInput[]
    deleteMany?: DelimitationScalarWhereInput | DelimitationScalarWhereInput[]
  }

  export type ProductImageCreateNestedOneWithoutDelimitationsInput = {
    create?: XOR<ProductImageCreateWithoutDelimitationsInput, ProductImageUncheckedCreateWithoutDelimitationsInput>
    connectOrCreate?: ProductImageCreateOrConnectWithoutDelimitationsInput
    connect?: ProductImageWhereUniqueInput
  }

  export type EnumCoordinateTypeFieldUpdateOperationsInput = {
    set?: $Enums.CoordinateType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductImageUpdateOneRequiredWithoutDelimitationsNestedInput = {
    create?: XOR<ProductImageCreateWithoutDelimitationsInput, ProductImageUncheckedCreateWithoutDelimitationsInput>
    connectOrCreate?: ProductImageCreateOrConnectWithoutDelimitationsInput
    upsert?: ProductImageUpsertWithoutDelimitationsInput
    connect?: ProductImageWhereUniqueInput
    update?: XOR<XOR<ProductImageUpdateToOneWithWhereWithoutDelimitationsInput, ProductImageUpdateWithoutDelimitationsInput>, ProductImageUncheckedUpdateWithoutDelimitationsInput>
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutValidatedOrdersInput = {
    create?: XOR<UserCreateWithoutValidatedOrdersInput, UserUncheckedCreateWithoutValidatedOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutValidatedOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateOneWithoutValidatedOrdersNestedInput = {
    create?: XOR<UserCreateWithoutValidatedOrdersInput, UserUncheckedCreateWithoutValidatedOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutValidatedOrdersInput
    upsert?: UserUpsertWithoutValidatedOrdersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutValidatedOrdersInput, UserUpdateWithoutValidatedOrdersInput>, UserUncheckedUpdateWithoutValidatedOrdersInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type ColorVariationCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ColorVariationCreateWithoutOrderItemsInput, ColorVariationUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ColorVariationCreateOrConnectWithoutOrderItemsInput
    connect?: ColorVariationWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    upsert?: OrderUpsertWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutOrderItemsInput, OrderUpdateWithoutOrderItemsInput>, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ColorVariationUpdateOneWithoutOrderItemsNestedInput = {
    create?: XOR<ColorVariationCreateWithoutOrderItemsInput, ColorVariationUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ColorVariationCreateOrConnectWithoutOrderItemsInput
    upsert?: ColorVariationUpsertWithoutOrderItemsInput
    disconnect?: ColorVariationWhereInput | boolean
    delete?: ColorVariationWhereInput | boolean
    connect?: ColorVariationWhereUniqueInput
    update?: XOR<XOR<ColorVariationUpdateToOneWithWhereWithoutOrderItemsInput, ColorVariationUpdateWithoutOrderItemsInput>, ColorVariationUncheckedUpdateWithoutOrderItemsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type DesignCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutDesignsInput = {
    create?: XOR<UserCreateWithoutDesignsInput, UserUncheckedCreateWithoutDesignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDesignsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutValidatedDesignsInput = {
    create?: XOR<UserCreateWithoutValidatedDesignsInput, UserUncheckedCreateWithoutValidatedDesignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutValidatedDesignsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDesignCategoryFieldUpdateOperationsInput = {
    set?: $Enums.DesignCategory
  }

  export type DesignUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutDesignsNestedInput = {
    create?: XOR<UserCreateWithoutDesignsInput, UserUncheckedCreateWithoutDesignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDesignsInput
    upsert?: UserUpsertWithoutDesignsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDesignsInput, UserUpdateWithoutDesignsInput>, UserUncheckedUpdateWithoutDesignsInput>
  }

  export type UserUpdateOneWithoutValidatedDesignsNestedInput = {
    create?: XOR<UserCreateWithoutValidatedDesignsInput, UserUncheckedCreateWithoutValidatedDesignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutValidatedDesignsInput
    upsert?: UserUpsertWithoutValidatedDesignsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutValidatedDesignsInput, UserUpdateWithoutValidatedDesignsInput>, UserUncheckedUpdateWithoutValidatedDesignsInput>
  }

  export type UserCreateNestedOneWithoutValidatedVendorProductsInput = {
    create?: XOR<UserCreateWithoutValidatedVendorProductsInput, UserUncheckedCreateWithoutValidatedVendorProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutValidatedVendorProductsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVendorProductsInput = {
    create?: XOR<UserCreateWithoutVendorProductsInput, UserUncheckedCreateWithoutVendorProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVendorProductsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutVendorProductsInput = {
    create?: XOR<ProductCreateWithoutVendorProductsInput, ProductUncheckedCreateWithoutVendorProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVendorProductsInput
    connect?: ProductWhereUniqueInput
  }

  export type VendorProductImageCreateNestedManyWithoutVendorProductInput = {
    create?: XOR<VendorProductImageCreateWithoutVendorProductInput, VendorProductImageUncheckedCreateWithoutVendorProductInput> | VendorProductImageCreateWithoutVendorProductInput[] | VendorProductImageUncheckedCreateWithoutVendorProductInput[]
    connectOrCreate?: VendorProductImageCreateOrConnectWithoutVendorProductInput | VendorProductImageCreateOrConnectWithoutVendorProductInput[]
    createMany?: VendorProductImageCreateManyVendorProductInputEnvelope
    connect?: VendorProductImageWhereUniqueInput | VendorProductImageWhereUniqueInput[]
  }

  export type DesignTransformationCreateNestedManyWithoutVendorProductInput = {
    create?: XOR<DesignTransformationCreateWithoutVendorProductInput, DesignTransformationUncheckedCreateWithoutVendorProductInput> | DesignTransformationCreateWithoutVendorProductInput[] | DesignTransformationUncheckedCreateWithoutVendorProductInput[]
    connectOrCreate?: DesignTransformationCreateOrConnectWithoutVendorProductInput | DesignTransformationCreateOrConnectWithoutVendorProductInput[]
    createMany?: DesignTransformationCreateManyVendorProductInputEnvelope
    connect?: DesignTransformationWhereUniqueInput | DesignTransformationWhereUniqueInput[]
  }

  export type VendorProductImageUncheckedCreateNestedManyWithoutVendorProductInput = {
    create?: XOR<VendorProductImageCreateWithoutVendorProductInput, VendorProductImageUncheckedCreateWithoutVendorProductInput> | VendorProductImageCreateWithoutVendorProductInput[] | VendorProductImageUncheckedCreateWithoutVendorProductInput[]
    connectOrCreate?: VendorProductImageCreateOrConnectWithoutVendorProductInput | VendorProductImageCreateOrConnectWithoutVendorProductInput[]
    createMany?: VendorProductImageCreateManyVendorProductInputEnvelope
    connect?: VendorProductImageWhereUniqueInput | VendorProductImageWhereUniqueInput[]
  }

  export type DesignTransformationUncheckedCreateNestedManyWithoutVendorProductInput = {
    create?: XOR<DesignTransformationCreateWithoutVendorProductInput, DesignTransformationUncheckedCreateWithoutVendorProductInput> | DesignTransformationCreateWithoutVendorProductInput[] | DesignTransformationUncheckedCreateWithoutVendorProductInput[]
    connectOrCreate?: DesignTransformationCreateOrConnectWithoutVendorProductInput | DesignTransformationCreateOrConnectWithoutVendorProductInput[]
    createMany?: DesignTransformationCreateManyVendorProductInputEnvelope
    connect?: DesignTransformationWhereUniqueInput | DesignTransformationWhereUniqueInput[]
  }

  export type EnumVendorProductStatusFieldUpdateOperationsInput = {
    set?: $Enums.VendorProductStatus
  }

  export type UserUpdateOneWithoutValidatedVendorProductsNestedInput = {
    create?: XOR<UserCreateWithoutValidatedVendorProductsInput, UserUncheckedCreateWithoutValidatedVendorProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutValidatedVendorProductsInput
    upsert?: UserUpsertWithoutValidatedVendorProductsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutValidatedVendorProductsInput, UserUpdateWithoutValidatedVendorProductsInput>, UserUncheckedUpdateWithoutValidatedVendorProductsInput>
  }

  export type UserUpdateOneRequiredWithoutVendorProductsNestedInput = {
    create?: XOR<UserCreateWithoutVendorProductsInput, UserUncheckedCreateWithoutVendorProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVendorProductsInput
    upsert?: UserUpsertWithoutVendorProductsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVendorProductsInput, UserUpdateWithoutVendorProductsInput>, UserUncheckedUpdateWithoutVendorProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutVendorProductsNestedInput = {
    create?: XOR<ProductCreateWithoutVendorProductsInput, ProductUncheckedCreateWithoutVendorProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVendorProductsInput
    upsert?: ProductUpsertWithoutVendorProductsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutVendorProductsInput, ProductUpdateWithoutVendorProductsInput>, ProductUncheckedUpdateWithoutVendorProductsInput>
  }

  export type VendorProductImageUpdateManyWithoutVendorProductNestedInput = {
    create?: XOR<VendorProductImageCreateWithoutVendorProductInput, VendorProductImageUncheckedCreateWithoutVendorProductInput> | VendorProductImageCreateWithoutVendorProductInput[] | VendorProductImageUncheckedCreateWithoutVendorProductInput[]
    connectOrCreate?: VendorProductImageCreateOrConnectWithoutVendorProductInput | VendorProductImageCreateOrConnectWithoutVendorProductInput[]
    upsert?: VendorProductImageUpsertWithWhereUniqueWithoutVendorProductInput | VendorProductImageUpsertWithWhereUniqueWithoutVendorProductInput[]
    createMany?: VendorProductImageCreateManyVendorProductInputEnvelope
    set?: VendorProductImageWhereUniqueInput | VendorProductImageWhereUniqueInput[]
    disconnect?: VendorProductImageWhereUniqueInput | VendorProductImageWhereUniqueInput[]
    delete?: VendorProductImageWhereUniqueInput | VendorProductImageWhereUniqueInput[]
    connect?: VendorProductImageWhereUniqueInput | VendorProductImageWhereUniqueInput[]
    update?: VendorProductImageUpdateWithWhereUniqueWithoutVendorProductInput | VendorProductImageUpdateWithWhereUniqueWithoutVendorProductInput[]
    updateMany?: VendorProductImageUpdateManyWithWhereWithoutVendorProductInput | VendorProductImageUpdateManyWithWhereWithoutVendorProductInput[]
    deleteMany?: VendorProductImageScalarWhereInput | VendorProductImageScalarWhereInput[]
  }

  export type DesignTransformationUpdateManyWithoutVendorProductNestedInput = {
    create?: XOR<DesignTransformationCreateWithoutVendorProductInput, DesignTransformationUncheckedCreateWithoutVendorProductInput> | DesignTransformationCreateWithoutVendorProductInput[] | DesignTransformationUncheckedCreateWithoutVendorProductInput[]
    connectOrCreate?: DesignTransformationCreateOrConnectWithoutVendorProductInput | DesignTransformationCreateOrConnectWithoutVendorProductInput[]
    upsert?: DesignTransformationUpsertWithWhereUniqueWithoutVendorProductInput | DesignTransformationUpsertWithWhereUniqueWithoutVendorProductInput[]
    createMany?: DesignTransformationCreateManyVendorProductInputEnvelope
    set?: DesignTransformationWhereUniqueInput | DesignTransformationWhereUniqueInput[]
    disconnect?: DesignTransformationWhereUniqueInput | DesignTransformationWhereUniqueInput[]
    delete?: DesignTransformationWhereUniqueInput | DesignTransformationWhereUniqueInput[]
    connect?: DesignTransformationWhereUniqueInput | DesignTransformationWhereUniqueInput[]
    update?: DesignTransformationUpdateWithWhereUniqueWithoutVendorProductInput | DesignTransformationUpdateWithWhereUniqueWithoutVendorProductInput[]
    updateMany?: DesignTransformationUpdateManyWithWhereWithoutVendorProductInput | DesignTransformationUpdateManyWithWhereWithoutVendorProductInput[]
    deleteMany?: DesignTransformationScalarWhereInput | DesignTransformationScalarWhereInput[]
  }

  export type VendorProductImageUncheckedUpdateManyWithoutVendorProductNestedInput = {
    create?: XOR<VendorProductImageCreateWithoutVendorProductInput, VendorProductImageUncheckedCreateWithoutVendorProductInput> | VendorProductImageCreateWithoutVendorProductInput[] | VendorProductImageUncheckedCreateWithoutVendorProductInput[]
    connectOrCreate?: VendorProductImageCreateOrConnectWithoutVendorProductInput | VendorProductImageCreateOrConnectWithoutVendorProductInput[]
    upsert?: VendorProductImageUpsertWithWhereUniqueWithoutVendorProductInput | VendorProductImageUpsertWithWhereUniqueWithoutVendorProductInput[]
    createMany?: VendorProductImageCreateManyVendorProductInputEnvelope
    set?: VendorProductImageWhereUniqueInput | VendorProductImageWhereUniqueInput[]
    disconnect?: VendorProductImageWhereUniqueInput | VendorProductImageWhereUniqueInput[]
    delete?: VendorProductImageWhereUniqueInput | VendorProductImageWhereUniqueInput[]
    connect?: VendorProductImageWhereUniqueInput | VendorProductImageWhereUniqueInput[]
    update?: VendorProductImageUpdateWithWhereUniqueWithoutVendorProductInput | VendorProductImageUpdateWithWhereUniqueWithoutVendorProductInput[]
    updateMany?: VendorProductImageUpdateManyWithWhereWithoutVendorProductInput | VendorProductImageUpdateManyWithWhereWithoutVendorProductInput[]
    deleteMany?: VendorProductImageScalarWhereInput | VendorProductImageScalarWhereInput[]
  }

  export type DesignTransformationUncheckedUpdateManyWithoutVendorProductNestedInput = {
    create?: XOR<DesignTransformationCreateWithoutVendorProductInput, DesignTransformationUncheckedCreateWithoutVendorProductInput> | DesignTransformationCreateWithoutVendorProductInput[] | DesignTransformationUncheckedCreateWithoutVendorProductInput[]
    connectOrCreate?: DesignTransformationCreateOrConnectWithoutVendorProductInput | DesignTransformationCreateOrConnectWithoutVendorProductInput[]
    upsert?: DesignTransformationUpsertWithWhereUniqueWithoutVendorProductInput | DesignTransformationUpsertWithWhereUniqueWithoutVendorProductInput[]
    createMany?: DesignTransformationCreateManyVendorProductInputEnvelope
    set?: DesignTransformationWhereUniqueInput | DesignTransformationWhereUniqueInput[]
    disconnect?: DesignTransformationWhereUniqueInput | DesignTransformationWhereUniqueInput[]
    delete?: DesignTransformationWhereUniqueInput | DesignTransformationWhereUniqueInput[]
    connect?: DesignTransformationWhereUniqueInput | DesignTransformationWhereUniqueInput[]
    update?: DesignTransformationUpdateWithWhereUniqueWithoutVendorProductInput | DesignTransformationUpdateWithWhereUniqueWithoutVendorProductInput[]
    updateMany?: DesignTransformationUpdateManyWithWhereWithoutVendorProductInput | DesignTransformationUpdateManyWithWhereWithoutVendorProductInput[]
    deleteMany?: DesignTransformationScalarWhereInput | DesignTransformationScalarWhereInput[]
  }

  export type VendorProductCreateNestedOneWithoutImagesInput = {
    create?: XOR<VendorProductCreateWithoutImagesInput, VendorProductUncheckedCreateWithoutImagesInput>
    connectOrCreate?: VendorProductCreateOrConnectWithoutImagesInput
    connect?: VendorProductWhereUniqueInput
  }

  export type ColorVariationCreateNestedOneWithoutVendorProductImagesInput = {
    create?: XOR<ColorVariationCreateWithoutVendorProductImagesInput, ColorVariationUncheckedCreateWithoutVendorProductImagesInput>
    connectOrCreate?: ColorVariationCreateOrConnectWithoutVendorProductImagesInput
    connect?: ColorVariationWhereUniqueInput
  }

  export type VendorProductUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<VendorProductCreateWithoutImagesInput, VendorProductUncheckedCreateWithoutImagesInput>
    connectOrCreate?: VendorProductCreateOrConnectWithoutImagesInput
    upsert?: VendorProductUpsertWithoutImagesInput
    connect?: VendorProductWhereUniqueInput
    update?: XOR<XOR<VendorProductUpdateToOneWithWhereWithoutImagesInput, VendorProductUpdateWithoutImagesInput>, VendorProductUncheckedUpdateWithoutImagesInput>
  }

  export type ColorVariationUpdateOneWithoutVendorProductImagesNestedInput = {
    create?: XOR<ColorVariationCreateWithoutVendorProductImagesInput, ColorVariationUncheckedCreateWithoutVendorProductImagesInput>
    connectOrCreate?: ColorVariationCreateOrConnectWithoutVendorProductImagesInput
    upsert?: ColorVariationUpsertWithoutVendorProductImagesInput
    disconnect?: ColorVariationWhereInput | boolean
    delete?: ColorVariationWhereInput | boolean
    connect?: ColorVariationWhereUniqueInput
    update?: XOR<XOR<ColorVariationUpdateToOneWithWhereWithoutVendorProductImagesInput, ColorVariationUpdateWithoutVendorProductImagesInput>, ColorVariationUncheckedUpdateWithoutVendorProductImagesInput>
  }

  export type VendorProductCreateNestedOneWithoutTransformationsInput = {
    create?: XOR<VendorProductCreateWithoutTransformationsInput, VendorProductUncheckedCreateWithoutTransformationsInput>
    connectOrCreate?: VendorProductCreateOrConnectWithoutTransformationsInput
    connect?: VendorProductWhereUniqueInput
  }

  export type EnumDesignPositioningFieldUpdateOperationsInput = {
    set?: $Enums.DesignPositioning
  }

  export type VendorProductUpdateOneRequiredWithoutTransformationsNestedInput = {
    create?: XOR<VendorProductCreateWithoutTransformationsInput, VendorProductUncheckedCreateWithoutTransformationsInput>
    connectOrCreate?: VendorProductCreateOrConnectWithoutTransformationsInput
    upsert?: VendorProductUpsertWithoutTransformationsInput
    connect?: VendorProductWhereUniqueInput
    update?: XOR<XOR<VendorProductUpdateToOneWithWhereWithoutTransformationsInput, VendorProductUpdateWithoutTransformationsInput>, VendorProductUncheckedUpdateWithoutTransformationsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumVendeurTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VendeurType | EnumVendeurTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VendeurType[] | ListEnumVendeurTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VendeurType[] | ListEnumVendeurTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVendeurTypeNullableFilter<$PrismaModel> | $Enums.VendeurType | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumVendeurTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VendeurType | EnumVendeurTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VendeurType[] | ListEnumVendeurTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VendeurType[] | ListEnumVendeurTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVendeurTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.VendeurType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVendeurTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumVendeurTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPublicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PublicationStatus | EnumPublicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublicationStatusFilter<$PrismaModel> | $Enums.PublicationStatus
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPublicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PublicationStatus | EnumPublicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.PublicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPublicationStatusFilter<$PrismaModel>
    _max?: NestedEnumPublicationStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumCoordinateTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CoordinateType | EnumCoordinateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CoordinateType[] | ListEnumCoordinateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoordinateType[] | ListEnumCoordinateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCoordinateTypeFilter<$PrismaModel> | $Enums.CoordinateType
  }

  export type NestedEnumCoordinateTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CoordinateType | EnumCoordinateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CoordinateType[] | ListEnumCoordinateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoordinateType[] | ListEnumCoordinateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCoordinateTypeWithAggregatesFilter<$PrismaModel> | $Enums.CoordinateType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCoordinateTypeFilter<$PrismaModel>
    _max?: NestedEnumCoordinateTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumDesignCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.DesignCategory | EnumDesignCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DesignCategory[] | ListEnumDesignCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.DesignCategory[] | ListEnumDesignCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumDesignCategoryFilter<$PrismaModel> | $Enums.DesignCategory
  }

  export type NestedEnumDesignCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DesignCategory | EnumDesignCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DesignCategory[] | ListEnumDesignCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.DesignCategory[] | ListEnumDesignCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumDesignCategoryWithAggregatesFilter<$PrismaModel> | $Enums.DesignCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDesignCategoryFilter<$PrismaModel>
    _max?: NestedEnumDesignCategoryFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumVendorProductStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorProductStatus | EnumVendorProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VendorProductStatus[] | ListEnumVendorProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorProductStatus[] | ListEnumVendorProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorProductStatusFilter<$PrismaModel> | $Enums.VendorProductStatus
  }

  export type NestedEnumVendorProductStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorProductStatus | EnumVendorProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VendorProductStatus[] | ListEnumVendorProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorProductStatus[] | ListEnumVendorProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorProductStatusWithAggregatesFilter<$PrismaModel> | $Enums.VendorProductStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVendorProductStatusFilter<$PrismaModel>
    _max?: NestedEnumVendorProductStatusFilter<$PrismaModel>
  }

  export type NestedEnumDesignPositioningFilter<$PrismaModel = never> = {
    equals?: $Enums.DesignPositioning | EnumDesignPositioningFieldRefInput<$PrismaModel>
    in?: $Enums.DesignPositioning[] | ListEnumDesignPositioningFieldRefInput<$PrismaModel>
    notIn?: $Enums.DesignPositioning[] | ListEnumDesignPositioningFieldRefInput<$PrismaModel>
    not?: NestedEnumDesignPositioningFilter<$PrismaModel> | $Enums.DesignPositioning
  }

  export type NestedEnumDesignPositioningWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DesignPositioning | EnumDesignPositioningFieldRefInput<$PrismaModel>
    in?: $Enums.DesignPositioning[] | ListEnumDesignPositioningFieldRefInput<$PrismaModel>
    notIn?: $Enums.DesignPositioning[] | ListEnumDesignPositioningFieldRefInput<$PrismaModel>
    not?: NestedEnumDesignPositioningWithAggregatesFilter<$PrismaModel> | $Enums.DesignPositioning
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDesignPositioningFilter<$PrismaModel>
    _max?: NestedEnumDesignPositioningFilter<$PrismaModel>
  }

  export type PasswordResetCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    usedAt?: Date | string | null
  }

  export type PasswordResetUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    usedAt?: Date | string | null
  }

  export type PasswordResetCreateOrConnectWithoutUserInput = {
    where: PasswordResetWhereUniqueInput
    create: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetCreateManyUserInputEnvelope = {
    data: PasswordResetCreateManyUserInput | PasswordResetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutUserInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    totalAmount: number
    phoneNumber: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    shippingName?: string | null
    shippingStreet?: string | null
    shippingCity?: string | null
    shippingRegion?: string | null
    shippingPostalCode?: string | null
    shippingCountry?: string | null
    shippingAddressFull?: string | null
    validator?: UserCreateNestedOneWithoutValidatedOrdersInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: number
    orderNumber: string
    status?: $Enums.OrderStatus
    totalAmount: number
    phoneNumber: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    validatedBy?: number | null
    shippingName?: string | null
    shippingStreet?: string | null
    shippingCity?: string | null
    shippingRegion?: string | null
    shippingPostalCode?: string | null
    shippingCountry?: string | null
    shippingAddressFull?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutValidatorInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    totalAmount: number
    phoneNumber: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    shippingName?: string | null
    shippingStreet?: string | null
    shippingCity?: string | null
    shippingRegion?: string | null
    shippingPostalCode?: string | null
    shippingCountry?: string | null
    shippingAddressFull?: string | null
    user: UserCreateNestedOneWithoutOrdersInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutValidatorInput = {
    id?: number
    orderNumber: string
    userId: number
    status?: $Enums.OrderStatus
    totalAmount: number
    phoneNumber: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    shippingName?: string | null
    shippingStreet?: string | null
    shippingCity?: string | null
    shippingRegion?: string | null
    shippingPostalCode?: string | null
    shippingCountry?: string | null
    shippingAddressFull?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutValidatorInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutValidatorInput, OrderUncheckedCreateWithoutValidatorInput>
  }

  export type OrderCreateManyValidatorInputEnvelope = {
    data: OrderCreateManyValidatorInput | OrderCreateManyValidatorInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DesignCreateWithoutVendorInput = {
    name: string
    description?: string | null
    price: number
    category: $Enums.DesignCategory
    imageUrl: string
    thumbnailUrl?: string | null
    cloudinaryPublicId: string
    thumbnailPublicId?: string | null
    fileSize: number
    originalFileName: string
    dimensions: JsonNullValueInput | InputJsonValue
    format: string
    tags?: DesignCreatetagsInput | string[]
    isDraft?: boolean
    isPublished?: boolean
    isPending?: boolean
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    views?: number
    likes?: number
    earnings?: number
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    validator?: UserCreateNestedOneWithoutValidatedDesignsInput
  }

  export type DesignUncheckedCreateWithoutVendorInput = {
    id?: number
    name: string
    description?: string | null
    price: number
    category: $Enums.DesignCategory
    imageUrl: string
    thumbnailUrl?: string | null
    cloudinaryPublicId: string
    thumbnailPublicId?: string | null
    fileSize: number
    originalFileName: string
    dimensions: JsonNullValueInput | InputJsonValue
    format: string
    tags?: DesignCreatetagsInput | string[]
    isDraft?: boolean
    isPublished?: boolean
    isPending?: boolean
    isValidated?: boolean
    validatedAt?: Date | string | null
    validatedBy?: number | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    views?: number
    likes?: number
    earnings?: number
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type DesignCreateOrConnectWithoutVendorInput = {
    where: DesignWhereUniqueInput
    create: XOR<DesignCreateWithoutVendorInput, DesignUncheckedCreateWithoutVendorInput>
  }

  export type DesignCreateManyVendorInputEnvelope = {
    data: DesignCreateManyVendorInput | DesignCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type DesignCreateWithoutValidatorInput = {
    name: string
    description?: string | null
    price: number
    category: $Enums.DesignCategory
    imageUrl: string
    thumbnailUrl?: string | null
    cloudinaryPublicId: string
    thumbnailPublicId?: string | null
    fileSize: number
    originalFileName: string
    dimensions: JsonNullValueInput | InputJsonValue
    format: string
    tags?: DesignCreatetagsInput | string[]
    isDraft?: boolean
    isPublished?: boolean
    isPending?: boolean
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    views?: number
    likes?: number
    earnings?: number
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    vendor: UserCreateNestedOneWithoutDesignsInput
  }

  export type DesignUncheckedCreateWithoutValidatorInput = {
    id?: number
    vendorId: number
    name: string
    description?: string | null
    price: number
    category: $Enums.DesignCategory
    imageUrl: string
    thumbnailUrl?: string | null
    cloudinaryPublicId: string
    thumbnailPublicId?: string | null
    fileSize: number
    originalFileName: string
    dimensions: JsonNullValueInput | InputJsonValue
    format: string
    tags?: DesignCreatetagsInput | string[]
    isDraft?: boolean
    isPublished?: boolean
    isPending?: boolean
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    views?: number
    likes?: number
    earnings?: number
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type DesignCreateOrConnectWithoutValidatorInput = {
    where: DesignWhereUniqueInput
    create: XOR<DesignCreateWithoutValidatorInput, DesignUncheckedCreateWithoutValidatorInput>
  }

  export type DesignCreateManyValidatorInputEnvelope = {
    data: DesignCreateManyValidatorInput | DesignCreateManyValidatorInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutValidatorInput = {
    name: string
    price: number
    stock: number
    status?: $Enums.PublicationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    hasCustomDesigns?: boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    categories?: CategoryCreateNestedManyWithoutProductsInput
    sizes?: ProductSizeCreateNestedManyWithoutProductInput
    colorVariations?: ColorVariationCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    vendorProducts?: VendorProductCreateNestedManyWithoutBaseProductInput
  }

  export type ProductUncheckedCreateWithoutValidatorInput = {
    id?: number
    name: string
    price: number
    stock: number
    status?: $Enums.PublicationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    hasCustomDesigns?: boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    sizes?: ProductSizeUncheckedCreateNestedManyWithoutProductInput
    colorVariations?: ColorVariationUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    vendorProducts?: VendorProductUncheckedCreateNestedManyWithoutBaseProductInput
  }

  export type ProductCreateOrConnectWithoutValidatorInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutValidatorInput, ProductUncheckedCreateWithoutValidatorInput>
  }

  export type ProductCreateManyValidatorInputEnvelope = {
    data: ProductCreateManyValidatorInput | ProductCreateManyValidatorInput[]
    skipDuplicates?: boolean
  }

  export type VendorProductCreateWithoutValidatorInput = {
    name: string
    description?: string | null
    price: number
    stock?: number
    status?: $Enums.VendorProductStatus
    adminProductName?: string | null
    adminProductDescription?: string | null
    adminProductPrice?: number | null
    designBase64?: string | null
    designCloudinaryUrl?: string | null
    designCloudinaryPublicId?: string | null
    designPositioning?: string | null
    designScale?: number | null
    designApplicationMode?: string | null
    sizes: JsonNullValueInput | InputJsonValue
    colors: JsonNullValueInput | InputJsonValue
    vendorName?: string | null
    vendorDescription?: string | null
    vendorStock?: number
    basePriceAdmin?: number
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: UserCreateNestedOneWithoutVendorProductsInput
    baseProduct: ProductCreateNestedOneWithoutVendorProductsInput
    images?: VendorProductImageCreateNestedManyWithoutVendorProductInput
    transformations?: DesignTransformationCreateNestedManyWithoutVendorProductInput
  }

  export type VendorProductUncheckedCreateWithoutValidatorInput = {
    id?: number
    baseProductId: number
    vendorId: number
    name: string
    description?: string | null
    price: number
    stock?: number
    status?: $Enums.VendorProductStatus
    adminProductName?: string | null
    adminProductDescription?: string | null
    adminProductPrice?: number | null
    designBase64?: string | null
    designCloudinaryUrl?: string | null
    designCloudinaryPublicId?: string | null
    designPositioning?: string | null
    designScale?: number | null
    designApplicationMode?: string | null
    sizes: JsonNullValueInput | InputJsonValue
    colors: JsonNullValueInput | InputJsonValue
    vendorName?: string | null
    vendorDescription?: string | null
    vendorStock?: number
    basePriceAdmin?: number
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VendorProductImageUncheckedCreateNestedManyWithoutVendorProductInput
    transformations?: DesignTransformationUncheckedCreateNestedManyWithoutVendorProductInput
  }

  export type VendorProductCreateOrConnectWithoutValidatorInput = {
    where: VendorProductWhereUniqueInput
    create: XOR<VendorProductCreateWithoutValidatorInput, VendorProductUncheckedCreateWithoutValidatorInput>
  }

  export type VendorProductCreateManyValidatorInputEnvelope = {
    data: VendorProductCreateManyValidatorInput | VendorProductCreateManyValidatorInput[]
    skipDuplicates?: boolean
  }

  export type VendorProductCreateWithoutVendorInput = {
    name: string
    description?: string | null
    price: number
    stock?: number
    status?: $Enums.VendorProductStatus
    adminProductName?: string | null
    adminProductDescription?: string | null
    adminProductPrice?: number | null
    designBase64?: string | null
    designCloudinaryUrl?: string | null
    designCloudinaryPublicId?: string | null
    designPositioning?: string | null
    designScale?: number | null
    designApplicationMode?: string | null
    sizes: JsonNullValueInput | InputJsonValue
    colors: JsonNullValueInput | InputJsonValue
    vendorName?: string | null
    vendorDescription?: string | null
    vendorStock?: number
    basePriceAdmin?: number
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    validator?: UserCreateNestedOneWithoutValidatedVendorProductsInput
    baseProduct: ProductCreateNestedOneWithoutVendorProductsInput
    images?: VendorProductImageCreateNestedManyWithoutVendorProductInput
    transformations?: DesignTransformationCreateNestedManyWithoutVendorProductInput
  }

  export type VendorProductUncheckedCreateWithoutVendorInput = {
    id?: number
    baseProductId: number
    name: string
    description?: string | null
    price: number
    stock?: number
    status?: $Enums.VendorProductStatus
    adminProductName?: string | null
    adminProductDescription?: string | null
    adminProductPrice?: number | null
    designBase64?: string | null
    designCloudinaryUrl?: string | null
    designCloudinaryPublicId?: string | null
    designPositioning?: string | null
    designScale?: number | null
    designApplicationMode?: string | null
    sizes: JsonNullValueInput | InputJsonValue
    colors: JsonNullValueInput | InputJsonValue
    vendorName?: string | null
    vendorDescription?: string | null
    vendorStock?: number
    basePriceAdmin?: number
    isValidated?: boolean
    validatedAt?: Date | string | null
    validatedBy?: number | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VendorProductImageUncheckedCreateNestedManyWithoutVendorProductInput
    transformations?: DesignTransformationUncheckedCreateNestedManyWithoutVendorProductInput
  }

  export type VendorProductCreateOrConnectWithoutVendorInput = {
    where: VendorProductWhereUniqueInput
    create: XOR<VendorProductCreateWithoutVendorInput, VendorProductUncheckedCreateWithoutVendorInput>
  }

  export type VendorProductCreateManyVendorInputEnvelope = {
    data: VendorProductCreateManyVendorInput | VendorProductCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetWhereUniqueInput
    update: XOR<PasswordResetUpdateWithoutUserInput, PasswordResetUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetWhereUniqueInput
    data: XOR<PasswordResetUpdateWithoutUserInput, PasswordResetUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetScalarWhereInput
    data: XOR<PasswordResetUpdateManyMutationInput, PasswordResetUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetScalarWhereInput = {
    AND?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
    OR?: PasswordResetScalarWhereInput[]
    NOT?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
    id?: IntFilter<"PasswordReset"> | number
    token?: StringFilter<"PasswordReset"> | string
    userId?: IntFilter<"PasswordReset"> | number
    expiresAt?: DateTimeFilter<"PasswordReset"> | Date | string
    used?: BoolFilter<"PasswordReset"> | boolean
    createdAt?: DateTimeFilter<"PasswordReset"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordReset"> | Date | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: IntFilter<"Order"> | number
    orderNumber?: StringFilter<"Order"> | string
    userId?: IntFilter<"Order"> | number
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    totalAmount?: FloatFilter<"Order"> | number
    phoneNumber?: StringFilter<"Order"> | string
    notes?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    validatedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    validatedBy?: IntNullableFilter<"Order"> | number | null
    shippingName?: StringNullableFilter<"Order"> | string | null
    shippingStreet?: StringNullableFilter<"Order"> | string | null
    shippingCity?: StringNullableFilter<"Order"> | string | null
    shippingRegion?: StringNullableFilter<"Order"> | string | null
    shippingPostalCode?: StringNullableFilter<"Order"> | string | null
    shippingCountry?: StringNullableFilter<"Order"> | string | null
    shippingAddressFull?: StringNullableFilter<"Order"> | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutValidatorInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutValidatorInput, OrderUncheckedUpdateWithoutValidatorInput>
    create: XOR<OrderCreateWithoutValidatorInput, OrderUncheckedCreateWithoutValidatorInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutValidatorInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutValidatorInput, OrderUncheckedUpdateWithoutValidatorInput>
  }

  export type OrderUpdateManyWithWhereWithoutValidatorInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutValidatorInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
  }

  export type DesignUpsertWithWhereUniqueWithoutVendorInput = {
    where: DesignWhereUniqueInput
    update: XOR<DesignUpdateWithoutVendorInput, DesignUncheckedUpdateWithoutVendorInput>
    create: XOR<DesignCreateWithoutVendorInput, DesignUncheckedCreateWithoutVendorInput>
  }

  export type DesignUpdateWithWhereUniqueWithoutVendorInput = {
    where: DesignWhereUniqueInput
    data: XOR<DesignUpdateWithoutVendorInput, DesignUncheckedUpdateWithoutVendorInput>
  }

  export type DesignUpdateManyWithWhereWithoutVendorInput = {
    where: DesignScalarWhereInput
    data: XOR<DesignUpdateManyMutationInput, DesignUncheckedUpdateManyWithoutVendorInput>
  }

  export type DesignScalarWhereInput = {
    AND?: DesignScalarWhereInput | DesignScalarWhereInput[]
    OR?: DesignScalarWhereInput[]
    NOT?: DesignScalarWhereInput | DesignScalarWhereInput[]
    id?: IntFilter<"Design"> | number
    vendorId?: IntFilter<"Design"> | number
    name?: StringFilter<"Design"> | string
    description?: StringNullableFilter<"Design"> | string | null
    price?: FloatFilter<"Design"> | number
    category?: EnumDesignCategoryFilter<"Design"> | $Enums.DesignCategory
    imageUrl?: StringFilter<"Design"> | string
    thumbnailUrl?: StringNullableFilter<"Design"> | string | null
    cloudinaryPublicId?: StringFilter<"Design"> | string
    thumbnailPublicId?: StringNullableFilter<"Design"> | string | null
    fileSize?: IntFilter<"Design"> | number
    originalFileName?: StringFilter<"Design"> | string
    dimensions?: JsonFilter<"Design">
    format?: StringFilter<"Design"> | string
    tags?: StringNullableListFilter<"Design">
    isDraft?: BoolFilter<"Design"> | boolean
    isPublished?: BoolFilter<"Design"> | boolean
    isPending?: BoolFilter<"Design"> | boolean
    isValidated?: BoolFilter<"Design"> | boolean
    validatedAt?: DateTimeNullableFilter<"Design"> | Date | string | null
    validatedBy?: IntNullableFilter<"Design"> | number | null
    rejectionReason?: StringNullableFilter<"Design"> | string | null
    submittedForValidationAt?: DateTimeNullableFilter<"Design"> | Date | string | null
    views?: IntFilter<"Design"> | number
    likes?: IntFilter<"Design"> | number
    earnings?: FloatFilter<"Design"> | number
    usageCount?: IntFilter<"Design"> | number
    createdAt?: DateTimeFilter<"Design"> | Date | string
    updatedAt?: DateTimeFilter<"Design"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Design"> | Date | string | null
  }

  export type DesignUpsertWithWhereUniqueWithoutValidatorInput = {
    where: DesignWhereUniqueInput
    update: XOR<DesignUpdateWithoutValidatorInput, DesignUncheckedUpdateWithoutValidatorInput>
    create: XOR<DesignCreateWithoutValidatorInput, DesignUncheckedCreateWithoutValidatorInput>
  }

  export type DesignUpdateWithWhereUniqueWithoutValidatorInput = {
    where: DesignWhereUniqueInput
    data: XOR<DesignUpdateWithoutValidatorInput, DesignUncheckedUpdateWithoutValidatorInput>
  }

  export type DesignUpdateManyWithWhereWithoutValidatorInput = {
    where: DesignScalarWhereInput
    data: XOR<DesignUpdateManyMutationInput, DesignUncheckedUpdateManyWithoutValidatorInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutValidatorInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutValidatorInput, ProductUncheckedUpdateWithoutValidatorInput>
    create: XOR<ProductCreateWithoutValidatorInput, ProductUncheckedCreateWithoutValidatorInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutValidatorInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutValidatorInput, ProductUncheckedUpdateWithoutValidatorInput>
  }

  export type ProductUpdateManyWithWhereWithoutValidatorInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutValidatorInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    stock?: IntFilter<"Product"> | number
    status?: EnumPublicationStatusFilter<"Product"> | $Enums.PublicationStatus
    description?: StringFilter<"Product"> | string
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    isValidated?: BoolFilter<"Product"> | boolean
    validatedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    validatedBy?: IntNullableFilter<"Product"> | number | null
    rejectionReason?: StringNullableFilter<"Product"> | string | null
    submittedForValidationAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    hasCustomDesigns?: BoolFilter<"Product"> | boolean
    designsMetadata?: JsonNullableFilter<"Product">
  }

  export type VendorProductUpsertWithWhereUniqueWithoutValidatorInput = {
    where: VendorProductWhereUniqueInput
    update: XOR<VendorProductUpdateWithoutValidatorInput, VendorProductUncheckedUpdateWithoutValidatorInput>
    create: XOR<VendorProductCreateWithoutValidatorInput, VendorProductUncheckedCreateWithoutValidatorInput>
  }

  export type VendorProductUpdateWithWhereUniqueWithoutValidatorInput = {
    where: VendorProductWhereUniqueInput
    data: XOR<VendorProductUpdateWithoutValidatorInput, VendorProductUncheckedUpdateWithoutValidatorInput>
  }

  export type VendorProductUpdateManyWithWhereWithoutValidatorInput = {
    where: VendorProductScalarWhereInput
    data: XOR<VendorProductUpdateManyMutationInput, VendorProductUncheckedUpdateManyWithoutValidatorInput>
  }

  export type VendorProductScalarWhereInput = {
    AND?: VendorProductScalarWhereInput | VendorProductScalarWhereInput[]
    OR?: VendorProductScalarWhereInput[]
    NOT?: VendorProductScalarWhereInput | VendorProductScalarWhereInput[]
    id?: IntFilter<"VendorProduct"> | number
    baseProductId?: IntFilter<"VendorProduct"> | number
    vendorId?: IntFilter<"VendorProduct"> | number
    name?: StringFilter<"VendorProduct"> | string
    description?: StringNullableFilter<"VendorProduct"> | string | null
    price?: IntFilter<"VendorProduct"> | number
    stock?: IntFilter<"VendorProduct"> | number
    status?: EnumVendorProductStatusFilter<"VendorProduct"> | $Enums.VendorProductStatus
    adminProductName?: StringNullableFilter<"VendorProduct"> | string | null
    adminProductDescription?: StringNullableFilter<"VendorProduct"> | string | null
    adminProductPrice?: IntNullableFilter<"VendorProduct"> | number | null
    designBase64?: StringNullableFilter<"VendorProduct"> | string | null
    designCloudinaryUrl?: StringNullableFilter<"VendorProduct"> | string | null
    designCloudinaryPublicId?: StringNullableFilter<"VendorProduct"> | string | null
    designPositioning?: StringNullableFilter<"VendorProduct"> | string | null
    designScale?: FloatNullableFilter<"VendorProduct"> | number | null
    designApplicationMode?: StringNullableFilter<"VendorProduct"> | string | null
    sizes?: JsonFilter<"VendorProduct">
    colors?: JsonFilter<"VendorProduct">
    vendorName?: StringNullableFilter<"VendorProduct"> | string | null
    vendorDescription?: StringNullableFilter<"VendorProduct"> | string | null
    vendorStock?: IntFilter<"VendorProduct"> | number
    basePriceAdmin?: FloatFilter<"VendorProduct"> | number
    isValidated?: BoolFilter<"VendorProduct"> | boolean
    validatedAt?: DateTimeNullableFilter<"VendorProduct"> | Date | string | null
    validatedBy?: IntNullableFilter<"VendorProduct"> | number | null
    rejectionReason?: StringNullableFilter<"VendorProduct"> | string | null
    submittedForValidationAt?: DateTimeNullableFilter<"VendorProduct"> | Date | string | null
    createdAt?: DateTimeFilter<"VendorProduct"> | Date | string
    updatedAt?: DateTimeFilter<"VendorProduct"> | Date | string
  }

  export type VendorProductUpsertWithWhereUniqueWithoutVendorInput = {
    where: VendorProductWhereUniqueInput
    update: XOR<VendorProductUpdateWithoutVendorInput, VendorProductUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorProductCreateWithoutVendorInput, VendorProductUncheckedCreateWithoutVendorInput>
  }

  export type VendorProductUpdateWithWhereUniqueWithoutVendorInput = {
    where: VendorProductWhereUniqueInput
    data: XOR<VendorProductUpdateWithoutVendorInput, VendorProductUncheckedUpdateWithoutVendorInput>
  }

  export type VendorProductUpdateManyWithWhereWithoutVendorInput = {
    where: VendorProductScalarWhereInput
    data: XOR<VendorProductUpdateManyMutationInput, VendorProductUncheckedUpdateManyWithoutVendorInput>
  }

  export type UserCreateWithoutPasswordResetsInput = {
    firstName: string
    lastName: string
    email: string
    password: string
    role?: $Enums.Role
    status?: boolean
    photo_profil?: string | null
    login_attempts?: number
    locked_until?: Date | string | null
    last_login_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    must_change_password?: boolean
    vendeur_type?: $Enums.VendeurType | null
    phone?: string | null
    country?: string | null
    address?: string | null
    shop_name?: string | null
    profile_photo_url?: string | null
    orders?: OrderCreateNestedManyWithoutUserInput
    validatedOrders?: OrderCreateNestedManyWithoutValidatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    designs?: DesignCreateNestedManyWithoutVendorInput
    validatedDesigns?: DesignCreateNestedManyWithoutValidatorInput
    validatedProducts?: ProductCreateNestedManyWithoutValidatorInput
    validatedVendorProducts?: VendorProductCreateNestedManyWithoutValidatorInput
    vendorProducts?: VendorProductCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutPasswordResetsInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    password: string
    role?: $Enums.Role
    status?: boolean
    photo_profil?: string | null
    login_attempts?: number
    locked_until?: Date | string | null
    last_login_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    must_change_password?: boolean
    vendeur_type?: $Enums.VendeurType | null
    phone?: string | null
    country?: string | null
    address?: string | null
    shop_name?: string | null
    profile_photo_url?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    validatedOrders?: OrderUncheckedCreateNestedManyWithoutValidatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    designs?: DesignUncheckedCreateNestedManyWithoutVendorInput
    validatedDesigns?: DesignUncheckedCreateNestedManyWithoutValidatorInput
    validatedProducts?: ProductUncheckedCreateNestedManyWithoutValidatorInput
    validatedVendorProducts?: VendorProductUncheckedCreateNestedManyWithoutValidatorInput
    vendorProducts?: VendorProductUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutPasswordResetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
  }

  export type UserUpsertWithoutPasswordResetsInput = {
    update: XOR<UserUpdateWithoutPasswordResetsInput, UserUncheckedUpdateWithoutPasswordResetsInput>
    create: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetsInput, UserUncheckedUpdateWithoutPasswordResetsInput>
  }

  export type UserUpdateWithoutPasswordResetsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutUserNestedInput
    validatedOrders?: OrderUpdateManyWithoutValidatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    designs?: DesignUpdateManyWithoutVendorNestedInput
    validatedDesigns?: DesignUpdateManyWithoutValidatorNestedInput
    validatedProducts?: ProductUpdateManyWithoutValidatorNestedInput
    validatedVendorProducts?: VendorProductUpdateManyWithoutValidatorNestedInput
    vendorProducts?: VendorProductUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    validatedOrders?: OrderUncheckedUpdateManyWithoutValidatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    designs?: DesignUncheckedUpdateManyWithoutVendorNestedInput
    validatedDesigns?: DesignUncheckedUpdateManyWithoutValidatorNestedInput
    validatedProducts?: ProductUncheckedUpdateManyWithoutValidatorNestedInput
    validatedVendorProducts?: VendorProductUncheckedUpdateManyWithoutValidatorNestedInput
    vendorProducts?: VendorProductUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserCreateWithoutValidatedProductsInput = {
    firstName: string
    lastName: string
    email: string
    password: string
    role?: $Enums.Role
    status?: boolean
    photo_profil?: string | null
    login_attempts?: number
    locked_until?: Date | string | null
    last_login_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    must_change_password?: boolean
    vendeur_type?: $Enums.VendeurType | null
    phone?: string | null
    country?: string | null
    address?: string | null
    shop_name?: string | null
    profile_photo_url?: string | null
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    validatedOrders?: OrderCreateNestedManyWithoutValidatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    designs?: DesignCreateNestedManyWithoutVendorInput
    validatedDesigns?: DesignCreateNestedManyWithoutValidatorInput
    validatedVendorProducts?: VendorProductCreateNestedManyWithoutValidatorInput
    vendorProducts?: VendorProductCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutValidatedProductsInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    password: string
    role?: $Enums.Role
    status?: boolean
    photo_profil?: string | null
    login_attempts?: number
    locked_until?: Date | string | null
    last_login_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    must_change_password?: boolean
    vendeur_type?: $Enums.VendeurType | null
    phone?: string | null
    country?: string | null
    address?: string | null
    shop_name?: string | null
    profile_photo_url?: string | null
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    validatedOrders?: OrderUncheckedCreateNestedManyWithoutValidatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    designs?: DesignUncheckedCreateNestedManyWithoutVendorInput
    validatedDesigns?: DesignUncheckedCreateNestedManyWithoutValidatorInput
    validatedVendorProducts?: VendorProductUncheckedCreateNestedManyWithoutValidatorInput
    vendorProducts?: VendorProductUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutValidatedProductsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutValidatedProductsInput, UserUncheckedCreateWithoutValidatedProductsInput>
  }

  export type CategoryCreateWithoutProductsInput = {
    name: string
    description?: string | null
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type ProductSizeCreateWithoutProductInput = {
    sizeName: string
  }

  export type ProductSizeUncheckedCreateWithoutProductInput = {
    id?: number
    sizeName: string
  }

  export type ProductSizeCreateOrConnectWithoutProductInput = {
    where: ProductSizeWhereUniqueInput
    create: XOR<ProductSizeCreateWithoutProductInput, ProductSizeUncheckedCreateWithoutProductInput>
  }

  export type ProductSizeCreateManyProductInputEnvelope = {
    data: ProductSizeCreateManyProductInput | ProductSizeCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ColorVariationCreateWithoutProductInput = {
    name: string
    colorCode: string
    images?: ProductImageCreateNestedManyWithoutColorVariationInput
    orderItems?: OrderItemCreateNestedManyWithoutColorVariationInput
    vendorProductImages?: VendorProductImageCreateNestedManyWithoutColorVariationInput
  }

  export type ColorVariationUncheckedCreateWithoutProductInput = {
    id?: number
    name: string
    colorCode: string
    images?: ProductImageUncheckedCreateNestedManyWithoutColorVariationInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutColorVariationInput
    vendorProductImages?: VendorProductImageUncheckedCreateNestedManyWithoutColorVariationInput
  }

  export type ColorVariationCreateOrConnectWithoutProductInput = {
    where: ColorVariationWhereUniqueInput
    create: XOR<ColorVariationCreateWithoutProductInput, ColorVariationUncheckedCreateWithoutProductInput>
  }

  export type ColorVariationCreateManyProductInputEnvelope = {
    data: ColorVariationCreateManyProductInput | ColorVariationCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutProductInput = {
    quantity: number
    unitPrice: number
    size?: string | null
    color?: string | null
    order: OrderCreateNestedOneWithoutOrderItemsInput
    colorVariation?: ColorVariationCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: number
    orderId: number
    quantity: number
    unitPrice: number
    size?: string | null
    color?: string | null
    colorId?: number | null
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type VendorProductCreateWithoutBaseProductInput = {
    name: string
    description?: string | null
    price: number
    stock?: number
    status?: $Enums.VendorProductStatus
    adminProductName?: string | null
    adminProductDescription?: string | null
    adminProductPrice?: number | null
    designBase64?: string | null
    designCloudinaryUrl?: string | null
    designCloudinaryPublicId?: string | null
    designPositioning?: string | null
    designScale?: number | null
    designApplicationMode?: string | null
    sizes: JsonNullValueInput | InputJsonValue
    colors: JsonNullValueInput | InputJsonValue
    vendorName?: string | null
    vendorDescription?: string | null
    vendorStock?: number
    basePriceAdmin?: number
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    validator?: UserCreateNestedOneWithoutValidatedVendorProductsInput
    vendor: UserCreateNestedOneWithoutVendorProductsInput
    images?: VendorProductImageCreateNestedManyWithoutVendorProductInput
    transformations?: DesignTransformationCreateNestedManyWithoutVendorProductInput
  }

  export type VendorProductUncheckedCreateWithoutBaseProductInput = {
    id?: number
    vendorId: number
    name: string
    description?: string | null
    price: number
    stock?: number
    status?: $Enums.VendorProductStatus
    adminProductName?: string | null
    adminProductDescription?: string | null
    adminProductPrice?: number | null
    designBase64?: string | null
    designCloudinaryUrl?: string | null
    designCloudinaryPublicId?: string | null
    designPositioning?: string | null
    designScale?: number | null
    designApplicationMode?: string | null
    sizes: JsonNullValueInput | InputJsonValue
    colors: JsonNullValueInput | InputJsonValue
    vendorName?: string | null
    vendorDescription?: string | null
    vendorStock?: number
    basePriceAdmin?: number
    isValidated?: boolean
    validatedAt?: Date | string | null
    validatedBy?: number | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VendorProductImageUncheckedCreateNestedManyWithoutVendorProductInput
    transformations?: DesignTransformationUncheckedCreateNestedManyWithoutVendorProductInput
  }

  export type VendorProductCreateOrConnectWithoutBaseProductInput = {
    where: VendorProductWhereUniqueInput
    create: XOR<VendorProductCreateWithoutBaseProductInput, VendorProductUncheckedCreateWithoutBaseProductInput>
  }

  export type VendorProductCreateManyBaseProductInputEnvelope = {
    data: VendorProductCreateManyBaseProductInput | VendorProductCreateManyBaseProductInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutValidatedProductsInput = {
    update: XOR<UserUpdateWithoutValidatedProductsInput, UserUncheckedUpdateWithoutValidatedProductsInput>
    create: XOR<UserCreateWithoutValidatedProductsInput, UserUncheckedCreateWithoutValidatedProductsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutValidatedProductsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutValidatedProductsInput, UserUncheckedUpdateWithoutValidatedProductsInput>
  }

  export type UserUpdateWithoutValidatedProductsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    validatedOrders?: OrderUpdateManyWithoutValidatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    designs?: DesignUpdateManyWithoutVendorNestedInput
    validatedDesigns?: DesignUpdateManyWithoutValidatorNestedInput
    validatedVendorProducts?: VendorProductUpdateManyWithoutValidatorNestedInput
    vendorProducts?: VendorProductUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutValidatedProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    validatedOrders?: OrderUncheckedUpdateManyWithoutValidatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    designs?: DesignUncheckedUpdateManyWithoutVendorNestedInput
    validatedDesigns?: DesignUncheckedUpdateManyWithoutValidatorNestedInput
    validatedVendorProducts?: VendorProductUncheckedUpdateManyWithoutValidatorNestedInput
    vendorProducts?: VendorProductUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateManyWithWhereWithoutProductsInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutProductsInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
  }

  export type ProductSizeUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductSizeWhereUniqueInput
    update: XOR<ProductSizeUpdateWithoutProductInput, ProductSizeUncheckedUpdateWithoutProductInput>
    create: XOR<ProductSizeCreateWithoutProductInput, ProductSizeUncheckedCreateWithoutProductInput>
  }

  export type ProductSizeUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductSizeWhereUniqueInput
    data: XOR<ProductSizeUpdateWithoutProductInput, ProductSizeUncheckedUpdateWithoutProductInput>
  }

  export type ProductSizeUpdateManyWithWhereWithoutProductInput = {
    where: ProductSizeScalarWhereInput
    data: XOR<ProductSizeUpdateManyMutationInput, ProductSizeUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductSizeScalarWhereInput = {
    AND?: ProductSizeScalarWhereInput | ProductSizeScalarWhereInput[]
    OR?: ProductSizeScalarWhereInput[]
    NOT?: ProductSizeScalarWhereInput | ProductSizeScalarWhereInput[]
    id?: IntFilter<"ProductSize"> | number
    productId?: IntFilter<"ProductSize"> | number
    sizeName?: StringFilter<"ProductSize"> | string
  }

  export type ColorVariationUpsertWithWhereUniqueWithoutProductInput = {
    where: ColorVariationWhereUniqueInput
    update: XOR<ColorVariationUpdateWithoutProductInput, ColorVariationUncheckedUpdateWithoutProductInput>
    create: XOR<ColorVariationCreateWithoutProductInput, ColorVariationUncheckedCreateWithoutProductInput>
  }

  export type ColorVariationUpdateWithWhereUniqueWithoutProductInput = {
    where: ColorVariationWhereUniqueInput
    data: XOR<ColorVariationUpdateWithoutProductInput, ColorVariationUncheckedUpdateWithoutProductInput>
  }

  export type ColorVariationUpdateManyWithWhereWithoutProductInput = {
    where: ColorVariationScalarWhereInput
    data: XOR<ColorVariationUpdateManyMutationInput, ColorVariationUncheckedUpdateManyWithoutProductInput>
  }

  export type ColorVariationScalarWhereInput = {
    AND?: ColorVariationScalarWhereInput | ColorVariationScalarWhereInput[]
    OR?: ColorVariationScalarWhereInput[]
    NOT?: ColorVariationScalarWhereInput | ColorVariationScalarWhereInput[]
    id?: IntFilter<"ColorVariation"> | number
    name?: StringFilter<"ColorVariation"> | string
    colorCode?: StringFilter<"ColorVariation"> | string
    productId?: IntFilter<"ColorVariation"> | number
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    productId?: IntFilter<"OrderItem"> | number
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: FloatFilter<"OrderItem"> | number
    size?: StringNullableFilter<"OrderItem"> | string | null
    color?: StringNullableFilter<"OrderItem"> | string | null
    colorId?: IntNullableFilter<"OrderItem"> | number | null
  }

  export type VendorProductUpsertWithWhereUniqueWithoutBaseProductInput = {
    where: VendorProductWhereUniqueInput
    update: XOR<VendorProductUpdateWithoutBaseProductInput, VendorProductUncheckedUpdateWithoutBaseProductInput>
    create: XOR<VendorProductCreateWithoutBaseProductInput, VendorProductUncheckedCreateWithoutBaseProductInput>
  }

  export type VendorProductUpdateWithWhereUniqueWithoutBaseProductInput = {
    where: VendorProductWhereUniqueInput
    data: XOR<VendorProductUpdateWithoutBaseProductInput, VendorProductUncheckedUpdateWithoutBaseProductInput>
  }

  export type VendorProductUpdateManyWithWhereWithoutBaseProductInput = {
    where: VendorProductScalarWhereInput
    data: XOR<VendorProductUpdateManyMutationInput, VendorProductUncheckedUpdateManyWithoutBaseProductInput>
  }

  export type ProductCreateWithoutSizesInput = {
    name: string
    price: number
    stock: number
    status?: $Enums.PublicationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    hasCustomDesigns?: boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    validator?: UserCreateNestedOneWithoutValidatedProductsInput
    categories?: CategoryCreateNestedManyWithoutProductsInput
    colorVariations?: ColorVariationCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    vendorProducts?: VendorProductCreateNestedManyWithoutBaseProductInput
  }

  export type ProductUncheckedCreateWithoutSizesInput = {
    id?: number
    name: string
    price: number
    stock: number
    status?: $Enums.PublicationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isValidated?: boolean
    validatedAt?: Date | string | null
    validatedBy?: number | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    hasCustomDesigns?: boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    colorVariations?: ColorVariationUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    vendorProducts?: VendorProductUncheckedCreateNestedManyWithoutBaseProductInput
  }

  export type ProductCreateOrConnectWithoutSizesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSizesInput, ProductUncheckedCreateWithoutSizesInput>
  }

  export type ProductUpsertWithoutSizesInput = {
    update: XOR<ProductUpdateWithoutSizesInput, ProductUncheckedUpdateWithoutSizesInput>
    create: XOR<ProductCreateWithoutSizesInput, ProductUncheckedCreateWithoutSizesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSizesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSizesInput, ProductUncheckedUpdateWithoutSizesInput>
  }

  export type ProductUpdateWithoutSizesInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasCustomDesigns?: BoolFieldUpdateOperationsInput | boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    validator?: UserUpdateOneWithoutValidatedProductsNestedInput
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    colorVariations?: ColorVariationUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    vendorProducts?: VendorProductUpdateManyWithoutBaseProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSizesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasCustomDesigns?: BoolFieldUpdateOperationsInput | boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    colorVariations?: ColorVariationUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    vendorProducts?: VendorProductUncheckedUpdateManyWithoutBaseProductNestedInput
  }

  export type ProductCreateWithoutCategoriesInput = {
    name: string
    price: number
    stock: number
    status?: $Enums.PublicationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    hasCustomDesigns?: boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    validator?: UserCreateNestedOneWithoutValidatedProductsInput
    sizes?: ProductSizeCreateNestedManyWithoutProductInput
    colorVariations?: ColorVariationCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    vendorProducts?: VendorProductCreateNestedManyWithoutBaseProductInput
  }

  export type ProductUncheckedCreateWithoutCategoriesInput = {
    id?: number
    name: string
    price: number
    stock: number
    status?: $Enums.PublicationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isValidated?: boolean
    validatedAt?: Date | string | null
    validatedBy?: number | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    hasCustomDesigns?: boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    sizes?: ProductSizeUncheckedCreateNestedManyWithoutProductInput
    colorVariations?: ColorVariationUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    vendorProducts?: VendorProductUncheckedCreateNestedManyWithoutBaseProductInput
  }

  export type ProductCreateOrConnectWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoriesInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type ProductCreateWithoutColorVariationsInput = {
    name: string
    price: number
    stock: number
    status?: $Enums.PublicationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    hasCustomDesigns?: boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    validator?: UserCreateNestedOneWithoutValidatedProductsInput
    categories?: CategoryCreateNestedManyWithoutProductsInput
    sizes?: ProductSizeCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    vendorProducts?: VendorProductCreateNestedManyWithoutBaseProductInput
  }

  export type ProductUncheckedCreateWithoutColorVariationsInput = {
    id?: number
    name: string
    price: number
    stock: number
    status?: $Enums.PublicationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isValidated?: boolean
    validatedAt?: Date | string | null
    validatedBy?: number | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    hasCustomDesigns?: boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    sizes?: ProductSizeUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    vendorProducts?: VendorProductUncheckedCreateNestedManyWithoutBaseProductInput
  }

  export type ProductCreateOrConnectWithoutColorVariationsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutColorVariationsInput, ProductUncheckedCreateWithoutColorVariationsInput>
  }

  export type ProductImageCreateWithoutColorVariationInput = {
    view: string
    url: string
    publicId: string
    naturalWidth?: number | null
    naturalHeight?: number | null
    designUrl?: string | null
    designPublicId?: string | null
    designFileName?: string | null
    designUploadDate?: Date | string | null
    designSize?: number | null
    designOriginalName?: string | null
    designDescription?: string | null
    isDesignActive?: boolean
    delimitations?: DelimitationCreateNestedManyWithoutProductImageInput
  }

  export type ProductImageUncheckedCreateWithoutColorVariationInput = {
    id?: number
    view: string
    url: string
    publicId: string
    naturalWidth?: number | null
    naturalHeight?: number | null
    designUrl?: string | null
    designPublicId?: string | null
    designFileName?: string | null
    designUploadDate?: Date | string | null
    designSize?: number | null
    designOriginalName?: string | null
    designDescription?: string | null
    isDesignActive?: boolean
    delimitations?: DelimitationUncheckedCreateNestedManyWithoutProductImageInput
  }

  export type ProductImageCreateOrConnectWithoutColorVariationInput = {
    where: ProductImageWhereUniqueInput
    create: XOR<ProductImageCreateWithoutColorVariationInput, ProductImageUncheckedCreateWithoutColorVariationInput>
  }

  export type ProductImageCreateManyColorVariationInputEnvelope = {
    data: ProductImageCreateManyColorVariationInput | ProductImageCreateManyColorVariationInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutColorVariationInput = {
    quantity: number
    unitPrice: number
    size?: string | null
    color?: string | null
    order: OrderCreateNestedOneWithoutOrderItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutColorVariationInput = {
    id?: number
    orderId: number
    productId: number
    quantity: number
    unitPrice: number
    size?: string | null
    color?: string | null
  }

  export type OrderItemCreateOrConnectWithoutColorVariationInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutColorVariationInput, OrderItemUncheckedCreateWithoutColorVariationInput>
  }

  export type OrderItemCreateManyColorVariationInputEnvelope = {
    data: OrderItemCreateManyColorVariationInput | OrderItemCreateManyColorVariationInput[]
    skipDuplicates?: boolean
  }

  export type VendorProductImageCreateWithoutColorVariationInput = {
    colorName?: string | null
    colorCode?: string | null
    imageType?: string
    cloudinaryUrl: string
    cloudinaryPublicId: string
    originalImageKey?: string | null
    width?: number | null
    height?: number | null
    fileSize?: number | null
    format?: string | null
    createdAt?: Date | string
    uploadedAt?: Date | string
    vendorProduct: VendorProductCreateNestedOneWithoutImagesInput
  }

  export type VendorProductImageUncheckedCreateWithoutColorVariationInput = {
    id?: number
    vendorProductId: number
    colorName?: string | null
    colorCode?: string | null
    imageType?: string
    cloudinaryUrl: string
    cloudinaryPublicId: string
    originalImageKey?: string | null
    width?: number | null
    height?: number | null
    fileSize?: number | null
    format?: string | null
    createdAt?: Date | string
    uploadedAt?: Date | string
  }

  export type VendorProductImageCreateOrConnectWithoutColorVariationInput = {
    where: VendorProductImageWhereUniqueInput
    create: XOR<VendorProductImageCreateWithoutColorVariationInput, VendorProductImageUncheckedCreateWithoutColorVariationInput>
  }

  export type VendorProductImageCreateManyColorVariationInputEnvelope = {
    data: VendorProductImageCreateManyColorVariationInput | VendorProductImageCreateManyColorVariationInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutColorVariationsInput = {
    update: XOR<ProductUpdateWithoutColorVariationsInput, ProductUncheckedUpdateWithoutColorVariationsInput>
    create: XOR<ProductCreateWithoutColorVariationsInput, ProductUncheckedCreateWithoutColorVariationsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutColorVariationsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutColorVariationsInput, ProductUncheckedUpdateWithoutColorVariationsInput>
  }

  export type ProductUpdateWithoutColorVariationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasCustomDesigns?: BoolFieldUpdateOperationsInput | boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    validator?: UserUpdateOneWithoutValidatedProductsNestedInput
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    sizes?: ProductSizeUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    vendorProducts?: VendorProductUpdateManyWithoutBaseProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutColorVariationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasCustomDesigns?: BoolFieldUpdateOperationsInput | boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    sizes?: ProductSizeUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    vendorProducts?: VendorProductUncheckedUpdateManyWithoutBaseProductNestedInput
  }

  export type ProductImageUpsertWithWhereUniqueWithoutColorVariationInput = {
    where: ProductImageWhereUniqueInput
    update: XOR<ProductImageUpdateWithoutColorVariationInput, ProductImageUncheckedUpdateWithoutColorVariationInput>
    create: XOR<ProductImageCreateWithoutColorVariationInput, ProductImageUncheckedCreateWithoutColorVariationInput>
  }

  export type ProductImageUpdateWithWhereUniqueWithoutColorVariationInput = {
    where: ProductImageWhereUniqueInput
    data: XOR<ProductImageUpdateWithoutColorVariationInput, ProductImageUncheckedUpdateWithoutColorVariationInput>
  }

  export type ProductImageUpdateManyWithWhereWithoutColorVariationInput = {
    where: ProductImageScalarWhereInput
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyWithoutColorVariationInput>
  }

  export type ProductImageScalarWhereInput = {
    AND?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
    OR?: ProductImageScalarWhereInput[]
    NOT?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
    id?: IntFilter<"ProductImage"> | number
    view?: StringFilter<"ProductImage"> | string
    url?: StringFilter<"ProductImage"> | string
    publicId?: StringFilter<"ProductImage"> | string
    naturalWidth?: IntNullableFilter<"ProductImage"> | number | null
    naturalHeight?: IntNullableFilter<"ProductImage"> | number | null
    designUrl?: StringNullableFilter<"ProductImage"> | string | null
    designPublicId?: StringNullableFilter<"ProductImage"> | string | null
    designFileName?: StringNullableFilter<"ProductImage"> | string | null
    designUploadDate?: DateTimeNullableFilter<"ProductImage"> | Date | string | null
    designSize?: IntNullableFilter<"ProductImage"> | number | null
    designOriginalName?: StringNullableFilter<"ProductImage"> | string | null
    designDescription?: StringNullableFilter<"ProductImage"> | string | null
    isDesignActive?: BoolFilter<"ProductImage"> | boolean
    colorVariationId?: IntFilter<"ProductImage"> | number
  }

  export type OrderItemUpsertWithWhereUniqueWithoutColorVariationInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutColorVariationInput, OrderItemUncheckedUpdateWithoutColorVariationInput>
    create: XOR<OrderItemCreateWithoutColorVariationInput, OrderItemUncheckedCreateWithoutColorVariationInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutColorVariationInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutColorVariationInput, OrderItemUncheckedUpdateWithoutColorVariationInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutColorVariationInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutColorVariationInput>
  }

  export type VendorProductImageUpsertWithWhereUniqueWithoutColorVariationInput = {
    where: VendorProductImageWhereUniqueInput
    update: XOR<VendorProductImageUpdateWithoutColorVariationInput, VendorProductImageUncheckedUpdateWithoutColorVariationInput>
    create: XOR<VendorProductImageCreateWithoutColorVariationInput, VendorProductImageUncheckedCreateWithoutColorVariationInput>
  }

  export type VendorProductImageUpdateWithWhereUniqueWithoutColorVariationInput = {
    where: VendorProductImageWhereUniqueInput
    data: XOR<VendorProductImageUpdateWithoutColorVariationInput, VendorProductImageUncheckedUpdateWithoutColorVariationInput>
  }

  export type VendorProductImageUpdateManyWithWhereWithoutColorVariationInput = {
    where: VendorProductImageScalarWhereInput
    data: XOR<VendorProductImageUpdateManyMutationInput, VendorProductImageUncheckedUpdateManyWithoutColorVariationInput>
  }

  export type VendorProductImageScalarWhereInput = {
    AND?: VendorProductImageScalarWhereInput | VendorProductImageScalarWhereInput[]
    OR?: VendorProductImageScalarWhereInput[]
    NOT?: VendorProductImageScalarWhereInput | VendorProductImageScalarWhereInput[]
    id?: IntFilter<"VendorProductImage"> | number
    vendorProductId?: IntFilter<"VendorProductImage"> | number
    colorId?: IntNullableFilter<"VendorProductImage"> | number | null
    colorName?: StringNullableFilter<"VendorProductImage"> | string | null
    colorCode?: StringNullableFilter<"VendorProductImage"> | string | null
    imageType?: StringFilter<"VendorProductImage"> | string
    cloudinaryUrl?: StringFilter<"VendorProductImage"> | string
    cloudinaryPublicId?: StringFilter<"VendorProductImage"> | string
    originalImageKey?: StringNullableFilter<"VendorProductImage"> | string | null
    width?: IntNullableFilter<"VendorProductImage"> | number | null
    height?: IntNullableFilter<"VendorProductImage"> | number | null
    fileSize?: IntNullableFilter<"VendorProductImage"> | number | null
    format?: StringNullableFilter<"VendorProductImage"> | string | null
    createdAt?: DateTimeFilter<"VendorProductImage"> | Date | string
    uploadedAt?: DateTimeFilter<"VendorProductImage"> | Date | string
  }

  export type ColorVariationCreateWithoutImagesInput = {
    name: string
    colorCode: string
    product: ProductCreateNestedOneWithoutColorVariationsInput
    orderItems?: OrderItemCreateNestedManyWithoutColorVariationInput
    vendorProductImages?: VendorProductImageCreateNestedManyWithoutColorVariationInput
  }

  export type ColorVariationUncheckedCreateWithoutImagesInput = {
    id?: number
    name: string
    colorCode: string
    productId: number
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutColorVariationInput
    vendorProductImages?: VendorProductImageUncheckedCreateNestedManyWithoutColorVariationInput
  }

  export type ColorVariationCreateOrConnectWithoutImagesInput = {
    where: ColorVariationWhereUniqueInput
    create: XOR<ColorVariationCreateWithoutImagesInput, ColorVariationUncheckedCreateWithoutImagesInput>
  }

  export type DelimitationCreateWithoutProductImageInput = {
    x: number
    y: number
    width: number
    height: number
    rotation?: number
    name?: string | null
    coordinateType?: $Enums.CoordinateType
    absoluteX?: number | null
    absoluteY?: number | null
    absoluteWidth?: number | null
    absoluteHeight?: number | null
    originalImageWidth?: number | null
    originalImageHeight?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceWidth?: number
    referenceHeight?: number
  }

  export type DelimitationUncheckedCreateWithoutProductImageInput = {
    id?: number
    x: number
    y: number
    width: number
    height: number
    rotation?: number
    name?: string | null
    coordinateType?: $Enums.CoordinateType
    absoluteX?: number | null
    absoluteY?: number | null
    absoluteWidth?: number | null
    absoluteHeight?: number | null
    originalImageWidth?: number | null
    originalImageHeight?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceWidth?: number
    referenceHeight?: number
  }

  export type DelimitationCreateOrConnectWithoutProductImageInput = {
    where: DelimitationWhereUniqueInput
    create: XOR<DelimitationCreateWithoutProductImageInput, DelimitationUncheckedCreateWithoutProductImageInput>
  }

  export type DelimitationCreateManyProductImageInputEnvelope = {
    data: DelimitationCreateManyProductImageInput | DelimitationCreateManyProductImageInput[]
    skipDuplicates?: boolean
  }

  export type ColorVariationUpsertWithoutImagesInput = {
    update: XOR<ColorVariationUpdateWithoutImagesInput, ColorVariationUncheckedUpdateWithoutImagesInput>
    create: XOR<ColorVariationCreateWithoutImagesInput, ColorVariationUncheckedCreateWithoutImagesInput>
    where?: ColorVariationWhereInput
  }

  export type ColorVariationUpdateToOneWithWhereWithoutImagesInput = {
    where?: ColorVariationWhereInput
    data: XOR<ColorVariationUpdateWithoutImagesInput, ColorVariationUncheckedUpdateWithoutImagesInput>
  }

  export type ColorVariationUpdateWithoutImagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    colorCode?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutColorVariationsNestedInput
    orderItems?: OrderItemUpdateManyWithoutColorVariationNestedInput
    vendorProductImages?: VendorProductImageUpdateManyWithoutColorVariationNestedInput
  }

  export type ColorVariationUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    colorCode?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    orderItems?: OrderItemUncheckedUpdateManyWithoutColorVariationNestedInput
    vendorProductImages?: VendorProductImageUncheckedUpdateManyWithoutColorVariationNestedInput
  }

  export type DelimitationUpsertWithWhereUniqueWithoutProductImageInput = {
    where: DelimitationWhereUniqueInput
    update: XOR<DelimitationUpdateWithoutProductImageInput, DelimitationUncheckedUpdateWithoutProductImageInput>
    create: XOR<DelimitationCreateWithoutProductImageInput, DelimitationUncheckedCreateWithoutProductImageInput>
  }

  export type DelimitationUpdateWithWhereUniqueWithoutProductImageInput = {
    where: DelimitationWhereUniqueInput
    data: XOR<DelimitationUpdateWithoutProductImageInput, DelimitationUncheckedUpdateWithoutProductImageInput>
  }

  export type DelimitationUpdateManyWithWhereWithoutProductImageInput = {
    where: DelimitationScalarWhereInput
    data: XOR<DelimitationUpdateManyMutationInput, DelimitationUncheckedUpdateManyWithoutProductImageInput>
  }

  export type DelimitationScalarWhereInput = {
    AND?: DelimitationScalarWhereInput | DelimitationScalarWhereInput[]
    OR?: DelimitationScalarWhereInput[]
    NOT?: DelimitationScalarWhereInput | DelimitationScalarWhereInput[]
    id?: IntFilter<"Delimitation"> | number
    x?: FloatFilter<"Delimitation"> | number
    y?: FloatFilter<"Delimitation"> | number
    width?: FloatFilter<"Delimitation"> | number
    height?: FloatFilter<"Delimitation"> | number
    rotation?: FloatFilter<"Delimitation"> | number
    name?: StringNullableFilter<"Delimitation"> | string | null
    coordinateType?: EnumCoordinateTypeFilter<"Delimitation"> | $Enums.CoordinateType
    absoluteX?: FloatNullableFilter<"Delimitation"> | number | null
    absoluteY?: FloatNullableFilter<"Delimitation"> | number | null
    absoluteWidth?: FloatNullableFilter<"Delimitation"> | number | null
    absoluteHeight?: FloatNullableFilter<"Delimitation"> | number | null
    originalImageWidth?: IntNullableFilter<"Delimitation"> | number | null
    originalImageHeight?: IntNullableFilter<"Delimitation"> | number | null
    productImageId?: IntFilter<"Delimitation"> | number
    createdAt?: DateTimeFilter<"Delimitation"> | Date | string
    updatedAt?: DateTimeFilter<"Delimitation"> | Date | string
    referenceWidth?: IntFilter<"Delimitation"> | number
    referenceHeight?: IntFilter<"Delimitation"> | number
  }

  export type ProductImageCreateWithoutDelimitationsInput = {
    view: string
    url: string
    publicId: string
    naturalWidth?: number | null
    naturalHeight?: number | null
    designUrl?: string | null
    designPublicId?: string | null
    designFileName?: string | null
    designUploadDate?: Date | string | null
    designSize?: number | null
    designOriginalName?: string | null
    designDescription?: string | null
    isDesignActive?: boolean
    colorVariation: ColorVariationCreateNestedOneWithoutImagesInput
  }

  export type ProductImageUncheckedCreateWithoutDelimitationsInput = {
    id?: number
    view: string
    url: string
    publicId: string
    naturalWidth?: number | null
    naturalHeight?: number | null
    designUrl?: string | null
    designPublicId?: string | null
    designFileName?: string | null
    designUploadDate?: Date | string | null
    designSize?: number | null
    designOriginalName?: string | null
    designDescription?: string | null
    isDesignActive?: boolean
    colorVariationId: number
  }

  export type ProductImageCreateOrConnectWithoutDelimitationsInput = {
    where: ProductImageWhereUniqueInput
    create: XOR<ProductImageCreateWithoutDelimitationsInput, ProductImageUncheckedCreateWithoutDelimitationsInput>
  }

  export type ProductImageUpsertWithoutDelimitationsInput = {
    update: XOR<ProductImageUpdateWithoutDelimitationsInput, ProductImageUncheckedUpdateWithoutDelimitationsInput>
    create: XOR<ProductImageCreateWithoutDelimitationsInput, ProductImageUncheckedCreateWithoutDelimitationsInput>
    where?: ProductImageWhereInput
  }

  export type ProductImageUpdateToOneWithWhereWithoutDelimitationsInput = {
    where?: ProductImageWhereInput
    data: XOR<ProductImageUpdateWithoutDelimitationsInput, ProductImageUncheckedUpdateWithoutDelimitationsInput>
  }

  export type ProductImageUpdateWithoutDelimitationsInput = {
    view?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    naturalWidth?: NullableIntFieldUpdateOperationsInput | number | null
    naturalHeight?: NullableIntFieldUpdateOperationsInput | number | null
    designUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designFileName?: NullableStringFieldUpdateOperationsInput | string | null
    designUploadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designSize?: NullableIntFieldUpdateOperationsInput | number | null
    designOriginalName?: NullableStringFieldUpdateOperationsInput | string | null
    designDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isDesignActive?: BoolFieldUpdateOperationsInput | boolean
    colorVariation?: ColorVariationUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ProductImageUncheckedUpdateWithoutDelimitationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    view?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    naturalWidth?: NullableIntFieldUpdateOperationsInput | number | null
    naturalHeight?: NullableIntFieldUpdateOperationsInput | number | null
    designUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designFileName?: NullableStringFieldUpdateOperationsInput | string | null
    designUploadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designSize?: NullableIntFieldUpdateOperationsInput | number | null
    designOriginalName?: NullableStringFieldUpdateOperationsInput | string | null
    designDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isDesignActive?: BoolFieldUpdateOperationsInput | boolean
    colorVariationId?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutOrdersInput = {
    firstName: string
    lastName: string
    email: string
    password: string
    role?: $Enums.Role
    status?: boolean
    photo_profil?: string | null
    login_attempts?: number
    locked_until?: Date | string | null
    last_login_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    must_change_password?: boolean
    vendeur_type?: $Enums.VendeurType | null
    phone?: string | null
    country?: string | null
    address?: string | null
    shop_name?: string | null
    profile_photo_url?: string | null
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    validatedOrders?: OrderCreateNestedManyWithoutValidatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    designs?: DesignCreateNestedManyWithoutVendorInput
    validatedDesigns?: DesignCreateNestedManyWithoutValidatorInput
    validatedProducts?: ProductCreateNestedManyWithoutValidatorInput
    validatedVendorProducts?: VendorProductCreateNestedManyWithoutValidatorInput
    vendorProducts?: VendorProductCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    password: string
    role?: $Enums.Role
    status?: boolean
    photo_profil?: string | null
    login_attempts?: number
    locked_until?: Date | string | null
    last_login_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    must_change_password?: boolean
    vendeur_type?: $Enums.VendeurType | null
    phone?: string | null
    country?: string | null
    address?: string | null
    shop_name?: string | null
    profile_photo_url?: string | null
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    validatedOrders?: OrderUncheckedCreateNestedManyWithoutValidatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    designs?: DesignUncheckedCreateNestedManyWithoutVendorInput
    validatedDesigns?: DesignUncheckedCreateNestedManyWithoutValidatorInput
    validatedProducts?: ProductUncheckedCreateNestedManyWithoutValidatorInput
    validatedVendorProducts?: VendorProductUncheckedCreateNestedManyWithoutValidatorInput
    vendorProducts?: VendorProductUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type UserCreateWithoutValidatedOrdersInput = {
    firstName: string
    lastName: string
    email: string
    password: string
    role?: $Enums.Role
    status?: boolean
    photo_profil?: string | null
    login_attempts?: number
    locked_until?: Date | string | null
    last_login_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    must_change_password?: boolean
    vendeur_type?: $Enums.VendeurType | null
    phone?: string | null
    country?: string | null
    address?: string | null
    shop_name?: string | null
    profile_photo_url?: string | null
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    designs?: DesignCreateNestedManyWithoutVendorInput
    validatedDesigns?: DesignCreateNestedManyWithoutValidatorInput
    validatedProducts?: ProductCreateNestedManyWithoutValidatorInput
    validatedVendorProducts?: VendorProductCreateNestedManyWithoutValidatorInput
    vendorProducts?: VendorProductCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutValidatedOrdersInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    password: string
    role?: $Enums.Role
    status?: boolean
    photo_profil?: string | null
    login_attempts?: number
    locked_until?: Date | string | null
    last_login_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    must_change_password?: boolean
    vendeur_type?: $Enums.VendeurType | null
    phone?: string | null
    country?: string | null
    address?: string | null
    shop_name?: string | null
    profile_photo_url?: string | null
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    designs?: DesignUncheckedCreateNestedManyWithoutVendorInput
    validatedDesigns?: DesignUncheckedCreateNestedManyWithoutValidatorInput
    validatedProducts?: ProductUncheckedCreateNestedManyWithoutValidatorInput
    validatedVendorProducts?: VendorProductUncheckedCreateNestedManyWithoutValidatorInput
    vendorProducts?: VendorProductUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutValidatedOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutValidatedOrdersInput, UserUncheckedCreateWithoutValidatedOrdersInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    quantity: number
    unitPrice: number
    size?: string | null
    color?: string | null
    product: ProductCreateNestedOneWithoutOrderItemsInput
    colorVariation?: ColorVariationCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    productId: number
    quantity: number
    unitPrice: number
    size?: string | null
    color?: string | null
    colorId?: number | null
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    validatedOrders?: OrderUpdateManyWithoutValidatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    designs?: DesignUpdateManyWithoutVendorNestedInput
    validatedDesigns?: DesignUpdateManyWithoutValidatorNestedInput
    validatedProducts?: ProductUpdateManyWithoutValidatorNestedInput
    validatedVendorProducts?: VendorProductUpdateManyWithoutValidatorNestedInput
    vendorProducts?: VendorProductUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    validatedOrders?: OrderUncheckedUpdateManyWithoutValidatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    designs?: DesignUncheckedUpdateManyWithoutVendorNestedInput
    validatedDesigns?: DesignUncheckedUpdateManyWithoutValidatorNestedInput
    validatedProducts?: ProductUncheckedUpdateManyWithoutValidatorNestedInput
    validatedVendorProducts?: VendorProductUncheckedUpdateManyWithoutValidatorNestedInput
    vendorProducts?: VendorProductUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserUpsertWithoutValidatedOrdersInput = {
    update: XOR<UserUpdateWithoutValidatedOrdersInput, UserUncheckedUpdateWithoutValidatedOrdersInput>
    create: XOR<UserCreateWithoutValidatedOrdersInput, UserUncheckedCreateWithoutValidatedOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutValidatedOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutValidatedOrdersInput, UserUncheckedUpdateWithoutValidatedOrdersInput>
  }

  export type UserUpdateWithoutValidatedOrdersInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    designs?: DesignUpdateManyWithoutVendorNestedInput
    validatedDesigns?: DesignUpdateManyWithoutValidatorNestedInput
    validatedProducts?: ProductUpdateManyWithoutValidatorNestedInput
    validatedVendorProducts?: VendorProductUpdateManyWithoutValidatorNestedInput
    vendorProducts?: VendorProductUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutValidatedOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    designs?: DesignUncheckedUpdateManyWithoutVendorNestedInput
    validatedDesigns?: DesignUncheckedUpdateManyWithoutValidatorNestedInput
    validatedProducts?: ProductUncheckedUpdateManyWithoutValidatorNestedInput
    validatedVendorProducts?: VendorProductUncheckedUpdateManyWithoutValidatorNestedInput
    vendorProducts?: VendorProductUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderCreateWithoutOrderItemsInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    totalAmount: number
    phoneNumber: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    shippingName?: string | null
    shippingStreet?: string | null
    shippingCity?: string | null
    shippingRegion?: string | null
    shippingPostalCode?: string | null
    shippingCountry?: string | null
    shippingAddressFull?: string | null
    user: UserCreateNestedOneWithoutOrdersInput
    validator?: UserCreateNestedOneWithoutValidatedOrdersInput
  }

  export type OrderUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    orderNumber: string
    userId: number
    status?: $Enums.OrderStatus
    totalAmount: number
    phoneNumber: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    validatedBy?: number | null
    shippingName?: string | null
    shippingStreet?: string | null
    shippingCity?: string | null
    shippingRegion?: string | null
    shippingPostalCode?: string | null
    shippingCountry?: string | null
    shippingAddressFull?: string | null
  }

  export type OrderCreateOrConnectWithoutOrderItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
  }

  export type ProductCreateWithoutOrderItemsInput = {
    name: string
    price: number
    stock: number
    status?: $Enums.PublicationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    hasCustomDesigns?: boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    validator?: UserCreateNestedOneWithoutValidatedProductsInput
    categories?: CategoryCreateNestedManyWithoutProductsInput
    sizes?: ProductSizeCreateNestedManyWithoutProductInput
    colorVariations?: ColorVariationCreateNestedManyWithoutProductInput
    vendorProducts?: VendorProductCreateNestedManyWithoutBaseProductInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    name: string
    price: number
    stock: number
    status?: $Enums.PublicationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isValidated?: boolean
    validatedAt?: Date | string | null
    validatedBy?: number | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    hasCustomDesigns?: boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    sizes?: ProductSizeUncheckedCreateNestedManyWithoutProductInput
    colorVariations?: ColorVariationUncheckedCreateNestedManyWithoutProductInput
    vendorProducts?: VendorProductUncheckedCreateNestedManyWithoutBaseProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type ColorVariationCreateWithoutOrderItemsInput = {
    name: string
    colorCode: string
    product: ProductCreateNestedOneWithoutColorVariationsInput
    images?: ProductImageCreateNestedManyWithoutColorVariationInput
    vendorProductImages?: VendorProductImageCreateNestedManyWithoutColorVariationInput
  }

  export type ColorVariationUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    name: string
    colorCode: string
    productId: number
    images?: ProductImageUncheckedCreateNestedManyWithoutColorVariationInput
    vendorProductImages?: VendorProductImageUncheckedCreateNestedManyWithoutColorVariationInput
  }

  export type ColorVariationCreateOrConnectWithoutOrderItemsInput = {
    where: ColorVariationWhereUniqueInput
    create: XOR<ColorVariationCreateWithoutOrderItemsInput, ColorVariationUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutOrderItemsInput = {
    update: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderUpdateWithoutOrderItemsInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStreet?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCity?: NullableStringFieldUpdateOperationsInput | string | null
    shippingRegion?: NullableStringFieldUpdateOperationsInput | string | null
    shippingPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddressFull?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    validator?: UserUpdateOneWithoutValidatedOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    shippingName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStreet?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCity?: NullableStringFieldUpdateOperationsInput | string | null
    shippingRegion?: NullableStringFieldUpdateOperationsInput | string | null
    shippingPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddressFull?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasCustomDesigns?: BoolFieldUpdateOperationsInput | boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    validator?: UserUpdateOneWithoutValidatedProductsNestedInput
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    sizes?: ProductSizeUpdateManyWithoutProductNestedInput
    colorVariations?: ColorVariationUpdateManyWithoutProductNestedInput
    vendorProducts?: VendorProductUpdateManyWithoutBaseProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasCustomDesigns?: BoolFieldUpdateOperationsInput | boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    sizes?: ProductSizeUncheckedUpdateManyWithoutProductNestedInput
    colorVariations?: ColorVariationUncheckedUpdateManyWithoutProductNestedInput
    vendorProducts?: VendorProductUncheckedUpdateManyWithoutBaseProductNestedInput
  }

  export type ColorVariationUpsertWithoutOrderItemsInput = {
    update: XOR<ColorVariationUpdateWithoutOrderItemsInput, ColorVariationUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ColorVariationCreateWithoutOrderItemsInput, ColorVariationUncheckedCreateWithoutOrderItemsInput>
    where?: ColorVariationWhereInput
  }

  export type ColorVariationUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ColorVariationWhereInput
    data: XOR<ColorVariationUpdateWithoutOrderItemsInput, ColorVariationUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ColorVariationUpdateWithoutOrderItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    colorCode?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutColorVariationsNestedInput
    images?: ProductImageUpdateManyWithoutColorVariationNestedInput
    vendorProductImages?: VendorProductImageUpdateManyWithoutColorVariationNestedInput
  }

  export type ColorVariationUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    colorCode?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    images?: ProductImageUncheckedUpdateManyWithoutColorVariationNestedInput
    vendorProductImages?: VendorProductImageUncheckedUpdateManyWithoutColorVariationNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    firstName: string
    lastName: string
    email: string
    password: string
    role?: $Enums.Role
    status?: boolean
    photo_profil?: string | null
    login_attempts?: number
    locked_until?: Date | string | null
    last_login_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    must_change_password?: boolean
    vendeur_type?: $Enums.VendeurType | null
    phone?: string | null
    country?: string | null
    address?: string | null
    shop_name?: string | null
    profile_photo_url?: string | null
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    validatedOrders?: OrderCreateNestedManyWithoutValidatorInput
    designs?: DesignCreateNestedManyWithoutVendorInput
    validatedDesigns?: DesignCreateNestedManyWithoutValidatorInput
    validatedProducts?: ProductCreateNestedManyWithoutValidatorInput
    validatedVendorProducts?: VendorProductCreateNestedManyWithoutValidatorInput
    vendorProducts?: VendorProductCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    password: string
    role?: $Enums.Role
    status?: boolean
    photo_profil?: string | null
    login_attempts?: number
    locked_until?: Date | string | null
    last_login_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    must_change_password?: boolean
    vendeur_type?: $Enums.VendeurType | null
    phone?: string | null
    country?: string | null
    address?: string | null
    shop_name?: string | null
    profile_photo_url?: string | null
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    validatedOrders?: OrderUncheckedCreateNestedManyWithoutValidatorInput
    designs?: DesignUncheckedCreateNestedManyWithoutVendorInput
    validatedDesigns?: DesignUncheckedCreateNestedManyWithoutValidatorInput
    validatedProducts?: ProductUncheckedCreateNestedManyWithoutValidatorInput
    validatedVendorProducts?: VendorProductUncheckedCreateNestedManyWithoutValidatorInput
    vendorProducts?: VendorProductUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    validatedOrders?: OrderUpdateManyWithoutValidatorNestedInput
    designs?: DesignUpdateManyWithoutVendorNestedInput
    validatedDesigns?: DesignUpdateManyWithoutValidatorNestedInput
    validatedProducts?: ProductUpdateManyWithoutValidatorNestedInput
    validatedVendorProducts?: VendorProductUpdateManyWithoutValidatorNestedInput
    vendorProducts?: VendorProductUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    validatedOrders?: OrderUncheckedUpdateManyWithoutValidatorNestedInput
    designs?: DesignUncheckedUpdateManyWithoutVendorNestedInput
    validatedDesigns?: DesignUncheckedUpdateManyWithoutValidatorNestedInput
    validatedProducts?: ProductUncheckedUpdateManyWithoutValidatorNestedInput
    validatedVendorProducts?: VendorProductUncheckedUpdateManyWithoutValidatorNestedInput
    vendorProducts?: VendorProductUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserCreateWithoutDesignsInput = {
    firstName: string
    lastName: string
    email: string
    password: string
    role?: $Enums.Role
    status?: boolean
    photo_profil?: string | null
    login_attempts?: number
    locked_until?: Date | string | null
    last_login_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    must_change_password?: boolean
    vendeur_type?: $Enums.VendeurType | null
    phone?: string | null
    country?: string | null
    address?: string | null
    shop_name?: string | null
    profile_photo_url?: string | null
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    validatedOrders?: OrderCreateNestedManyWithoutValidatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    validatedDesigns?: DesignCreateNestedManyWithoutValidatorInput
    validatedProducts?: ProductCreateNestedManyWithoutValidatorInput
    validatedVendorProducts?: VendorProductCreateNestedManyWithoutValidatorInput
    vendorProducts?: VendorProductCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutDesignsInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    password: string
    role?: $Enums.Role
    status?: boolean
    photo_profil?: string | null
    login_attempts?: number
    locked_until?: Date | string | null
    last_login_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    must_change_password?: boolean
    vendeur_type?: $Enums.VendeurType | null
    phone?: string | null
    country?: string | null
    address?: string | null
    shop_name?: string | null
    profile_photo_url?: string | null
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    validatedOrders?: OrderUncheckedCreateNestedManyWithoutValidatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    validatedDesigns?: DesignUncheckedCreateNestedManyWithoutValidatorInput
    validatedProducts?: ProductUncheckedCreateNestedManyWithoutValidatorInput
    validatedVendorProducts?: VendorProductUncheckedCreateNestedManyWithoutValidatorInput
    vendorProducts?: VendorProductUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutDesignsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDesignsInput, UserUncheckedCreateWithoutDesignsInput>
  }

  export type UserCreateWithoutValidatedDesignsInput = {
    firstName: string
    lastName: string
    email: string
    password: string
    role?: $Enums.Role
    status?: boolean
    photo_profil?: string | null
    login_attempts?: number
    locked_until?: Date | string | null
    last_login_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    must_change_password?: boolean
    vendeur_type?: $Enums.VendeurType | null
    phone?: string | null
    country?: string | null
    address?: string | null
    shop_name?: string | null
    profile_photo_url?: string | null
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    validatedOrders?: OrderCreateNestedManyWithoutValidatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    designs?: DesignCreateNestedManyWithoutVendorInput
    validatedProducts?: ProductCreateNestedManyWithoutValidatorInput
    validatedVendorProducts?: VendorProductCreateNestedManyWithoutValidatorInput
    vendorProducts?: VendorProductCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutValidatedDesignsInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    password: string
    role?: $Enums.Role
    status?: boolean
    photo_profil?: string | null
    login_attempts?: number
    locked_until?: Date | string | null
    last_login_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    must_change_password?: boolean
    vendeur_type?: $Enums.VendeurType | null
    phone?: string | null
    country?: string | null
    address?: string | null
    shop_name?: string | null
    profile_photo_url?: string | null
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    validatedOrders?: OrderUncheckedCreateNestedManyWithoutValidatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    designs?: DesignUncheckedCreateNestedManyWithoutVendorInput
    validatedProducts?: ProductUncheckedCreateNestedManyWithoutValidatorInput
    validatedVendorProducts?: VendorProductUncheckedCreateNestedManyWithoutValidatorInput
    vendorProducts?: VendorProductUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutValidatedDesignsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutValidatedDesignsInput, UserUncheckedCreateWithoutValidatedDesignsInput>
  }

  export type UserUpsertWithoutDesignsInput = {
    update: XOR<UserUpdateWithoutDesignsInput, UserUncheckedUpdateWithoutDesignsInput>
    create: XOR<UserCreateWithoutDesignsInput, UserUncheckedCreateWithoutDesignsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDesignsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDesignsInput, UserUncheckedUpdateWithoutDesignsInput>
  }

  export type UserUpdateWithoutDesignsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    validatedOrders?: OrderUpdateManyWithoutValidatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    validatedDesigns?: DesignUpdateManyWithoutValidatorNestedInput
    validatedProducts?: ProductUpdateManyWithoutValidatorNestedInput
    validatedVendorProducts?: VendorProductUpdateManyWithoutValidatorNestedInput
    vendorProducts?: VendorProductUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutDesignsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    validatedOrders?: OrderUncheckedUpdateManyWithoutValidatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    validatedDesigns?: DesignUncheckedUpdateManyWithoutValidatorNestedInput
    validatedProducts?: ProductUncheckedUpdateManyWithoutValidatorNestedInput
    validatedVendorProducts?: VendorProductUncheckedUpdateManyWithoutValidatorNestedInput
    vendorProducts?: VendorProductUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserUpsertWithoutValidatedDesignsInput = {
    update: XOR<UserUpdateWithoutValidatedDesignsInput, UserUncheckedUpdateWithoutValidatedDesignsInput>
    create: XOR<UserCreateWithoutValidatedDesignsInput, UserUncheckedCreateWithoutValidatedDesignsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutValidatedDesignsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutValidatedDesignsInput, UserUncheckedUpdateWithoutValidatedDesignsInput>
  }

  export type UserUpdateWithoutValidatedDesignsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    validatedOrders?: OrderUpdateManyWithoutValidatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    designs?: DesignUpdateManyWithoutVendorNestedInput
    validatedProducts?: ProductUpdateManyWithoutValidatorNestedInput
    validatedVendorProducts?: VendorProductUpdateManyWithoutValidatorNestedInput
    vendorProducts?: VendorProductUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutValidatedDesignsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    validatedOrders?: OrderUncheckedUpdateManyWithoutValidatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    designs?: DesignUncheckedUpdateManyWithoutVendorNestedInput
    validatedProducts?: ProductUncheckedUpdateManyWithoutValidatorNestedInput
    validatedVendorProducts?: VendorProductUncheckedUpdateManyWithoutValidatorNestedInput
    vendorProducts?: VendorProductUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserCreateWithoutValidatedVendorProductsInput = {
    firstName: string
    lastName: string
    email: string
    password: string
    role?: $Enums.Role
    status?: boolean
    photo_profil?: string | null
    login_attempts?: number
    locked_until?: Date | string | null
    last_login_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    must_change_password?: boolean
    vendeur_type?: $Enums.VendeurType | null
    phone?: string | null
    country?: string | null
    address?: string | null
    shop_name?: string | null
    profile_photo_url?: string | null
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    validatedOrders?: OrderCreateNestedManyWithoutValidatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    designs?: DesignCreateNestedManyWithoutVendorInput
    validatedDesigns?: DesignCreateNestedManyWithoutValidatorInput
    validatedProducts?: ProductCreateNestedManyWithoutValidatorInput
    vendorProducts?: VendorProductCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutValidatedVendorProductsInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    password: string
    role?: $Enums.Role
    status?: boolean
    photo_profil?: string | null
    login_attempts?: number
    locked_until?: Date | string | null
    last_login_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    must_change_password?: boolean
    vendeur_type?: $Enums.VendeurType | null
    phone?: string | null
    country?: string | null
    address?: string | null
    shop_name?: string | null
    profile_photo_url?: string | null
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    validatedOrders?: OrderUncheckedCreateNestedManyWithoutValidatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    designs?: DesignUncheckedCreateNestedManyWithoutVendorInput
    validatedDesigns?: DesignUncheckedCreateNestedManyWithoutValidatorInput
    validatedProducts?: ProductUncheckedCreateNestedManyWithoutValidatorInput
    vendorProducts?: VendorProductUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutValidatedVendorProductsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutValidatedVendorProductsInput, UserUncheckedCreateWithoutValidatedVendorProductsInput>
  }

  export type UserCreateWithoutVendorProductsInput = {
    firstName: string
    lastName: string
    email: string
    password: string
    role?: $Enums.Role
    status?: boolean
    photo_profil?: string | null
    login_attempts?: number
    locked_until?: Date | string | null
    last_login_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    must_change_password?: boolean
    vendeur_type?: $Enums.VendeurType | null
    phone?: string | null
    country?: string | null
    address?: string | null
    shop_name?: string | null
    profile_photo_url?: string | null
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    validatedOrders?: OrderCreateNestedManyWithoutValidatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    designs?: DesignCreateNestedManyWithoutVendorInput
    validatedDesigns?: DesignCreateNestedManyWithoutValidatorInput
    validatedProducts?: ProductCreateNestedManyWithoutValidatorInput
    validatedVendorProducts?: VendorProductCreateNestedManyWithoutValidatorInput
  }

  export type UserUncheckedCreateWithoutVendorProductsInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    password: string
    role?: $Enums.Role
    status?: boolean
    photo_profil?: string | null
    login_attempts?: number
    locked_until?: Date | string | null
    last_login_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    must_change_password?: boolean
    vendeur_type?: $Enums.VendeurType | null
    phone?: string | null
    country?: string | null
    address?: string | null
    shop_name?: string | null
    profile_photo_url?: string | null
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    validatedOrders?: OrderUncheckedCreateNestedManyWithoutValidatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    designs?: DesignUncheckedCreateNestedManyWithoutVendorInput
    validatedDesigns?: DesignUncheckedCreateNestedManyWithoutValidatorInput
    validatedProducts?: ProductUncheckedCreateNestedManyWithoutValidatorInput
    validatedVendorProducts?: VendorProductUncheckedCreateNestedManyWithoutValidatorInput
  }

  export type UserCreateOrConnectWithoutVendorProductsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVendorProductsInput, UserUncheckedCreateWithoutVendorProductsInput>
  }

  export type ProductCreateWithoutVendorProductsInput = {
    name: string
    price: number
    stock: number
    status?: $Enums.PublicationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    hasCustomDesigns?: boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    validator?: UserCreateNestedOneWithoutValidatedProductsInput
    categories?: CategoryCreateNestedManyWithoutProductsInput
    sizes?: ProductSizeCreateNestedManyWithoutProductInput
    colorVariations?: ColorVariationCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutVendorProductsInput = {
    id?: number
    name: string
    price: number
    stock: number
    status?: $Enums.PublicationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isValidated?: boolean
    validatedAt?: Date | string | null
    validatedBy?: number | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    hasCustomDesigns?: boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    sizes?: ProductSizeUncheckedCreateNestedManyWithoutProductInput
    colorVariations?: ColorVariationUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutVendorProductsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVendorProductsInput, ProductUncheckedCreateWithoutVendorProductsInput>
  }

  export type VendorProductImageCreateWithoutVendorProductInput = {
    colorName?: string | null
    colorCode?: string | null
    imageType?: string
    cloudinaryUrl: string
    cloudinaryPublicId: string
    originalImageKey?: string | null
    width?: number | null
    height?: number | null
    fileSize?: number | null
    format?: string | null
    createdAt?: Date | string
    uploadedAt?: Date | string
    colorVariation?: ColorVariationCreateNestedOneWithoutVendorProductImagesInput
  }

  export type VendorProductImageUncheckedCreateWithoutVendorProductInput = {
    id?: number
    colorId?: number | null
    colorName?: string | null
    colorCode?: string | null
    imageType?: string
    cloudinaryUrl: string
    cloudinaryPublicId: string
    originalImageKey?: string | null
    width?: number | null
    height?: number | null
    fileSize?: number | null
    format?: string | null
    createdAt?: Date | string
    uploadedAt?: Date | string
  }

  export type VendorProductImageCreateOrConnectWithoutVendorProductInput = {
    where: VendorProductImageWhereUniqueInput
    create: XOR<VendorProductImageCreateWithoutVendorProductInput, VendorProductImageUncheckedCreateWithoutVendorProductInput>
  }

  export type VendorProductImageCreateManyVendorProductInputEnvelope = {
    data: VendorProductImageCreateManyVendorProductInput | VendorProductImageCreateManyVendorProductInput[]
    skipDuplicates?: boolean
  }

  export type DesignTransformationCreateWithoutVendorProductInput = {
    delimitationIndex: number
    xOffset?: number
    yOffset?: number
    scaleFactor?: number
    positioning?: $Enums.DesignPositioning
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignTransformationUncheckedCreateWithoutVendorProductInput = {
    id?: number
    delimitationIndex: number
    xOffset?: number
    yOffset?: number
    scaleFactor?: number
    positioning?: $Enums.DesignPositioning
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignTransformationCreateOrConnectWithoutVendorProductInput = {
    where: DesignTransformationWhereUniqueInput
    create: XOR<DesignTransformationCreateWithoutVendorProductInput, DesignTransformationUncheckedCreateWithoutVendorProductInput>
  }

  export type DesignTransformationCreateManyVendorProductInputEnvelope = {
    data: DesignTransformationCreateManyVendorProductInput | DesignTransformationCreateManyVendorProductInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutValidatedVendorProductsInput = {
    update: XOR<UserUpdateWithoutValidatedVendorProductsInput, UserUncheckedUpdateWithoutValidatedVendorProductsInput>
    create: XOR<UserCreateWithoutValidatedVendorProductsInput, UserUncheckedCreateWithoutValidatedVendorProductsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutValidatedVendorProductsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutValidatedVendorProductsInput, UserUncheckedUpdateWithoutValidatedVendorProductsInput>
  }

  export type UserUpdateWithoutValidatedVendorProductsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    validatedOrders?: OrderUpdateManyWithoutValidatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    designs?: DesignUpdateManyWithoutVendorNestedInput
    validatedDesigns?: DesignUpdateManyWithoutValidatorNestedInput
    validatedProducts?: ProductUpdateManyWithoutValidatorNestedInput
    vendorProducts?: VendorProductUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutValidatedVendorProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    validatedOrders?: OrderUncheckedUpdateManyWithoutValidatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    designs?: DesignUncheckedUpdateManyWithoutVendorNestedInput
    validatedDesigns?: DesignUncheckedUpdateManyWithoutValidatorNestedInput
    validatedProducts?: ProductUncheckedUpdateManyWithoutValidatorNestedInput
    vendorProducts?: VendorProductUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserUpsertWithoutVendorProductsInput = {
    update: XOR<UserUpdateWithoutVendorProductsInput, UserUncheckedUpdateWithoutVendorProductsInput>
    create: XOR<UserCreateWithoutVendorProductsInput, UserUncheckedCreateWithoutVendorProductsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVendorProductsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVendorProductsInput, UserUncheckedUpdateWithoutVendorProductsInput>
  }

  export type UserUpdateWithoutVendorProductsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    validatedOrders?: OrderUpdateManyWithoutValidatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    designs?: DesignUpdateManyWithoutVendorNestedInput
    validatedDesigns?: DesignUpdateManyWithoutValidatorNestedInput
    validatedProducts?: ProductUpdateManyWithoutValidatorNestedInput
    validatedVendorProducts?: VendorProductUpdateManyWithoutValidatorNestedInput
  }

  export type UserUncheckedUpdateWithoutVendorProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: BoolFieldUpdateOperationsInput | boolean
    photo_profil?: NullableStringFieldUpdateOperationsInput | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    vendeur_type?: NullableEnumVendeurTypeFieldUpdateOperationsInput | $Enums.VendeurType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    validatedOrders?: OrderUncheckedUpdateManyWithoutValidatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    designs?: DesignUncheckedUpdateManyWithoutVendorNestedInput
    validatedDesigns?: DesignUncheckedUpdateManyWithoutValidatorNestedInput
    validatedProducts?: ProductUncheckedUpdateManyWithoutValidatorNestedInput
    validatedVendorProducts?: VendorProductUncheckedUpdateManyWithoutValidatorNestedInput
  }

  export type ProductUpsertWithoutVendorProductsInput = {
    update: XOR<ProductUpdateWithoutVendorProductsInput, ProductUncheckedUpdateWithoutVendorProductsInput>
    create: XOR<ProductCreateWithoutVendorProductsInput, ProductUncheckedCreateWithoutVendorProductsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutVendorProductsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutVendorProductsInput, ProductUncheckedUpdateWithoutVendorProductsInput>
  }

  export type ProductUpdateWithoutVendorProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasCustomDesigns?: BoolFieldUpdateOperationsInput | boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    validator?: UserUpdateOneWithoutValidatedProductsNestedInput
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    sizes?: ProductSizeUpdateManyWithoutProductNestedInput
    colorVariations?: ColorVariationUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutVendorProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasCustomDesigns?: BoolFieldUpdateOperationsInput | boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    sizes?: ProductSizeUncheckedUpdateManyWithoutProductNestedInput
    colorVariations?: ColorVariationUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type VendorProductImageUpsertWithWhereUniqueWithoutVendorProductInput = {
    where: VendorProductImageWhereUniqueInput
    update: XOR<VendorProductImageUpdateWithoutVendorProductInput, VendorProductImageUncheckedUpdateWithoutVendorProductInput>
    create: XOR<VendorProductImageCreateWithoutVendorProductInput, VendorProductImageUncheckedCreateWithoutVendorProductInput>
  }

  export type VendorProductImageUpdateWithWhereUniqueWithoutVendorProductInput = {
    where: VendorProductImageWhereUniqueInput
    data: XOR<VendorProductImageUpdateWithoutVendorProductInput, VendorProductImageUncheckedUpdateWithoutVendorProductInput>
  }

  export type VendorProductImageUpdateManyWithWhereWithoutVendorProductInput = {
    where: VendorProductImageScalarWhereInput
    data: XOR<VendorProductImageUpdateManyMutationInput, VendorProductImageUncheckedUpdateManyWithoutVendorProductInput>
  }

  export type DesignTransformationUpsertWithWhereUniqueWithoutVendorProductInput = {
    where: DesignTransformationWhereUniqueInput
    update: XOR<DesignTransformationUpdateWithoutVendorProductInput, DesignTransformationUncheckedUpdateWithoutVendorProductInput>
    create: XOR<DesignTransformationCreateWithoutVendorProductInput, DesignTransformationUncheckedCreateWithoutVendorProductInput>
  }

  export type DesignTransformationUpdateWithWhereUniqueWithoutVendorProductInput = {
    where: DesignTransformationWhereUniqueInput
    data: XOR<DesignTransformationUpdateWithoutVendorProductInput, DesignTransformationUncheckedUpdateWithoutVendorProductInput>
  }

  export type DesignTransformationUpdateManyWithWhereWithoutVendorProductInput = {
    where: DesignTransformationScalarWhereInput
    data: XOR<DesignTransformationUpdateManyMutationInput, DesignTransformationUncheckedUpdateManyWithoutVendorProductInput>
  }

  export type DesignTransformationScalarWhereInput = {
    AND?: DesignTransformationScalarWhereInput | DesignTransformationScalarWhereInput[]
    OR?: DesignTransformationScalarWhereInput[]
    NOT?: DesignTransformationScalarWhereInput | DesignTransformationScalarWhereInput[]
    id?: IntFilter<"DesignTransformation"> | number
    vendorProductId?: IntFilter<"DesignTransformation"> | number
    delimitationIndex?: IntFilter<"DesignTransformation"> | number
    xOffset?: FloatFilter<"DesignTransformation"> | number
    yOffset?: FloatFilter<"DesignTransformation"> | number
    scaleFactor?: FloatFilter<"DesignTransformation"> | number
    positioning?: EnumDesignPositioningFilter<"DesignTransformation"> | $Enums.DesignPositioning
    createdAt?: DateTimeFilter<"DesignTransformation"> | Date | string
    updatedAt?: DateTimeFilter<"DesignTransformation"> | Date | string
  }

  export type VendorProductCreateWithoutImagesInput = {
    name: string
    description?: string | null
    price: number
    stock?: number
    status?: $Enums.VendorProductStatus
    adminProductName?: string | null
    adminProductDescription?: string | null
    adminProductPrice?: number | null
    designBase64?: string | null
    designCloudinaryUrl?: string | null
    designCloudinaryPublicId?: string | null
    designPositioning?: string | null
    designScale?: number | null
    designApplicationMode?: string | null
    sizes: JsonNullValueInput | InputJsonValue
    colors: JsonNullValueInput | InputJsonValue
    vendorName?: string | null
    vendorDescription?: string | null
    vendorStock?: number
    basePriceAdmin?: number
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    validator?: UserCreateNestedOneWithoutValidatedVendorProductsInput
    vendor: UserCreateNestedOneWithoutVendorProductsInput
    baseProduct: ProductCreateNestedOneWithoutVendorProductsInput
    transformations?: DesignTransformationCreateNestedManyWithoutVendorProductInput
  }

  export type VendorProductUncheckedCreateWithoutImagesInput = {
    id?: number
    baseProductId: number
    vendorId: number
    name: string
    description?: string | null
    price: number
    stock?: number
    status?: $Enums.VendorProductStatus
    adminProductName?: string | null
    adminProductDescription?: string | null
    adminProductPrice?: number | null
    designBase64?: string | null
    designCloudinaryUrl?: string | null
    designCloudinaryPublicId?: string | null
    designPositioning?: string | null
    designScale?: number | null
    designApplicationMode?: string | null
    sizes: JsonNullValueInput | InputJsonValue
    colors: JsonNullValueInput | InputJsonValue
    vendorName?: string | null
    vendorDescription?: string | null
    vendorStock?: number
    basePriceAdmin?: number
    isValidated?: boolean
    validatedAt?: Date | string | null
    validatedBy?: number | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transformations?: DesignTransformationUncheckedCreateNestedManyWithoutVendorProductInput
  }

  export type VendorProductCreateOrConnectWithoutImagesInput = {
    where: VendorProductWhereUniqueInput
    create: XOR<VendorProductCreateWithoutImagesInput, VendorProductUncheckedCreateWithoutImagesInput>
  }

  export type ColorVariationCreateWithoutVendorProductImagesInput = {
    name: string
    colorCode: string
    product: ProductCreateNestedOneWithoutColorVariationsInput
    images?: ProductImageCreateNestedManyWithoutColorVariationInput
    orderItems?: OrderItemCreateNestedManyWithoutColorVariationInput
  }

  export type ColorVariationUncheckedCreateWithoutVendorProductImagesInput = {
    id?: number
    name: string
    colorCode: string
    productId: number
    images?: ProductImageUncheckedCreateNestedManyWithoutColorVariationInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutColorVariationInput
  }

  export type ColorVariationCreateOrConnectWithoutVendorProductImagesInput = {
    where: ColorVariationWhereUniqueInput
    create: XOR<ColorVariationCreateWithoutVendorProductImagesInput, ColorVariationUncheckedCreateWithoutVendorProductImagesInput>
  }

  export type VendorProductUpsertWithoutImagesInput = {
    update: XOR<VendorProductUpdateWithoutImagesInput, VendorProductUncheckedUpdateWithoutImagesInput>
    create: XOR<VendorProductCreateWithoutImagesInput, VendorProductUncheckedCreateWithoutImagesInput>
    where?: VendorProductWhereInput
  }

  export type VendorProductUpdateToOneWithWhereWithoutImagesInput = {
    where?: VendorProductWhereInput
    data: XOR<VendorProductUpdateWithoutImagesInput, VendorProductUncheckedUpdateWithoutImagesInput>
  }

  export type VendorProductUpdateWithoutImagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumVendorProductStatusFieldUpdateOperationsInput | $Enums.VendorProductStatus
    adminProductName?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductPrice?: NullableIntFieldUpdateOperationsInput | number | null
    designBase64?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designPositioning?: NullableStringFieldUpdateOperationsInput | string | null
    designScale?: NullableFloatFieldUpdateOperationsInput | number | null
    designApplicationMode?: NullableStringFieldUpdateOperationsInput | string | null
    sizes?: JsonNullValueInput | InputJsonValue
    colors?: JsonNullValueInput | InputJsonValue
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    vendorStock?: IntFieldUpdateOperationsInput | number
    basePriceAdmin?: FloatFieldUpdateOperationsInput | number
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validator?: UserUpdateOneWithoutValidatedVendorProductsNestedInput
    vendor?: UserUpdateOneRequiredWithoutVendorProductsNestedInput
    baseProduct?: ProductUpdateOneRequiredWithoutVendorProductsNestedInput
    transformations?: DesignTransformationUpdateManyWithoutVendorProductNestedInput
  }

  export type VendorProductUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    baseProductId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumVendorProductStatusFieldUpdateOperationsInput | $Enums.VendorProductStatus
    adminProductName?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductPrice?: NullableIntFieldUpdateOperationsInput | number | null
    designBase64?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designPositioning?: NullableStringFieldUpdateOperationsInput | string | null
    designScale?: NullableFloatFieldUpdateOperationsInput | number | null
    designApplicationMode?: NullableStringFieldUpdateOperationsInput | string | null
    sizes?: JsonNullValueInput | InputJsonValue
    colors?: JsonNullValueInput | InputJsonValue
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    vendorStock?: IntFieldUpdateOperationsInput | number
    basePriceAdmin?: FloatFieldUpdateOperationsInput | number
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transformations?: DesignTransformationUncheckedUpdateManyWithoutVendorProductNestedInput
  }

  export type ColorVariationUpsertWithoutVendorProductImagesInput = {
    update: XOR<ColorVariationUpdateWithoutVendorProductImagesInput, ColorVariationUncheckedUpdateWithoutVendorProductImagesInput>
    create: XOR<ColorVariationCreateWithoutVendorProductImagesInput, ColorVariationUncheckedCreateWithoutVendorProductImagesInput>
    where?: ColorVariationWhereInput
  }

  export type ColorVariationUpdateToOneWithWhereWithoutVendorProductImagesInput = {
    where?: ColorVariationWhereInput
    data: XOR<ColorVariationUpdateWithoutVendorProductImagesInput, ColorVariationUncheckedUpdateWithoutVendorProductImagesInput>
  }

  export type ColorVariationUpdateWithoutVendorProductImagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    colorCode?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutColorVariationsNestedInput
    images?: ProductImageUpdateManyWithoutColorVariationNestedInput
    orderItems?: OrderItemUpdateManyWithoutColorVariationNestedInput
  }

  export type ColorVariationUncheckedUpdateWithoutVendorProductImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    colorCode?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    images?: ProductImageUncheckedUpdateManyWithoutColorVariationNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutColorVariationNestedInput
  }

  export type VendorProductCreateWithoutTransformationsInput = {
    name: string
    description?: string | null
    price: number
    stock?: number
    status?: $Enums.VendorProductStatus
    adminProductName?: string | null
    adminProductDescription?: string | null
    adminProductPrice?: number | null
    designBase64?: string | null
    designCloudinaryUrl?: string | null
    designCloudinaryPublicId?: string | null
    designPositioning?: string | null
    designScale?: number | null
    designApplicationMode?: string | null
    sizes: JsonNullValueInput | InputJsonValue
    colors: JsonNullValueInput | InputJsonValue
    vendorName?: string | null
    vendorDescription?: string | null
    vendorStock?: number
    basePriceAdmin?: number
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    validator?: UserCreateNestedOneWithoutValidatedVendorProductsInput
    vendor: UserCreateNestedOneWithoutVendorProductsInput
    baseProduct: ProductCreateNestedOneWithoutVendorProductsInput
    images?: VendorProductImageCreateNestedManyWithoutVendorProductInput
  }

  export type VendorProductUncheckedCreateWithoutTransformationsInput = {
    id?: number
    baseProductId: number
    vendorId: number
    name: string
    description?: string | null
    price: number
    stock?: number
    status?: $Enums.VendorProductStatus
    adminProductName?: string | null
    adminProductDescription?: string | null
    adminProductPrice?: number | null
    designBase64?: string | null
    designCloudinaryUrl?: string | null
    designCloudinaryPublicId?: string | null
    designPositioning?: string | null
    designScale?: number | null
    designApplicationMode?: string | null
    sizes: JsonNullValueInput | InputJsonValue
    colors: JsonNullValueInput | InputJsonValue
    vendorName?: string | null
    vendorDescription?: string | null
    vendorStock?: number
    basePriceAdmin?: number
    isValidated?: boolean
    validatedAt?: Date | string | null
    validatedBy?: number | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VendorProductImageUncheckedCreateNestedManyWithoutVendorProductInput
  }

  export type VendorProductCreateOrConnectWithoutTransformationsInput = {
    where: VendorProductWhereUniqueInput
    create: XOR<VendorProductCreateWithoutTransformationsInput, VendorProductUncheckedCreateWithoutTransformationsInput>
  }

  export type VendorProductUpsertWithoutTransformationsInput = {
    update: XOR<VendorProductUpdateWithoutTransformationsInput, VendorProductUncheckedUpdateWithoutTransformationsInput>
    create: XOR<VendorProductCreateWithoutTransformationsInput, VendorProductUncheckedCreateWithoutTransformationsInput>
    where?: VendorProductWhereInput
  }

  export type VendorProductUpdateToOneWithWhereWithoutTransformationsInput = {
    where?: VendorProductWhereInput
    data: XOR<VendorProductUpdateWithoutTransformationsInput, VendorProductUncheckedUpdateWithoutTransformationsInput>
  }

  export type VendorProductUpdateWithoutTransformationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumVendorProductStatusFieldUpdateOperationsInput | $Enums.VendorProductStatus
    adminProductName?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductPrice?: NullableIntFieldUpdateOperationsInput | number | null
    designBase64?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designPositioning?: NullableStringFieldUpdateOperationsInput | string | null
    designScale?: NullableFloatFieldUpdateOperationsInput | number | null
    designApplicationMode?: NullableStringFieldUpdateOperationsInput | string | null
    sizes?: JsonNullValueInput | InputJsonValue
    colors?: JsonNullValueInput | InputJsonValue
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    vendorStock?: IntFieldUpdateOperationsInput | number
    basePriceAdmin?: FloatFieldUpdateOperationsInput | number
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validator?: UserUpdateOneWithoutValidatedVendorProductsNestedInput
    vendor?: UserUpdateOneRequiredWithoutVendorProductsNestedInput
    baseProduct?: ProductUpdateOneRequiredWithoutVendorProductsNestedInput
    images?: VendorProductImageUpdateManyWithoutVendorProductNestedInput
  }

  export type VendorProductUncheckedUpdateWithoutTransformationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    baseProductId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumVendorProductStatusFieldUpdateOperationsInput | $Enums.VendorProductStatus
    adminProductName?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductPrice?: NullableIntFieldUpdateOperationsInput | number | null
    designBase64?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designPositioning?: NullableStringFieldUpdateOperationsInput | string | null
    designScale?: NullableFloatFieldUpdateOperationsInput | number | null
    designApplicationMode?: NullableStringFieldUpdateOperationsInput | string | null
    sizes?: JsonNullValueInput | InputJsonValue
    colors?: JsonNullValueInput | InputJsonValue
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    vendorStock?: IntFieldUpdateOperationsInput | number
    basePriceAdmin?: FloatFieldUpdateOperationsInput | number
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VendorProductImageUncheckedUpdateManyWithoutVendorProductNestedInput
  }

  export type PasswordResetCreateManyUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    usedAt?: Date | string | null
  }

  export type OrderCreateManyUserInput = {
    id?: number
    orderNumber: string
    status?: $Enums.OrderStatus
    totalAmount: number
    phoneNumber: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    validatedBy?: number | null
    shippingName?: string | null
    shippingStreet?: string | null
    shippingCity?: string | null
    shippingRegion?: string | null
    shippingPostalCode?: string | null
    shippingCountry?: string | null
    shippingAddressFull?: string | null
  }

  export type OrderCreateManyValidatorInput = {
    id?: number
    orderNumber: string
    userId: number
    status?: $Enums.OrderStatus
    totalAmount: number
    phoneNumber: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    shippingName?: string | null
    shippingStreet?: string | null
    shippingCity?: string | null
    shippingRegion?: string | null
    shippingPostalCode?: string | null
    shippingCountry?: string | null
    shippingAddressFull?: string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type DesignCreateManyVendorInput = {
    id?: number
    name: string
    description?: string | null
    price: number
    category: $Enums.DesignCategory
    imageUrl: string
    thumbnailUrl?: string | null
    cloudinaryPublicId: string
    thumbnailPublicId?: string | null
    fileSize: number
    originalFileName: string
    dimensions: JsonNullValueInput | InputJsonValue
    format: string
    tags?: DesignCreatetagsInput | string[]
    isDraft?: boolean
    isPublished?: boolean
    isPending?: boolean
    isValidated?: boolean
    validatedAt?: Date | string | null
    validatedBy?: number | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    views?: number
    likes?: number
    earnings?: number
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type DesignCreateManyValidatorInput = {
    id?: number
    vendorId: number
    name: string
    description?: string | null
    price: number
    category: $Enums.DesignCategory
    imageUrl: string
    thumbnailUrl?: string | null
    cloudinaryPublicId: string
    thumbnailPublicId?: string | null
    fileSize: number
    originalFileName: string
    dimensions: JsonNullValueInput | InputJsonValue
    format: string
    tags?: DesignCreatetagsInput | string[]
    isDraft?: boolean
    isPublished?: boolean
    isPending?: boolean
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    views?: number
    likes?: number
    earnings?: number
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type ProductCreateManyValidatorInput = {
    id?: number
    name: string
    price: number
    stock: number
    status?: $Enums.PublicationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    hasCustomDesigns?: boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VendorProductCreateManyValidatorInput = {
    id?: number
    baseProductId: number
    vendorId: number
    name: string
    description?: string | null
    price: number
    stock?: number
    status?: $Enums.VendorProductStatus
    adminProductName?: string | null
    adminProductDescription?: string | null
    adminProductPrice?: number | null
    designBase64?: string | null
    designCloudinaryUrl?: string | null
    designCloudinaryPublicId?: string | null
    designPositioning?: string | null
    designScale?: number | null
    designApplicationMode?: string | null
    sizes: JsonNullValueInput | InputJsonValue
    colors: JsonNullValueInput | InputJsonValue
    vendorName?: string | null
    vendorDescription?: string | null
    vendorStock?: number
    basePriceAdmin?: number
    isValidated?: boolean
    validatedAt?: Date | string | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorProductCreateManyVendorInput = {
    id?: number
    baseProductId: number
    name: string
    description?: string | null
    price: number
    stock?: number
    status?: $Enums.VendorProductStatus
    adminProductName?: string | null
    adminProductDescription?: string | null
    adminProductPrice?: number | null
    designBase64?: string | null
    designCloudinaryUrl?: string | null
    designCloudinaryPublicId?: string | null
    designPositioning?: string | null
    designScale?: number | null
    designApplicationMode?: string | null
    sizes: JsonNullValueInput | InputJsonValue
    colors: JsonNullValueInput | InputJsonValue
    vendorName?: string | null
    vendorDescription?: string | null
    vendorStock?: number
    basePriceAdmin?: number
    isValidated?: boolean
    validatedAt?: Date | string | null
    validatedBy?: number | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordResetUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordResetUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordResetUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUpdateWithoutUserInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStreet?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCity?: NullableStringFieldUpdateOperationsInput | string | null
    shippingRegion?: NullableStringFieldUpdateOperationsInput | string | null
    shippingPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddressFull?: NullableStringFieldUpdateOperationsInput | string | null
    validator?: UserUpdateOneWithoutValidatedOrdersNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    shippingName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStreet?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCity?: NullableStringFieldUpdateOperationsInput | string | null
    shippingRegion?: NullableStringFieldUpdateOperationsInput | string | null
    shippingPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddressFull?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    shippingName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStreet?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCity?: NullableStringFieldUpdateOperationsInput | string | null
    shippingRegion?: NullableStringFieldUpdateOperationsInput | string | null
    shippingPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddressFull?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpdateWithoutValidatorInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStreet?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCity?: NullableStringFieldUpdateOperationsInput | string | null
    shippingRegion?: NullableStringFieldUpdateOperationsInput | string | null
    shippingPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddressFull?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutValidatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStreet?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCity?: NullableStringFieldUpdateOperationsInput | string | null
    shippingRegion?: NullableStringFieldUpdateOperationsInput | string | null
    shippingPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddressFull?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutValidatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStreet?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCity?: NullableStringFieldUpdateOperationsInput | string | null
    shippingRegion?: NullableStringFieldUpdateOperationsInput | string | null
    shippingPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddressFull?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DesignUpdateWithoutVendorInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    category?: EnumDesignCategoryFieldUpdateOperationsInput | $Enums.DesignCategory
    imageUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cloudinaryPublicId?: StringFieldUpdateOperationsInput | string
    thumbnailPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: IntFieldUpdateOperationsInput | number
    originalFileName?: StringFieldUpdateOperationsInput | string
    dimensions?: JsonNullValueInput | InputJsonValue
    format?: StringFieldUpdateOperationsInput | string
    tags?: DesignUpdatetagsInput | string[]
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPending?: BoolFieldUpdateOperationsInput | boolean
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validator?: UserUpdateOneWithoutValidatedDesignsNestedInput
  }

  export type DesignUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    category?: EnumDesignCategoryFieldUpdateOperationsInput | $Enums.DesignCategory
    imageUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cloudinaryPublicId?: StringFieldUpdateOperationsInput | string
    thumbnailPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: IntFieldUpdateOperationsInput | number
    originalFileName?: StringFieldUpdateOperationsInput | string
    dimensions?: JsonNullValueInput | InputJsonValue
    format?: StringFieldUpdateOperationsInput | string
    tags?: DesignUpdatetagsInput | string[]
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPending?: BoolFieldUpdateOperationsInput | boolean
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DesignUncheckedUpdateManyWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    category?: EnumDesignCategoryFieldUpdateOperationsInput | $Enums.DesignCategory
    imageUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cloudinaryPublicId?: StringFieldUpdateOperationsInput | string
    thumbnailPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: IntFieldUpdateOperationsInput | number
    originalFileName?: StringFieldUpdateOperationsInput | string
    dimensions?: JsonNullValueInput | InputJsonValue
    format?: StringFieldUpdateOperationsInput | string
    tags?: DesignUpdatetagsInput | string[]
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPending?: BoolFieldUpdateOperationsInput | boolean
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DesignUpdateWithoutValidatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    category?: EnumDesignCategoryFieldUpdateOperationsInput | $Enums.DesignCategory
    imageUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cloudinaryPublicId?: StringFieldUpdateOperationsInput | string
    thumbnailPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: IntFieldUpdateOperationsInput | number
    originalFileName?: StringFieldUpdateOperationsInput | string
    dimensions?: JsonNullValueInput | InputJsonValue
    format?: StringFieldUpdateOperationsInput | string
    tags?: DesignUpdatetagsInput | string[]
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPending?: BoolFieldUpdateOperationsInput | boolean
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendor?: UserUpdateOneRequiredWithoutDesignsNestedInput
  }

  export type DesignUncheckedUpdateWithoutValidatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    category?: EnumDesignCategoryFieldUpdateOperationsInput | $Enums.DesignCategory
    imageUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cloudinaryPublicId?: StringFieldUpdateOperationsInput | string
    thumbnailPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: IntFieldUpdateOperationsInput | number
    originalFileName?: StringFieldUpdateOperationsInput | string
    dimensions?: JsonNullValueInput | InputJsonValue
    format?: StringFieldUpdateOperationsInput | string
    tags?: DesignUpdatetagsInput | string[]
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPending?: BoolFieldUpdateOperationsInput | boolean
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DesignUncheckedUpdateManyWithoutValidatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    category?: EnumDesignCategoryFieldUpdateOperationsInput | $Enums.DesignCategory
    imageUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cloudinaryPublicId?: StringFieldUpdateOperationsInput | string
    thumbnailPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: IntFieldUpdateOperationsInput | number
    originalFileName?: StringFieldUpdateOperationsInput | string
    dimensions?: JsonNullValueInput | InputJsonValue
    format?: StringFieldUpdateOperationsInput | string
    tags?: DesignUpdatetagsInput | string[]
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPending?: BoolFieldUpdateOperationsInput | boolean
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductUpdateWithoutValidatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasCustomDesigns?: BoolFieldUpdateOperationsInput | boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    sizes?: ProductSizeUpdateManyWithoutProductNestedInput
    colorVariations?: ColorVariationUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    vendorProducts?: VendorProductUpdateManyWithoutBaseProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutValidatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasCustomDesigns?: BoolFieldUpdateOperationsInput | boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    sizes?: ProductSizeUncheckedUpdateManyWithoutProductNestedInput
    colorVariations?: ColorVariationUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    vendorProducts?: VendorProductUncheckedUpdateManyWithoutBaseProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutValidatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasCustomDesigns?: BoolFieldUpdateOperationsInput | boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VendorProductUpdateWithoutValidatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumVendorProductStatusFieldUpdateOperationsInput | $Enums.VendorProductStatus
    adminProductName?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductPrice?: NullableIntFieldUpdateOperationsInput | number | null
    designBase64?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designPositioning?: NullableStringFieldUpdateOperationsInput | string | null
    designScale?: NullableFloatFieldUpdateOperationsInput | number | null
    designApplicationMode?: NullableStringFieldUpdateOperationsInput | string | null
    sizes?: JsonNullValueInput | InputJsonValue
    colors?: JsonNullValueInput | InputJsonValue
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    vendorStock?: IntFieldUpdateOperationsInput | number
    basePriceAdmin?: FloatFieldUpdateOperationsInput | number
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: UserUpdateOneRequiredWithoutVendorProductsNestedInput
    baseProduct?: ProductUpdateOneRequiredWithoutVendorProductsNestedInput
    images?: VendorProductImageUpdateManyWithoutVendorProductNestedInput
    transformations?: DesignTransformationUpdateManyWithoutVendorProductNestedInput
  }

  export type VendorProductUncheckedUpdateWithoutValidatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    baseProductId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumVendorProductStatusFieldUpdateOperationsInput | $Enums.VendorProductStatus
    adminProductName?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductPrice?: NullableIntFieldUpdateOperationsInput | number | null
    designBase64?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designPositioning?: NullableStringFieldUpdateOperationsInput | string | null
    designScale?: NullableFloatFieldUpdateOperationsInput | number | null
    designApplicationMode?: NullableStringFieldUpdateOperationsInput | string | null
    sizes?: JsonNullValueInput | InputJsonValue
    colors?: JsonNullValueInput | InputJsonValue
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    vendorStock?: IntFieldUpdateOperationsInput | number
    basePriceAdmin?: FloatFieldUpdateOperationsInput | number
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VendorProductImageUncheckedUpdateManyWithoutVendorProductNestedInput
    transformations?: DesignTransformationUncheckedUpdateManyWithoutVendorProductNestedInput
  }

  export type VendorProductUncheckedUpdateManyWithoutValidatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    baseProductId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumVendorProductStatusFieldUpdateOperationsInput | $Enums.VendorProductStatus
    adminProductName?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductPrice?: NullableIntFieldUpdateOperationsInput | number | null
    designBase64?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designPositioning?: NullableStringFieldUpdateOperationsInput | string | null
    designScale?: NullableFloatFieldUpdateOperationsInput | number | null
    designApplicationMode?: NullableStringFieldUpdateOperationsInput | string | null
    sizes?: JsonNullValueInput | InputJsonValue
    colors?: JsonNullValueInput | InputJsonValue
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    vendorStock?: IntFieldUpdateOperationsInput | number
    basePriceAdmin?: FloatFieldUpdateOperationsInput | number
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorProductUpdateWithoutVendorInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumVendorProductStatusFieldUpdateOperationsInput | $Enums.VendorProductStatus
    adminProductName?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductPrice?: NullableIntFieldUpdateOperationsInput | number | null
    designBase64?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designPositioning?: NullableStringFieldUpdateOperationsInput | string | null
    designScale?: NullableFloatFieldUpdateOperationsInput | number | null
    designApplicationMode?: NullableStringFieldUpdateOperationsInput | string | null
    sizes?: JsonNullValueInput | InputJsonValue
    colors?: JsonNullValueInput | InputJsonValue
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    vendorStock?: IntFieldUpdateOperationsInput | number
    basePriceAdmin?: FloatFieldUpdateOperationsInput | number
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validator?: UserUpdateOneWithoutValidatedVendorProductsNestedInput
    baseProduct?: ProductUpdateOneRequiredWithoutVendorProductsNestedInput
    images?: VendorProductImageUpdateManyWithoutVendorProductNestedInput
    transformations?: DesignTransformationUpdateManyWithoutVendorProductNestedInput
  }

  export type VendorProductUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    baseProductId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumVendorProductStatusFieldUpdateOperationsInput | $Enums.VendorProductStatus
    adminProductName?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductPrice?: NullableIntFieldUpdateOperationsInput | number | null
    designBase64?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designPositioning?: NullableStringFieldUpdateOperationsInput | string | null
    designScale?: NullableFloatFieldUpdateOperationsInput | number | null
    designApplicationMode?: NullableStringFieldUpdateOperationsInput | string | null
    sizes?: JsonNullValueInput | InputJsonValue
    colors?: JsonNullValueInput | InputJsonValue
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    vendorStock?: IntFieldUpdateOperationsInput | number
    basePriceAdmin?: FloatFieldUpdateOperationsInput | number
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VendorProductImageUncheckedUpdateManyWithoutVendorProductNestedInput
    transformations?: DesignTransformationUncheckedUpdateManyWithoutVendorProductNestedInput
  }

  export type VendorProductUncheckedUpdateManyWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    baseProductId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumVendorProductStatusFieldUpdateOperationsInput | $Enums.VendorProductStatus
    adminProductName?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductPrice?: NullableIntFieldUpdateOperationsInput | number | null
    designBase64?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designPositioning?: NullableStringFieldUpdateOperationsInput | string | null
    designScale?: NullableFloatFieldUpdateOperationsInput | number | null
    designApplicationMode?: NullableStringFieldUpdateOperationsInput | string | null
    sizes?: JsonNullValueInput | InputJsonValue
    colors?: JsonNullValueInput | InputJsonValue
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    vendorStock?: IntFieldUpdateOperationsInput | number
    basePriceAdmin?: FloatFieldUpdateOperationsInput | number
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductSizeCreateManyProductInput = {
    id?: number
    sizeName: string
  }

  export type ColorVariationCreateManyProductInput = {
    id?: number
    name: string
    colorCode: string
  }

  export type OrderItemCreateManyProductInput = {
    id?: number
    orderId: number
    quantity: number
    unitPrice: number
    size?: string | null
    color?: string | null
    colorId?: number | null
  }

  export type VendorProductCreateManyBaseProductInput = {
    id?: number
    vendorId: number
    name: string
    description?: string | null
    price: number
    stock?: number
    status?: $Enums.VendorProductStatus
    adminProductName?: string | null
    adminProductDescription?: string | null
    adminProductPrice?: number | null
    designBase64?: string | null
    designCloudinaryUrl?: string | null
    designCloudinaryPublicId?: string | null
    designPositioning?: string | null
    designScale?: number | null
    designApplicationMode?: string | null
    sizes: JsonNullValueInput | InputJsonValue
    colors: JsonNullValueInput | InputJsonValue
    vendorName?: string | null
    vendorDescription?: string | null
    vendorStock?: number
    basePriceAdmin?: number
    isValidated?: boolean
    validatedAt?: Date | string | null
    validatedBy?: number | null
    rejectionReason?: string | null
    submittedForValidationAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductSizeUpdateWithoutProductInput = {
    sizeName?: StringFieldUpdateOperationsInput | string
  }

  export type ProductSizeUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    sizeName?: StringFieldUpdateOperationsInput | string
  }

  export type ProductSizeUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    sizeName?: StringFieldUpdateOperationsInput | string
  }

  export type ColorVariationUpdateWithoutProductInput = {
    name?: StringFieldUpdateOperationsInput | string
    colorCode?: StringFieldUpdateOperationsInput | string
    images?: ProductImageUpdateManyWithoutColorVariationNestedInput
    orderItems?: OrderItemUpdateManyWithoutColorVariationNestedInput
    vendorProductImages?: VendorProductImageUpdateManyWithoutColorVariationNestedInput
  }

  export type ColorVariationUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    colorCode?: StringFieldUpdateOperationsInput | string
    images?: ProductImageUncheckedUpdateManyWithoutColorVariationNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutColorVariationNestedInput
    vendorProductImages?: VendorProductImageUncheckedUpdateManyWithoutColorVariationNestedInput
  }

  export type ColorVariationUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    colorCode?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
    colorVariation?: ColorVariationUpdateOneWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VendorProductUpdateWithoutBaseProductInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumVendorProductStatusFieldUpdateOperationsInput | $Enums.VendorProductStatus
    adminProductName?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductPrice?: NullableIntFieldUpdateOperationsInput | number | null
    designBase64?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designPositioning?: NullableStringFieldUpdateOperationsInput | string | null
    designScale?: NullableFloatFieldUpdateOperationsInput | number | null
    designApplicationMode?: NullableStringFieldUpdateOperationsInput | string | null
    sizes?: JsonNullValueInput | InputJsonValue
    colors?: JsonNullValueInput | InputJsonValue
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    vendorStock?: IntFieldUpdateOperationsInput | number
    basePriceAdmin?: FloatFieldUpdateOperationsInput | number
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validator?: UserUpdateOneWithoutValidatedVendorProductsNestedInput
    vendor?: UserUpdateOneRequiredWithoutVendorProductsNestedInput
    images?: VendorProductImageUpdateManyWithoutVendorProductNestedInput
    transformations?: DesignTransformationUpdateManyWithoutVendorProductNestedInput
  }

  export type VendorProductUncheckedUpdateWithoutBaseProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumVendorProductStatusFieldUpdateOperationsInput | $Enums.VendorProductStatus
    adminProductName?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductPrice?: NullableIntFieldUpdateOperationsInput | number | null
    designBase64?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designPositioning?: NullableStringFieldUpdateOperationsInput | string | null
    designScale?: NullableFloatFieldUpdateOperationsInput | number | null
    designApplicationMode?: NullableStringFieldUpdateOperationsInput | string | null
    sizes?: JsonNullValueInput | InputJsonValue
    colors?: JsonNullValueInput | InputJsonValue
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    vendorStock?: IntFieldUpdateOperationsInput | number
    basePriceAdmin?: FloatFieldUpdateOperationsInput | number
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VendorProductImageUncheckedUpdateManyWithoutVendorProductNestedInput
    transformations?: DesignTransformationUncheckedUpdateManyWithoutVendorProductNestedInput
  }

  export type VendorProductUncheckedUpdateManyWithoutBaseProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumVendorProductStatusFieldUpdateOperationsInput | $Enums.VendorProductStatus
    adminProductName?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    adminProductPrice?: NullableIntFieldUpdateOperationsInput | number | null
    designBase64?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designCloudinaryPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designPositioning?: NullableStringFieldUpdateOperationsInput | string | null
    designScale?: NullableFloatFieldUpdateOperationsInput | number | null
    designApplicationMode?: NullableStringFieldUpdateOperationsInput | string | null
    sizes?: JsonNullValueInput | InputJsonValue
    colors?: JsonNullValueInput | InputJsonValue
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    vendorStock?: IntFieldUpdateOperationsInput | number
    basePriceAdmin?: FloatFieldUpdateOperationsInput | number
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasCustomDesigns?: BoolFieldUpdateOperationsInput | boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    validator?: UserUpdateOneWithoutValidatedProductsNestedInput
    sizes?: ProductSizeUpdateManyWithoutProductNestedInput
    colorVariations?: ColorVariationUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    vendorProducts?: VendorProductUpdateManyWithoutBaseProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasCustomDesigns?: BoolFieldUpdateOperationsInput | boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
    sizes?: ProductSizeUncheckedUpdateManyWithoutProductNestedInput
    colorVariations?: ColorVariationUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    vendorProducts?: VendorProductUncheckedUpdateManyWithoutBaseProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValidated?: BoolFieldUpdateOperationsInput | boolean
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForValidationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasCustomDesigns?: BoolFieldUpdateOperationsInput | boolean
    designsMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductImageCreateManyColorVariationInput = {
    id?: number
    view: string
    url: string
    publicId: string
    naturalWidth?: number | null
    naturalHeight?: number | null
    designUrl?: string | null
    designPublicId?: string | null
    designFileName?: string | null
    designUploadDate?: Date | string | null
    designSize?: number | null
    designOriginalName?: string | null
    designDescription?: string | null
    isDesignActive?: boolean
  }

  export type OrderItemCreateManyColorVariationInput = {
    id?: number
    orderId: number
    productId: number
    quantity: number
    unitPrice: number
    size?: string | null
    color?: string | null
  }

  export type VendorProductImageCreateManyColorVariationInput = {
    id?: number
    vendorProductId: number
    colorName?: string | null
    colorCode?: string | null
    imageType?: string
    cloudinaryUrl: string
    cloudinaryPublicId: string
    originalImageKey?: string | null
    width?: number | null
    height?: number | null
    fileSize?: number | null
    format?: string | null
    createdAt?: Date | string
    uploadedAt?: Date | string
  }

  export type ProductImageUpdateWithoutColorVariationInput = {
    view?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    naturalWidth?: NullableIntFieldUpdateOperationsInput | number | null
    naturalHeight?: NullableIntFieldUpdateOperationsInput | number | null
    designUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designFileName?: NullableStringFieldUpdateOperationsInput | string | null
    designUploadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designSize?: NullableIntFieldUpdateOperationsInput | number | null
    designOriginalName?: NullableStringFieldUpdateOperationsInput | string | null
    designDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isDesignActive?: BoolFieldUpdateOperationsInput | boolean
    delimitations?: DelimitationUpdateManyWithoutProductImageNestedInput
  }

  export type ProductImageUncheckedUpdateWithoutColorVariationInput = {
    id?: IntFieldUpdateOperationsInput | number
    view?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    naturalWidth?: NullableIntFieldUpdateOperationsInput | number | null
    naturalHeight?: NullableIntFieldUpdateOperationsInput | number | null
    designUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designFileName?: NullableStringFieldUpdateOperationsInput | string | null
    designUploadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designSize?: NullableIntFieldUpdateOperationsInput | number | null
    designOriginalName?: NullableStringFieldUpdateOperationsInput | string | null
    designDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isDesignActive?: BoolFieldUpdateOperationsInput | boolean
    delimitations?: DelimitationUncheckedUpdateManyWithoutProductImageNestedInput
  }

  export type ProductImageUncheckedUpdateManyWithoutColorVariationInput = {
    id?: IntFieldUpdateOperationsInput | number
    view?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    naturalWidth?: NullableIntFieldUpdateOperationsInput | number | null
    naturalHeight?: NullableIntFieldUpdateOperationsInput | number | null
    designUrl?: NullableStringFieldUpdateOperationsInput | string | null
    designPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    designFileName?: NullableStringFieldUpdateOperationsInput | string | null
    designUploadDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designSize?: NullableIntFieldUpdateOperationsInput | number | null
    designOriginalName?: NullableStringFieldUpdateOperationsInput | string | null
    designDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isDesignActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderItemUpdateWithoutColorVariationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutColorVariationInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyWithoutColorVariationInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VendorProductImageUpdateWithoutColorVariationInput = {
    colorName?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: StringFieldUpdateOperationsInput | string
    cloudinaryUrl?: StringFieldUpdateOperationsInput | string
    cloudinaryPublicId?: StringFieldUpdateOperationsInput | string
    originalImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorProduct?: VendorProductUpdateOneRequiredWithoutImagesNestedInput
  }

  export type VendorProductImageUncheckedUpdateWithoutColorVariationInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorProductId?: IntFieldUpdateOperationsInput | number
    colorName?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: StringFieldUpdateOperationsInput | string
    cloudinaryUrl?: StringFieldUpdateOperationsInput | string
    cloudinaryPublicId?: StringFieldUpdateOperationsInput | string
    originalImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorProductImageUncheckedUpdateManyWithoutColorVariationInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorProductId?: IntFieldUpdateOperationsInput | number
    colorName?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: StringFieldUpdateOperationsInput | string
    cloudinaryUrl?: StringFieldUpdateOperationsInput | string
    cloudinaryPublicId?: StringFieldUpdateOperationsInput | string
    originalImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DelimitationCreateManyProductImageInput = {
    id?: number
    x: number
    y: number
    width: number
    height: number
    rotation?: number
    name?: string | null
    coordinateType?: $Enums.CoordinateType
    absoluteX?: number | null
    absoluteY?: number | null
    absoluteWidth?: number | null
    absoluteHeight?: number | null
    originalImageWidth?: number | null
    originalImageHeight?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceWidth?: number
    referenceHeight?: number
  }

  export type DelimitationUpdateWithoutProductImageInput = {
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    coordinateType?: EnumCoordinateTypeFieldUpdateOperationsInput | $Enums.CoordinateType
    absoluteX?: NullableFloatFieldUpdateOperationsInput | number | null
    absoluteY?: NullableFloatFieldUpdateOperationsInput | number | null
    absoluteWidth?: NullableFloatFieldUpdateOperationsInput | number | null
    absoluteHeight?: NullableFloatFieldUpdateOperationsInput | number | null
    originalImageWidth?: NullableIntFieldUpdateOperationsInput | number | null
    originalImageHeight?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceWidth?: IntFieldUpdateOperationsInput | number
    referenceHeight?: IntFieldUpdateOperationsInput | number
  }

  export type DelimitationUncheckedUpdateWithoutProductImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    coordinateType?: EnumCoordinateTypeFieldUpdateOperationsInput | $Enums.CoordinateType
    absoluteX?: NullableFloatFieldUpdateOperationsInput | number | null
    absoluteY?: NullableFloatFieldUpdateOperationsInput | number | null
    absoluteWidth?: NullableFloatFieldUpdateOperationsInput | number | null
    absoluteHeight?: NullableFloatFieldUpdateOperationsInput | number | null
    originalImageWidth?: NullableIntFieldUpdateOperationsInput | number | null
    originalImageHeight?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceWidth?: IntFieldUpdateOperationsInput | number
    referenceHeight?: IntFieldUpdateOperationsInput | number
  }

  export type DelimitationUncheckedUpdateManyWithoutProductImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    coordinateType?: EnumCoordinateTypeFieldUpdateOperationsInput | $Enums.CoordinateType
    absoluteX?: NullableFloatFieldUpdateOperationsInput | number | null
    absoluteY?: NullableFloatFieldUpdateOperationsInput | number | null
    absoluteWidth?: NullableFloatFieldUpdateOperationsInput | number | null
    absoluteHeight?: NullableFloatFieldUpdateOperationsInput | number | null
    originalImageWidth?: NullableIntFieldUpdateOperationsInput | number | null
    originalImageHeight?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceWidth?: IntFieldUpdateOperationsInput | number
    referenceHeight?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemCreateManyOrderInput = {
    id?: number
    productId: number
    quantity: number
    unitPrice: number
    size?: string | null
    color?: string | null
    colorId?: number | null
  }

  export type OrderItemUpdateWithoutOrderInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
    colorVariation?: ColorVariationUpdateOneWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VendorProductImageCreateManyVendorProductInput = {
    id?: number
    colorId?: number | null
    colorName?: string | null
    colorCode?: string | null
    imageType?: string
    cloudinaryUrl: string
    cloudinaryPublicId: string
    originalImageKey?: string | null
    width?: number | null
    height?: number | null
    fileSize?: number | null
    format?: string | null
    createdAt?: Date | string
    uploadedAt?: Date | string
  }

  export type DesignTransformationCreateManyVendorProductInput = {
    id?: number
    delimitationIndex: number
    xOffset?: number
    yOffset?: number
    scaleFactor?: number
    positioning?: $Enums.DesignPositioning
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorProductImageUpdateWithoutVendorProductInput = {
    colorName?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: StringFieldUpdateOperationsInput | string
    cloudinaryUrl?: StringFieldUpdateOperationsInput | string
    cloudinaryPublicId?: StringFieldUpdateOperationsInput | string
    originalImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    colorVariation?: ColorVariationUpdateOneWithoutVendorProductImagesNestedInput
  }

  export type VendorProductImageUncheckedUpdateWithoutVendorProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    colorName?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: StringFieldUpdateOperationsInput | string
    cloudinaryUrl?: StringFieldUpdateOperationsInput | string
    cloudinaryPublicId?: StringFieldUpdateOperationsInput | string
    originalImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorProductImageUncheckedUpdateManyWithoutVendorProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    colorName?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: StringFieldUpdateOperationsInput | string
    cloudinaryUrl?: StringFieldUpdateOperationsInput | string
    cloudinaryPublicId?: StringFieldUpdateOperationsInput | string
    originalImageKey?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignTransformationUpdateWithoutVendorProductInput = {
    delimitationIndex?: IntFieldUpdateOperationsInput | number
    xOffset?: FloatFieldUpdateOperationsInput | number
    yOffset?: FloatFieldUpdateOperationsInput | number
    scaleFactor?: FloatFieldUpdateOperationsInput | number
    positioning?: EnumDesignPositioningFieldUpdateOperationsInput | $Enums.DesignPositioning
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignTransformationUncheckedUpdateWithoutVendorProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    delimitationIndex?: IntFieldUpdateOperationsInput | number
    xOffset?: FloatFieldUpdateOperationsInput | number
    yOffset?: FloatFieldUpdateOperationsInput | number
    scaleFactor?: FloatFieldUpdateOperationsInput | number
    positioning?: EnumDesignPositioningFieldUpdateOperationsInput | $Enums.DesignPositioning
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignTransformationUncheckedUpdateManyWithoutVendorProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    delimitationIndex?: IntFieldUpdateOperationsInput | number
    xOffset?: FloatFieldUpdateOperationsInput | number
    yOffset?: FloatFieldUpdateOperationsInput | number
    scaleFactor?: FloatFieldUpdateOperationsInput | number
    positioning?: EnumDesignPositioningFieldUpdateOperationsInput | $Enums.DesignPositioning
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}